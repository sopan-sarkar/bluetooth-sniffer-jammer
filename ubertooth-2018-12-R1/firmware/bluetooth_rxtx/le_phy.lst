ARM GAS  /tmp/ccnRyoKo.s 			page 1


   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 4
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"le_phy.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.le_dma_init,"ax",%progbits
  16              		.align	1
  17              		.syntax unified
  18              		.thumb
  19              		.thumb_func
  20              		.fpu softvfp
  22              	le_dma_init:
  23              	.LFB8:
  24              		.file 1 "le_phy.c"
   1:le_phy.c      **** /*
   2:le_phy.c      ****  * Copyright 2017 Mike Ryan
   3:le_phy.c      ****  *
   4:le_phy.c      ****  * This file is part of Project Ubertooth and is released under the
   5:le_phy.c      ****  * terms of the GPL. Refer to COPYING for more information.
   6:le_phy.c      ****  */
   7:le_phy.c      **** 
   8:le_phy.c      **** #include <stdlib.h>
   9:le_phy.c      **** #include <string.h>
  10:le_phy.c      **** 
  11:le_phy.c      **** #include "ubertooth.h"
  12:le_phy.c      **** #include "ubertooth_clock.h"
  13:le_phy.c      **** #include "ubertooth_dma.h"
  14:le_phy.c      **** #include "ubertooth_usb.h"
  15:le_phy.c      **** #include "bluetooth_le.h"
  16:le_phy.c      **** #include "queue.h"
  17:le_phy.c      **** 
  18:le_phy.c      **** // current time, from timer1
  19:le_phy.c      **** #define NOW T1TC
  20:le_phy.c      **** #define USEC(X) ((X)*10)
  21:le_phy.c      **** #define MSEC(X) ((X)*10000)
  22:le_phy.c      **** #define  SEC(X) ((X)*10000000)
  23:le_phy.c      **** #define PACKET_DURATION(X) (USEC(40 + (X)->size * 8))
  24:le_phy.c      **** 
  25:le_phy.c      **** #define ADVERTISING_AA (0x8e89bed6)
  26:le_phy.c      **** 
  27:le_phy.c      **** ///////////////////////
  28:le_phy.c      **** // time constants
  29:le_phy.c      **** 
  30:le_phy.c      **** // time for the radio to warmup + some timing slack
  31:le_phy.c      **** #define RX_WARMUP_TIME USEC(300)
  32:le_phy.c      **** 
  33:le_phy.c      **** // max inter-frame space between packets in a connection event
  34:le_phy.c      **** #define IFS_TIMEOUT USEC(300)
ARM GAS  /tmp/ccnRyoKo.s 			page 2


  35:le_phy.c      **** 
  36:le_phy.c      **** // observed connection anchor must be within ANCHOR_EPSILON of
  37:le_phy.c      **** // calculated anchor
  38:le_phy.c      **** #define ANCHOR_EPSILON USEC(3)
  39:le_phy.c      **** 
  40:le_phy.c      **** 
  41:le_phy.c      **** //////////////////////
  42:le_phy.c      **** // global state
  43:le_phy.c      **** 
  44:le_phy.c      **** extern le_state_t le; // FIXME - refactor this struct
  45:le_phy.c      **** volatile uint16_t rf_channel;
  46:le_phy.c      **** uint8_t le_dma_dest[2];
  47:le_phy.c      **** 
  48:le_phy.c      **** extern volatile uint8_t mode;
  49:le_phy.c      **** extern volatile uint8_t requested_mode;
  50:le_phy.c      **** extern volatile uint16_t le_adv_channel;
  51:le_phy.c      **** extern volatile int cancel_follow;
  52:le_phy.c      **** 
  53:le_phy.c      **** ////////////////////
  54:le_phy.c      **** // buffers
  55:le_phy.c      **** 
  56:le_phy.c      **** // packet buffers live in a pool. a minimum of one buffer is always
  57:le_phy.c      **** // being used, either waiting to receive or actively receiving a packet
  58:le_phy.c      **** // (current_rxbuf). once a packet is received, it is placed into the
  59:le_phy.c      **** // packet queue. the main loop pulls packets from this queue and
  60:le_phy.c      **** // processes them, and then returns the buffers back to the pool by
  61:le_phy.c      **** // calling buffer_release()
  62:le_phy.c      **** 
  63:le_phy.c      **** #define LE_BUFFER_POOL_SIZE 4
  64:le_phy.c      **** typedef struct _le_rx_t {
  65:le_phy.c      **** 	uint8_t data[2 + 255 + 3];  // header + PDU + CRC
  66:le_phy.c      **** 	unsigned size;              // total data length (known after header rx)
  67:le_phy.c      **** 	unsigned pos;               // current input byte offset
  68:le_phy.c      **** 	uint32_t timestamp;         // timestamp taken after first byte rx
  69:le_phy.c      **** 	unsigned channel;           // physical channel
  70:le_phy.c      **** 	uint32_t access_address;    // access address
  71:le_phy.c      **** 	int available;              // 1 if available, 0 in use
  72:le_phy.c      **** 	int8_t rssi_min, rssi_max;  // min and max RSSI observed values
  73:le_phy.c      **** 	int rssi_sum;               // running sum of all RSSI values
  74:le_phy.c      **** } le_rx_t;
  75:le_phy.c      **** 
  76:le_phy.c      **** // pool of all buffers
  77:le_phy.c      **** static le_rx_t le_buffer_pool[LE_BUFFER_POOL_SIZE];
  78:le_phy.c      **** 
  79:le_phy.c      **** // buffer waiting for or actively receiving packet
  80:le_phy.c      **** static le_rx_t *current_rxbuf = NULL;
  81:le_phy.c      **** 
  82:le_phy.c      **** // received packets, waiting to be processed
  83:le_phy.c      **** queue_t packet_queue;
  84:le_phy.c      **** 
  85:le_phy.c      **** 
  86:le_phy.c      **** /////////////////////
  87:le_phy.c      **** // connections
  88:le_phy.c      **** 
  89:le_phy.c      **** // this system is architected so that following multiple connections may
  90:le_phy.c      **** // be possible in the future. all connection state lives in an le_conn_t
  91:le_phy.c      **** // struct. at present only one such structure exists. refer to
ARM GAS  /tmp/ccnRyoKo.s 			page 3


  92:le_phy.c      **** // connection event below for how anchors are handled.
  93:le_phy.c      **** 
  94:le_phy.c      **** typedef struct _le_conn_t {
  95:le_phy.c      **** 	uint32_t access_address;
  96:le_phy.c      **** 	uint32_t crc_init;
  97:le_phy.c      **** 	uint32_t crc_init_reversed;
  98:le_phy.c      **** 
  99:le_phy.c      **** 	uint8_t  channel_idx;
 100:le_phy.c      **** 	uint8_t  hop_increment;
 101:le_phy.c      **** 	uint32_t conn_interval; // in units of 100 ns
 102:le_phy.c      **** 	uint32_t supervision_timeout; // in units of 100 ns
 103:le_phy.c      **** 
 104:le_phy.c      **** 	uint8_t  win_size;
 105:le_phy.c      **** 	uint32_t win_offset; // in units of 100 ns
 106:le_phy.c      **** 
 107:le_phy.c      **** 	le_channel_remapping_t remapping;
 108:le_phy.c      **** 
 109:le_phy.c      **** 	uint32_t last_anchor;
 110:le_phy.c      **** 	int      anchor_set;
 111:le_phy.c      **** 	uint32_t last_packet_ts; // used to check supervision timeout
 112:le_phy.c      **** 
 113:le_phy.c      **** 	uint16_t conn_event_counter;
 114:le_phy.c      **** 
 115:le_phy.c      **** 	int      conn_update_pending;
 116:le_phy.c      **** 	uint32_t conn_update_pending_interval;
 117:le_phy.c      **** 	uint32_t conn_update_pending_supervision_timeout;
 118:le_phy.c      **** 	uint16_t conn_update_instant;
 119:le_phy.c      **** 
 120:le_phy.c      **** 	int      channel_map_update_pending;
 121:le_phy.c      **** 	uint16_t channel_map_update_instant;
 122:le_phy.c      **** 	le_channel_remapping_t pending_remapping;
 123:le_phy.c      **** } le_conn_t;
 124:le_phy.c      **** le_conn_t conn = { 0, };
 125:le_phy.c      **** 
 126:le_phy.c      **** // every connection event is tracked using this global le_conn_event_t
 127:le_phy.c      **** // structure named conn_event. when a packet is observed, anchor is set.
 128:le_phy.c      **** // the event may close due to receiving two packets, or if a timeout
 129:le_phy.c      **** // occurs. in both cases, finish_conn_event() is called, which updates
 130:le_phy.c      **** // the active connection's anchor. opened is set to 1 once the radio is
 131:le_phy.c      **** // tuned to the data channel for the connection event.
 132:le_phy.c      **** typedef struct _le_conn_event_t {
 133:le_phy.c      **** 	uint32_t anchor;
 134:le_phy.c      **** 	unsigned num_packets;
 135:le_phy.c      **** 	int opened;
 136:le_phy.c      **** } le_conn_event_t;
 137:le_phy.c      **** le_conn_event_t conn_event;
 138:le_phy.c      **** 
 139:le_phy.c      **** static void reset_conn(void) {
 140:le_phy.c      **** 	memset(&conn, 0, sizeof(conn));
 141:le_phy.c      **** 	conn.access_address = ADVERTISING_AA;
 142:le_phy.c      **** }
 143:le_phy.c      **** 
 144:le_phy.c      **** 
 145:le_phy.c      **** //////////////////////
 146:le_phy.c      **** // code
 147:le_phy.c      **** 
 148:le_phy.c      **** // pre-declarations for utility stuff
ARM GAS  /tmp/ccnRyoKo.s 			page 4


 149:le_phy.c      **** static void timer1_start(void);
 150:le_phy.c      **** static void timer1_stop(void);
 151:le_phy.c      **** static void timer1_set_match(uint32_t match);
 152:le_phy.c      **** static void timer1_clear_match(void);
 153:le_phy.c      **** static void timer1_wait_fs_lock(void);
 154:le_phy.c      **** static void timer1_cancel_fs_lock(void);
 155:le_phy.c      **** static void blink(int tx, int rx, int usr);
 156:le_phy.c      **** static void le_dma_init(void);
 157:le_phy.c      **** static void le_cc2400_strobe_rx(void);
 158:le_phy.c      **** static void change_channel(void);
 159:le_phy.c      **** static uint8_t dewhiten_length(unsigned channel, uint8_t data);
 160:le_phy.c      **** 
 161:le_phy.c      **** // resets the state of all available buffers
 162:le_phy.c      **** static void buffers_init(void) {
 163:le_phy.c      **** 	int i;
 164:le_phy.c      **** 
 165:le_phy.c      **** 	for (i = 0; i < LE_BUFFER_POOL_SIZE; ++i)
 166:le_phy.c      **** 		le_buffer_pool[i].available = 1;
 167:le_phy.c      **** }
 168:le_phy.c      **** 
 169:le_phy.c      **** // clear a buffer for new data
 170:le_phy.c      **** static void buffer_clear(le_rx_t *buf) {
 171:le_phy.c      **** 	buf->pos = 0;
 172:le_phy.c      **** 	buf->size = 0;
 173:le_phy.c      **** 	memset(buf->data, 0, sizeof(buf->data));
 174:le_phy.c      **** 	buf->rssi_min = INT8_MAX;
 175:le_phy.c      **** 	buf->rssi_max = INT8_MIN;
 176:le_phy.c      **** 	buf->rssi_sum = 0;
 177:le_phy.c      **** }
 178:le_phy.c      **** 
 179:le_phy.c      **** // get a packet buffer
 180:le_phy.c      **** // returns a pointer to a buffer if available
 181:le_phy.c      **** // returns NULL otherwise
 182:le_phy.c      **** static le_rx_t *buffer_get(void) {
 183:le_phy.c      **** 	int i;
 184:le_phy.c      **** 
 185:le_phy.c      **** 	for (i = 0; i < LE_BUFFER_POOL_SIZE; ++i) {
 186:le_phy.c      **** 		if (le_buffer_pool[i].available) {
 187:le_phy.c      **** 			le_buffer_pool[i].available = 0;
 188:le_phy.c      **** 			buffer_clear(&le_buffer_pool[i]);
 189:le_phy.c      **** 			return &le_buffer_pool[i];
 190:le_phy.c      **** 		}
 191:le_phy.c      **** 	}
 192:le_phy.c      **** 
 193:le_phy.c      **** 	return NULL;
 194:le_phy.c      **** }
 195:le_phy.c      **** 
 196:le_phy.c      **** // release a buffer back to the pool
 197:le_phy.c      **** static void buffer_release(le_rx_t *buffer) {
 198:le_phy.c      **** 	buffer->available = 1;
 199:le_phy.c      **** }
 200:le_phy.c      **** 
 201:le_phy.c      **** // clear a connection event
 202:le_phy.c      **** static void reset_conn_event(void) {
 203:le_phy.c      **** 	conn_event.num_packets = 0;
 204:le_phy.c      **** 	conn_event.opened = 0;
 205:le_phy.c      **** }
ARM GAS  /tmp/ccnRyoKo.s 			page 5


 206:le_phy.c      **** 
 207:le_phy.c      **** // finish a connection event
 208:le_phy.c      **** //
 209:le_phy.c      **** // 1) update the anchor point (see details below)
 210:le_phy.c      **** // 2) increment connection event counter
 211:le_phy.c      **** // 3) check if supervision timeout is exceeded
 212:le_phy.c      **** // 4) setup radio for next packet (data or adv if timeout exceeded)
 213:le_phy.c      **** //
 214:le_phy.c      **** // anchor update logic can be summarized thusly:
 215:le_phy.c      **** // 1) if we received two packets, set the connection anchor to the
 216:le_phy.c      **** //    observed value
 217:le_phy.c      **** // 2) if we received one packet, see if it's within ANCHOR_EPISLON
 218:le_phy.c      **** //    microseconds if the expected anchor time. if so, it's the master
 219:le_phy.c      **** //    and we can update the anchor
 220:le_phy.c      **** // 3) if the single packet is a slave or we received zero packets,
 221:le_phy.c      **** //    update the anchor to the estimated value
 222:le_phy.c      **** //
 223:le_phy.c      **** // FIXME this code does not properly handle the case where the initial
 224:le_phy.c      **** // connection transmit window has no received packets
 225:le_phy.c      **** static void finish_conn_event(void) {
 226:le_phy.c      **** 	uint32_t last_anchor = 0;
 227:le_phy.c      **** 	int last_anchor_set = 0;
 228:le_phy.c      **** 	// two packets -- update anchor
 229:le_phy.c      **** 	if (conn_event.num_packets == 2) {
 230:le_phy.c      **** 		last_anchor = conn_event.anchor;
 231:le_phy.c      **** 		last_anchor_set = 1;
 232:le_phy.c      **** 	}
 233:le_phy.c      **** 
 234:le_phy.c      **** 	// if there's one packet, we need to find out if it was the master
 235:le_phy.c      **** 	else if (conn_event.num_packets == 1 && conn.anchor_set) {
 236:le_phy.c      **** 		// calculate the difference between the estimated and observed anchor
 237:le_phy.c      **** 		uint32_t estimated_anchor = conn.last_anchor + conn.conn_interval;
 238:le_phy.c      **** 		uint32_t delta = estimated_anchor - conn_event.anchor;
 239:le_phy.c      **** 		// see whether the observed anchor is within 3 us of the estimate
 240:le_phy.c      **** 		delta += ANCHOR_EPSILON;
 241:le_phy.c      **** 		if (delta < 2 * ANCHOR_EPSILON) {
 242:le_phy.c      **** 			last_anchor = conn_event.anchor;
 243:le_phy.c      **** 			last_anchor_set = 1;
 244:le_phy.c      **** 		}
 245:le_phy.c      **** 	}
 246:le_phy.c      **** 
 247:le_phy.c      **** 	// if we observed a new anchor, set it
 248:le_phy.c      **** 	if (last_anchor_set) {
 249:le_phy.c      **** 		conn.last_anchor = last_anchor;
 250:le_phy.c      **** 		conn.anchor_set = 1;
 251:le_phy.c      **** 	}
 252:le_phy.c      **** 
 253:le_phy.c      **** 	// without a new anchor, estimate the next anchor
 254:le_phy.c      **** 	else if (conn.anchor_set) {
 255:le_phy.c      **** 		conn.last_anchor += conn.conn_interval;
 256:le_phy.c      **** 	}
 257:le_phy.c      **** 
 258:le_phy.c      **** 	else {
 259:le_phy.c      **** 		// FIXME this is totally broken if we receive the slave's packet first
 260:le_phy.c      **** 		conn.last_anchor = conn_event.anchor;
 261:le_phy.c      **** 		conn.last_packet_ts = NOW; // FIXME gross hack
 262:le_phy.c      **** 	}
ARM GAS  /tmp/ccnRyoKo.s 			page 6


 263:le_phy.c      **** 
 264:le_phy.c      **** 	// update last packet for supervision timeout
 265:le_phy.c      **** 	if (conn_event.num_packets > 0) {
 266:le_phy.c      **** 		conn.last_packet_ts = NOW;
 267:le_phy.c      **** 	}
 268:le_phy.c      **** 
 269:le_phy.c      **** 	reset_conn_event();
 270:le_phy.c      **** 
 271:le_phy.c      **** 	// increment connection event counter
 272:le_phy.c      **** 	++conn.conn_event_counter;
 273:le_phy.c      **** 
 274:le_phy.c      **** 	// supervision timeout reached - switch back to advertising
 275:le_phy.c      **** 	if (NOW - conn.last_packet_ts > conn.supervision_timeout) {
 276:le_phy.c      **** 		reset_conn();
 277:le_phy.c      **** 		change_channel();
 278:le_phy.c      **** 	}
 279:le_phy.c      **** 
 280:le_phy.c      **** 	// FIXME - hack to cancel following a connection
 281:le_phy.c      **** 	else if (cancel_follow) {
 282:le_phy.c      **** 		cancel_follow = 0;
 283:le_phy.c      **** 		reset_conn();
 284:le_phy.c      **** 		change_channel();
 285:le_phy.c      **** 	}
 286:le_phy.c      **** 
 287:le_phy.c      **** 	// supervision timeout not reached - hop to next channel
 288:le_phy.c      **** 	else {
 289:le_phy.c      **** 		timer1_set_match(conn.last_anchor + conn.conn_interval - RX_WARMUP_TIME);
 290:le_phy.c      **** 	}
 291:le_phy.c      **** }
 292:le_phy.c      **** 
 293:le_phy.c      **** // DMA handler
 294:le_phy.c      **** // called once per byte. handles all incoming data, but only minimally
 295:le_phy.c      **** // processes received data. at the end of a packet, it enqueues the
 296:le_phy.c      **** // received packet, fetches a new buffer, and restarts RX.
 297:le_phy.c      **** void le_DMA_IRQHandler(void) {
 298:le_phy.c      ****     debug_printf("le_DMA_IRQHandler\n");
 299:le_phy.c      **** 	unsigned pos;
 300:le_phy.c      **** 	int8_t rssi;
 301:le_phy.c      **** 	uint32_t timestamp = NOW; // sampled early for most accurate measurement
 302:le_phy.c      **** 
 303:le_phy.c      **** 	// channel 0
 304:le_phy.c      **** 	if (DMACIntStat & (1 << 0)) {
 305:le_phy.c      **** 		// terminal count - byte received
 306:le_phy.c      **** 		if (DMACIntTCStat & (1 << 0)) {
 307:le_phy.c      **** 			DMACIntTCClear = (1 << 0);
 308:le_phy.c      **** 
 309:le_phy.c      **** 			// poll RSSI
 310:le_phy.c      **** 			rssi = (int8_t)(cc2400_get(RSSI) >> 8);
 311:le_phy.c      **** 			current_rxbuf->rssi_sum += rssi;
 312:le_phy.c      **** 			if (rssi < current_rxbuf->rssi_min) current_rxbuf->rssi_min = rssi;
 313:le_phy.c      **** 			if (rssi > current_rxbuf->rssi_max) current_rxbuf->rssi_max = rssi;
 314:le_phy.c      **** 
 315:le_phy.c      **** 			// grab byte from DMA buffer
 316:le_phy.c      **** 			pos = current_rxbuf->pos;
 317:le_phy.c      **** 			current_rxbuf->data[pos] = le_dma_dest[pos & 1]; // dirty hack
 318:le_phy.c      **** 			pos += 1;
 319:le_phy.c      **** 			current_rxbuf->pos = pos;
ARM GAS  /tmp/ccnRyoKo.s 			page 7


 320:le_phy.c      **** 
 321:le_phy.c      **** 			if (pos == 1) {
 322:le_phy.c      **** 				current_rxbuf->timestamp = timestamp - USEC(8 + 32); // packet starts at preamble
 323:le_phy.c      **** 				current_rxbuf->channel = rf_channel;
 324:le_phy.c      **** 				current_rxbuf->access_address = conn.access_address;
 325:le_phy.c      **** 
 326:le_phy.c      **** 				// data packet received: cancel timeout
 327:le_phy.c      **** 				// new timeout or hop timer will be set at end of packet RX
 328:le_phy.c      **** 				if (btle_channel_index(rf_channel) < 37) {
 329:le_phy.c      **** 					timer1_clear_match();
 330:le_phy.c      **** 				}
 331:le_phy.c      **** 			}
 332:le_phy.c      **** 
 333:le_phy.c      **** 			// get length from header
 334:le_phy.c      **** 			if (pos == 2) {
 335:le_phy.c      **** 				uint8_t length = dewhiten_length(current_rxbuf->channel, current_rxbuf->data[1]);
 336:le_phy.c      **** 				current_rxbuf->size = length + 2 + 3; // two bytes for header and three for CRC
 337:le_phy.c      **** 			}
 338:le_phy.c      **** 
 339:le_phy.c      **** 			// finished packet - state transition
 340:le_phy.c      **** 			if (pos > 2 && pos >= current_rxbuf->size) {
 341:le_phy.c      **** 				// stop the CC2400 before flushing SSP
 342:le_phy.c      **** 				cc2400_strobe(SFSON);
 343:le_phy.c      **** 
 344:le_phy.c      **** 				// stop DMA on this channel and flush SSP
 345:le_phy.c      **** 				DMACC0Config = 0;
 346:le_phy.c      **** 				DMACIntTCClear = (1 << 0); // if we don't clear a second time, data is corrupt
 347:le_phy.c      **** 
 348:le_phy.c      **** 				DIO_SSP_DMACR &= ~SSPDMACR_RXDMAE;
 349:le_phy.c      **** 				while (SSP1SR & SSPSR_RNE) {
 350:le_phy.c      **** 					uint8_t tmp = (uint8_t)DIO_SSP_DR;
 351:le_phy.c      **** 				}
 352:le_phy.c      **** 
 353:le_phy.c      **** 				// TODO error transition on queue_insert
 354:le_phy.c      **** 				queue_insert(&packet_queue, current_rxbuf);
 355:le_phy.c      **** 
 356:le_phy.c      **** 				// track connection events
 357:le_phy.c      **** 				if (btle_channel_index(rf_channel) < 37) {
 358:le_phy.c      **** 					++conn_event.num_packets;
 359:le_phy.c      **** 
 360:le_phy.c      **** 					// first packet: set connection anchor
 361:le_phy.c      **** 					if (conn_event.num_packets == 1) {
 362:le_phy.c      **** 						conn_event.anchor = current_rxbuf->timestamp;
 363:le_phy.c      **** 						timer1_set_match(NOW + IFS_TIMEOUT); // set a timeout for next packet
 364:le_phy.c      **** 					}
 365:le_phy.c      **** 
 366:le_phy.c      **** 					// second packet: close connection event, and set hop timer
 367:le_phy.c      **** 					else if (conn_event.num_packets == 2) {
 368:le_phy.c      **** 						cc2400_strobe(SRFOFF);
 369:le_phy.c      **** 						current_rxbuf = buffer_get();
 370:le_phy.c      **** 						finish_conn_event();
 371:le_phy.c      **** 						return;
 372:le_phy.c      **** 					}
 373:le_phy.c      **** 				}
 374:le_phy.c      **** 
 375:le_phy.c      **** 				// get a new packet
 376:le_phy.c      **** 				// TODO handle error transition
ARM GAS  /tmp/ccnRyoKo.s 			page 8


 377:le_phy.c      **** 				current_rxbuf = buffer_get();
 378:le_phy.c      **** 
 379:le_phy.c      **** 				// restart DMA and SSP
 380:le_phy.c      **** 				le_dma_init();
 381:le_phy.c      **** 				dio_ssp_start();
 382:le_phy.c      **** 
 383:le_phy.c      **** 				// wait for FS_LOCK in background
 384:le_phy.c      **** 				timer1_wait_fs_lock();
 385:le_phy.c      **** 			}
 386:le_phy.c      **** 		}
 387:le_phy.c      **** 
 388:le_phy.c      **** 		// error - transition to error state
 389:le_phy.c      **** 		if (DMACIntErrStat & (1 << 0)) {
 390:le_phy.c      **** 			// TODO error state transition
 391:le_phy.c      **** 			DMACIntErrClr = (1 << 0);
 392:le_phy.c      **** 		}
 393:le_phy.c      **** 	}
 394:le_phy.c      **** }
 395:le_phy.c      **** 
 396:le_phy.c      **** static void le_dma_init(void) {
  25              		.loc 1 396 0
  26              		.cfi_startproc
  27              		@ args = 0, pretend = 0, frame = 0
  28              		@ frame_needed = 0, uses_anonymous_args = 0
  29 0000 30B5     		push	{r4, r5, lr}
  30              		.cfi_def_cfa_offset 12
  31              		.cfi_offset 4, -12
  32              		.cfi_offset 5, -8
  33              		.cfi_offset 14, -4
  34              	.LVL0:
 397:le_phy.c      **** 	int i;
 398:le_phy.c      **** 
 399:le_phy.c      **** 	// DMA linked list items
 400:le_phy.c      **** 	typedef struct {
 401:le_phy.c      **** 		uint32_t src;
 402:le_phy.c      **** 		uint32_t dest;
 403:le_phy.c      **** 		uint32_t next_lli;
 404:le_phy.c      **** 		uint32_t control;
 405:le_phy.c      **** 	} dma_lli;
 406:le_phy.c      **** 	static dma_lli le_dma_lli[2];
 407:le_phy.c      **** 
 408:le_phy.c      **** 	for (i = 0; i < 2; ++i) {
 409:le_phy.c      **** 		le_dma_lli[i].src = (uint32_t)&(DIO_SSP_DR);
  35              		.loc 1 409 0
  36 0002 0C4B     		ldr	r3, .L2
 410:le_phy.c      **** 		le_dma_lli[i].dest = (uint32_t)&le_dma_dest[i];
  37              		.loc 1 410 0
  38 0004 0C49     		ldr	r1, .L2+4
 411:le_phy.c      **** 		le_dma_lli[i].next_lli = (uint32_t)&le_dma_lli[1-i]; // two elements pointing back at each other
 412:le_phy.c      **** 		le_dma_lli[i].control = 1 |
  39              		.loc 1 412 0
  40 0006 0D4A     		ldr	r2, .L2+8
 409:le_phy.c      **** 		le_dma_lli[i].dest = (uint32_t)&le_dma_dest[i];
  41              		.loc 1 409 0
  42 0008 0D48     		ldr	r0, .L2+12
 411:le_phy.c      **** 		le_dma_lli[i].next_lli = (uint32_t)&le_dma_lli[1-i]; // two elements pointing back at each other
  43              		.loc 1 411 0
ARM GAS  /tmp/ccnRyoKo.s 			page 9


  44 000a 03F11004 		add	r4, r3, #16
 410:le_phy.c      **** 		le_dma_lli[i].dest = (uint32_t)&le_dma_dest[i];
  45              		.loc 1 410 0
  46 000e 4D1C     		adds	r5, r1, #1
  47              		.loc 1 412 0
  48 0010 DA60     		str	r2, [r3, #12]
  49              	.LVL1:
 409:le_phy.c      **** 		le_dma_lli[i].dest = (uint32_t)&le_dma_dest[i];
  50              		.loc 1 409 0
  51 0012 1860     		str	r0, [r3]
 410:le_phy.c      **** 		le_dma_lli[i].dest = (uint32_t)&le_dma_dest[i];
  52              		.loc 1 410 0
  53 0014 5960     		str	r1, [r3, #4]
 411:le_phy.c      **** 		le_dma_lli[i].next_lli = (uint32_t)&le_dma_lli[1-i]; // two elements pointing back at each other
  54              		.loc 1 411 0
  55 0016 9C60     		str	r4, [r3, #8]
 409:le_phy.c      **** 		le_dma_lli[i].dest = (uint32_t)&le_dma_dest[i];
  56              		.loc 1 409 0
  57 0018 1861     		str	r0, [r3, #16]
  58              		.loc 1 412 0
  59 001a DA61     		str	r2, [r3, #28]
  60              	.LVL2:
 410:le_phy.c      **** 		le_dma_lli[i].dest = (uint32_t)&le_dma_dest[i];
  61              		.loc 1 410 0
  62 001c 5D61     		str	r5, [r3, #20]
 411:le_phy.c      **** 		le_dma_lli[i].next_lli = (uint32_t)&le_dma_lli[1-i]; // two elements pointing back at each other
  63              		.loc 1 411 0
  64 001e 9B61     		str	r3, [r3, #24]
 413:le_phy.c      **** 				(0 << 12) |        // source burst size = 1
 414:le_phy.c      **** 				(0 << 15) |        // destination burst size = 1
 415:le_phy.c      **** 				(0 << 18) |        // source width 8 bits
 416:le_phy.c      **** 				(0 << 21) |        // destination width 8 bits
 417:le_phy.c      **** 				DMACCxControl_I;   // terminal count interrupt enable
 418:le_phy.c      **** 	}
 419:le_phy.c      **** 
 420:le_phy.c      **** 	// configure DMA channel 0
 421:le_phy.c      **** 	DMACC0SrcAddr = le_dma_lli[0].src;
  65              		.loc 1 421 0
  66 0020 084B     		ldr	r3, .L2+16
  67 0022 1860     		str	r0, [r3]
 422:le_phy.c      **** 	DMACC0DestAddr = le_dma_lli[0].dest;
  68              		.loc 1 422 0
  69 0024 5960     		str	r1, [r3, #4]
 423:le_phy.c      **** 	DMACC0LLI = le_dma_lli[0].next_lli;
  70              		.loc 1 423 0
  71 0026 9C60     		str	r4, [r3, #8]
 424:le_phy.c      **** 	DMACC0Control = le_dma_lli[0].control;
  72              		.loc 1 424 0
  73 0028 DA60     		str	r2, [r3, #12]
 425:le_phy.c      **** 	DMACC0Config =
  74              		.loc 1 425 0
  75 002a 4DF20602 		movw	r2, #53254
  76 002e 1A61     		str	r2, [r3, #16]
  77 0030 30BD     		pop	{r4, r5, pc}
  78              	.L3:
  79 0032 00BF     		.align	2
  80              	.L2:
ARM GAS  /tmp/ccnRyoKo.s 			page 10


  81 0034 00000000 		.word	.LANCHOR0
  82 0038 00000000 		.word	le_dma_dest
  83 003c 01000080 		.word	-2147483647
  84 0040 08000340 		.word	1073938440
  85 0044 00410050 		.word	1342193920
  86              		.cfi_endproc
  87              	.LFE8:
  89              		.section	.text.timer1_set_match,"ax",%progbits
  90              		.align	1
  91              		.syntax unified
  92              		.thumb
  93              		.thumb_func
  94              		.fpu softvfp
  96              	timer1_set_match:
  97              	.LFB15:
 426:le_phy.c      **** 			DIO_SSP_SRC |
 427:le_phy.c      **** 			(0x2 << 11) |     // peripheral to memory
 428:le_phy.c      **** 			DMACCxConfig_IE | // allow error interrupts
 429:le_phy.c      **** 			DMACCxConfig_ITC; // allow terminal count interrupts
 430:le_phy.c      **** }
 431:le_phy.c      **** 
 432:le_phy.c      **** // initalize USB, SSP, and DMA
 433:le_phy.c      **** static void le_sys_init(void) {
 434:le_phy.c      **** 	usb_queue_init(); // USB FIFO FIXME replace with safer queue
 435:le_phy.c      **** 	dio_ssp_init();   // init SSP and raise !CS (self-routed GPIO)
 436:le_phy.c      **** 	le_dma_init();    // prepare DMA + interrupts
 437:le_phy.c      **** 	dio_ssp_start();  // enable SSP + DMA
 438:le_phy.c      **** }
 439:le_phy.c      **** 
 440:le_phy.c      **** // initialize RF and strobe FSON
 441:le_phy.c      **** static void le_cc2400_init_rf(void) {
 442:le_phy.c      **** 	u16 grmdm, mdmctrl;
 443:le_phy.c      **** 	uint32_t sync = rbit(conn.access_address);
 444:le_phy.c      **** 
 445:le_phy.c      **** 	mdmctrl = 0x0040; // 250 kHz frequency deviation
 446:le_phy.c      **** 	grmdm = 0x44E1; // un-buffered mode, packet w/ sync word detection
 447:le_phy.c      **** 	// 0 10 00 1 001 11 0 00 0 1
 448:le_phy.c      **** 	//   |  |  | |   |  +--------> CRC off
 449:le_phy.c      **** 	//   |  |  | |   +-----------> sync word: 32 MSB bits of SYNC_WORD
 450:le_phy.c      **** 	//   |  |  | +---------------> 1 preamble byte of 01010101
 451:le_phy.c      **** 	//   |  |  +-----------------> packet mode
 452:le_phy.c      **** 	//   |  +--------------------> un-buffered mode
 453:le_phy.c      **** 	//   +-----------------------> sync error bits: 2
 454:le_phy.c      **** 
 455:le_phy.c      **** 	cc2400_set(MANAND,  0x7ffe);
 456:le_phy.c      **** 	cc2400_set(LMTST,   0x2b22);
 457:le_phy.c      **** 
 458:le_phy.c      **** 	cc2400_set(MDMTST0, 0x124b);
 459:le_phy.c      **** 	// 1      2      4b
 460:le_phy.c      **** 	// 00 0 1 0 0 10 01001011
 461:le_phy.c      **** 	//    | | | | |  +---------> AFC_DELTA = ??
 462:le_phy.c      **** 	//    | | | | +------------> AFC settling = 4 pairs (8 bit preamble)
 463:le_phy.c      **** 	//    | | | +--------------> no AFC adjust on packet
 464:le_phy.c      **** 	//    | | +----------------> do not invert data
 465:le_phy.c      **** 	//    | +------------------> TX IF freq 1 0Hz
 466:le_phy.c      **** 	//    +--------------------> PRNG off
 467:le_phy.c      **** 	//
ARM GAS  /tmp/ccnRyoKo.s 			page 11


 468:le_phy.c      **** 	// ref: CC2400 datasheet page 67
 469:le_phy.c      **** 	// AFC settling explained page 41/42
 470:le_phy.c      **** 
 471:le_phy.c      **** 	cc2400_set(GRMDM,   grmdm);
 472:le_phy.c      **** 
 473:le_phy.c      **** 	cc2400_set(SYNCL,   sync & 0xffff);
 474:le_phy.c      **** 	cc2400_set(SYNCH,   (sync >> 16) & 0xffff);
 475:le_phy.c      **** 
 476:le_phy.c      **** 	cc2400_set(FSDIV,   rf_channel - 1); // 1 MHz IF
 477:le_phy.c      **** 	cc2400_set(MDMCTRL, mdmctrl);
 478:le_phy.c      **** 
 479:le_phy.c      **** 	// XOSC16M should always be stable, but leave this test anyway
 480:le_phy.c      **** 	while (!(cc2400_status() & XOSC16M_STABLE));
 481:le_phy.c      **** 
 482:le_phy.c      **** 	// wait for FS_LOCK in background
 483:le_phy.c      **** 	cc2400_strobe(SFSON);
 484:le_phy.c      **** 	timer1_wait_fs_lock();
 485:le_phy.c      **** }
 486:le_phy.c      **** 
 487:le_phy.c      **** // strobe RX and enable PA
 488:le_phy.c      **** static void le_cc2400_strobe_rx(void) {
 489:le_phy.c      **** 	cc2400_strobe(SRX);
 490:le_phy.c      **** #ifdef UBERTOOTH_ONE
 491:le_phy.c      **** 	PAEN_SET;
 492:le_phy.c      **** 	HGM_SET;
 493:le_phy.c      **** #endif
 494:le_phy.c      **** }
 495:le_phy.c      **** 
 496:le_phy.c      **** // change channel and init rx
 497:le_phy.c      **** static void change_channel(void) {
 498:le_phy.c      **** 	uint8_t channel_idx = 0;
 499:le_phy.c      **** 
 500:le_phy.c      **** 	cc2400_strobe(SRFOFF);
 501:le_phy.c      **** 
 502:le_phy.c      **** 	// stop DMA and flush SSP
 503:le_phy.c      **** 	DIO_SSP_DMACR &= ~SSPDMACR_RXDMAE;
 504:le_phy.c      **** 	while (SSP1SR & SSPSR_RNE) {
 505:le_phy.c      **** 		uint8_t tmp = (uint8_t)DIO_SSP_DR;
 506:le_phy.c      **** 	}
 507:le_phy.c      **** 
 508:le_phy.c      **** 	buffer_clear(current_rxbuf);
 509:le_phy.c      **** 	le_dma_init();
 510:le_phy.c      **** 	dio_ssp_start();
 511:le_phy.c      **** 
 512:le_phy.c      **** 	if (conn.access_address == ADVERTISING_AA) {
 513:le_phy.c      **** 		// FIXME
 514:le_phy.c      **** 		switch (le_adv_channel) {
 515:le_phy.c      **** 			case 2402: channel_idx = 37; break;
 516:le_phy.c      **** 			case 2426: channel_idx = 38; break;
 517:le_phy.c      **** 			case 2480: channel_idx = 39; break;
 518:le_phy.c      **** 			default:   channel_idx = 37; break;
 519:le_phy.c      **** 		}
 520:le_phy.c      **** 	} else {
 521:le_phy.c      **** 		conn.channel_idx = (conn.channel_idx + conn.hop_increment) % 37;
 522:le_phy.c      **** 		channel_idx = le_map_channel(conn.channel_idx, &conn.remapping);
 523:le_phy.c      **** 	}
 524:le_phy.c      **** 
ARM GAS  /tmp/ccnRyoKo.s 			page 12


 525:le_phy.c      **** 	rf_channel = btle_channel_index_to_phys(channel_idx);
 526:le_phy.c      **** 	le_cc2400_init_rf();
 527:le_phy.c      **** }
 528:le_phy.c      **** 
 529:le_phy.c      **** ///////
 530:le_phy.c      **** // timer stuff
 531:le_phy.c      **** 
 532:le_phy.c      **** static void timer1_start(void) {
 533:le_phy.c      **** 	T1TCR = TCR_Counter_Reset;
 534:le_phy.c      **** 	T1PR = 4; // 100 ns
 535:le_phy.c      **** 	T1TCR = TCR_Counter_Enable;
 536:le_phy.c      **** 
 537:le_phy.c      **** 	// set up interrupt handler
 538:le_phy.c      **** 	ISER0 = ISER0_ISE_TIMER1;
 539:le_phy.c      **** }
 540:le_phy.c      **** 
 541:le_phy.c      **** static void timer1_stop(void) {
 542:le_phy.c      **** 	T1TCR = TCR_Counter_Reset;
 543:le_phy.c      **** 
 544:le_phy.c      **** 	// clear interrupt handler
 545:le_phy.c      **** 	ICER0 = ICER0_ICE_TIMER1;
 546:le_phy.c      **** }
 547:le_phy.c      **** 
 548:le_phy.c      **** static void timer1_set_match(uint32_t match) {
  98              		.loc 1 548 0
  99              		.cfi_startproc
 100              		@ args = 0, pretend = 0, frame = 0
 101              		@ frame_needed = 0, uses_anonymous_args = 0
 102              		@ link register save eliminated.
 103              	.LVL3:
 549:le_phy.c      **** 	T1MR0 = match;
 104              		.loc 1 549 0
 105 0000 034B     		ldr	r3, .L5
 550:le_phy.c      **** 	T1MCR |= TMCR_MR0I;
 106              		.loc 1 550 0
 107 0002 044A     		ldr	r2, .L5+4
 549:le_phy.c      **** 	T1MR0 = match;
 108              		.loc 1 549 0
 109 0004 1860     		str	r0, [r3]
 110              		.loc 1 550 0
 111 0006 1368     		ldr	r3, [r2]
 112 0008 43F00103 		orr	r3, r3, #1
 113 000c 1360     		str	r3, [r2]
 114 000e 7047     		bx	lr
 115              	.L6:
 116              		.align	2
 117              	.L5:
 118 0010 18800040 		.word	1073774616
 119 0014 14800040 		.word	1073774612
 120              		.cfi_endproc
 121              	.LFE15:
 123              		.section	.text.timer1_wait_fs_lock,"ax",%progbits
 124              		.align	1
 125              		.syntax unified
 126              		.thumb
 127              		.thumb_func
 128              		.fpu softvfp
ARM GAS  /tmp/ccnRyoKo.s 			page 13


 130              	timer1_wait_fs_lock:
 131              	.LFB17:
 551:le_phy.c      **** }
 552:le_phy.c      **** 
 553:le_phy.c      **** static void timer1_clear_match(void) {
 554:le_phy.c      **** 	T1MCR &= ~TMCR_MR0I;
 555:le_phy.c      **** }
 556:le_phy.c      **** 
 557:le_phy.c      **** static void timer1_wait_fs_lock(void) {
 132              		.loc 1 557 0
 133              		.cfi_startproc
 134              		@ args = 0, pretend = 0, frame = 0
 135              		@ frame_needed = 0, uses_anonymous_args = 0
 136              		@ link register save eliminated.
 558:le_phy.c      **** 	T1MR2 = NOW + USEC(3);
 137              		.loc 1 558 0
 138 0000 054B     		ldr	r3, .L8
 139 0002 064A     		ldr	r2, .L8+4
 140 0004 1B68     		ldr	r3, [r3]
 141 0006 1E33     		adds	r3, r3, #30
 142 0008 1360     		str	r3, [r2]
 559:le_phy.c      **** 	T1MCR |= TMCR_MR2I;
 143              		.loc 1 559 0
 144 000a 52F80C3C 		ldr	r3, [r2, #-12]
 145 000e 43F04003 		orr	r3, r3, #64
 146 0012 42F80C3C 		str	r3, [r2, #-12]
 147 0016 7047     		bx	lr
 148              	.L9:
 149              		.align	2
 150              	.L8:
 151 0018 08800040 		.word	1073774600
 152 001c 20800040 		.word	1073774624
 153              		.cfi_endproc
 154              	.LFE17:
 156              		.section	.text.extract_field,"ax",%progbits
 157              		.align	1
 158              		.syntax unified
 159              		.thumb
 160              		.thumb_func
 161              		.fpu softvfp
 163              	extract_field:
 164              	.LFB23:
 560:le_phy.c      **** }
 561:le_phy.c      **** 
 562:le_phy.c      **** static void timer1_cancel_fs_lock(void) {
 563:le_phy.c      **** 	T1MCR &= ~TMCR_MR2I;
 564:le_phy.c      **** }
 565:le_phy.c      **** 
 566:le_phy.c      **** void TIMER1_IRQHandler(void) {
 567:le_phy.c      **** 	// MR0: connection events
 568:le_phy.c      **** 	if (T1IR & TIR_MR0_Interrupt) {
 569:le_phy.c      **** 		// ack the interrupt
 570:le_phy.c      **** 		T1IR = TIR_MR0_Interrupt;
 571:le_phy.c      **** 
 572:le_phy.c      **** 		// connection update procedure
 573:le_phy.c      **** 		if (conn.conn_update_pending &&
 574:le_phy.c      **** 				conn.conn_event_counter == conn.conn_update_instant) {
ARM GAS  /tmp/ccnRyoKo.s 			page 14


 575:le_phy.c      **** 
 576:le_phy.c      **** 			// on the first past through, handle the transmit window
 577:le_phy.c      **** 			// offset. if there's no offset, skip down to else block
 578:le_phy.c      **** 			if (!conn_event.opened && conn.win_offset > 0) {
 579:le_phy.c      **** 				timer1_set_match(conn.last_anchor + conn.conn_interval +
 580:le_phy.c      **** 						conn.win_offset - RX_WARMUP_TIME);
 581:le_phy.c      **** 				conn_event.opened = 1;
 582:le_phy.c      **** 			}
 583:le_phy.c      **** 
 584:le_phy.c      **** 			// after the transmit window offset, or if there is no
 585:le_phy.c      **** 			// transmit window, set a packet timeout and change the
 586:le_phy.c      **** 			// channel
 587:le_phy.c      **** 			else { // conn_event.opened || conn.win_offset == 0
 588:le_phy.c      **** 				conn_event.opened = 1;
 589:le_phy.c      **** 
 590:le_phy.c      **** 				// this is like a new connection, so set all values
 591:le_phy.c      **** 				// accordingly
 592:le_phy.c      **** 				conn.anchor_set = 0;
 593:le_phy.c      **** 				conn.conn_interval = conn.conn_update_pending_interval;
 594:le_phy.c      **** 				conn.supervision_timeout = conn.conn_update_pending_supervision_timeout;
 595:le_phy.c      **** 				conn.conn_update_pending = 0;
 596:le_phy.c      **** 
 597:le_phy.c      **** 				// timeout after conn window + max packet length
 598:le_phy.c      **** 				timer1_set_match(conn.last_anchor + conn.conn_interval +
 599:le_phy.c      **** 						conn.win_offset + conn.win_size + USEC(2120));
 600:le_phy.c      **** 				change_channel();
 601:le_phy.c      **** 			}
 602:le_phy.c      **** 			return;
 603:le_phy.c      **** 		}
 604:le_phy.c      **** 
 605:le_phy.c      **** 		// channel map update
 606:le_phy.c      **** 		if (conn.channel_map_update_pending &&
 607:le_phy.c      **** 				conn.conn_event_counter == conn.channel_map_update_instant) {
 608:le_phy.c      **** 			conn.remapping = conn.pending_remapping;
 609:le_phy.c      **** 			conn.channel_map_update_pending = 0;
 610:le_phy.c      **** 		}
 611:le_phy.c      **** 
 612:le_phy.c      **** 		// new connection event: set timeout and change channel
 613:le_phy.c      **** 		if (!conn_event.opened) {
 614:le_phy.c      **** 			conn_event.opened = 1;
 615:le_phy.c      **** 			// timeout is max packet length + warmup time (slack)
 616:le_phy.c      **** 			timer1_set_match(NOW + USEC(2120) + RX_WARMUP_TIME);
 617:le_phy.c      **** 			change_channel();
 618:le_phy.c      **** 		}
 619:le_phy.c      **** 
 620:le_phy.c      **** 		// regular connection event, plus timeout from connection updates
 621:le_phy.c      **** 		// FIXME connection update timeouts and initial connection
 622:le_phy.c      **** 		// timeouts need to be handled differently: they should have a
 623:le_phy.c      **** 		// full window until the packets from the new connection are
 624:le_phy.c      **** 		// captured and a new anchor is set.
 625:le_phy.c      **** 		else {
 626:le_phy.c      **** 			// new connection event: set timeout and change channel
 627:le_phy.c      **** 			if (!conn_event.opened) {
 628:le_phy.c      **** 				conn_event.opened = 1;
 629:le_phy.c      **** 
 630:le_phy.c      **** 				// timeout is max packet length + warmup time (slack)
 631:le_phy.c      **** 				timer1_set_match(NOW + USEC(2120) + RX_WARMUP_TIME);
ARM GAS  /tmp/ccnRyoKo.s 			page 15


 632:le_phy.c      **** 				change_channel();
 633:le_phy.c      **** 			}
 634:le_phy.c      **** 
 635:le_phy.c      **** 			// timeout: close connection event and set timer for next hop
 636:le_phy.c      **** 			else {
 637:le_phy.c      **** 				finish_conn_event();
 638:le_phy.c      **** 			}
 639:le_phy.c      **** 		}
 640:le_phy.c      **** 	}
 641:le_phy.c      **** 
 642:le_phy.c      **** 	// LEDs
 643:le_phy.c      **** 	if (T1IR & TIR_MR1_Interrupt) {
 644:le_phy.c      **** 		T1IR = TIR_MR1_Interrupt;
 645:le_phy.c      **** 		T1MCR &= ~TMCR_MR1I;
 646:le_phy.c      **** 
 647:le_phy.c      **** 		TXLED_CLR;
 648:le_phy.c      **** 		RXLED_CLR;
 649:le_phy.c      **** 		USRLED_CLR;
 650:le_phy.c      **** 	}
 651:le_phy.c      **** 
 652:le_phy.c      **** 	// check FS_LOCK
 653:le_phy.c      **** 	if (T1IR & TIR_MR2_Interrupt) {
 654:le_phy.c      **** 		T1IR = TIR_MR2_Interrupt;
 655:le_phy.c      **** 
 656:le_phy.c      **** 		// if FS is locked, strobe RX and clear interrupt
 657:le_phy.c      **** 		if (cc2400_status() & FS_LOCK) {
 658:le_phy.c      **** 			le_cc2400_strobe_rx();
 659:le_phy.c      **** 			T1MCR &= ~TMCR_MR2I;
 660:le_phy.c      **** 		}
 661:le_phy.c      **** 
 662:le_phy.c      **** 		// if FS is not locked, check again in 3 us
 663:le_phy.c      **** 		else {
 664:le_phy.c      **** 			timer1_wait_fs_lock();
 665:le_phy.c      **** 		}
 666:le_phy.c      **** 	}
 667:le_phy.c      **** }
 668:le_phy.c      **** 
 669:le_phy.c      **** static void blink(int tx, int rx, int usr) {
 670:le_phy.c      **** 	if (tx)
 671:le_phy.c      **** 		TXLED_SET;
 672:le_phy.c      **** 	if (rx)
 673:le_phy.c      **** 		RXLED_SET;
 674:le_phy.c      **** 	if (usr)
 675:le_phy.c      **** 		USRLED_SET;
 676:le_phy.c      **** 
 677:le_phy.c      **** 	// blink for 10 ms
 678:le_phy.c      **** 	T1MR1 = NOW + MSEC(10);
 679:le_phy.c      **** 	T1MCR |= TMCR_MR1I;
 680:le_phy.c      **** }
 681:le_phy.c      **** 
 682:le_phy.c      **** // helper function to dewhiten length from whitened data (only used
 683:le_phy.c      **** // during DMA)
 684:le_phy.c      **** static uint8_t dewhiten_length(unsigned channel, uint8_t data) {
 685:le_phy.c      **** 	unsigned int i, bit;
 686:le_phy.c      **** 	int idx = whitening_index[btle_channel_index(channel)];
 687:le_phy.c      **** 	uint8_t out = 0;
 688:le_phy.c      **** 
ARM GAS  /tmp/ccnRyoKo.s 			page 16


 689:le_phy.c      **** 	// length is second byte of packet
 690:le_phy.c      **** 	idx = (idx + 8) % sizeof(whitening);
 691:le_phy.c      **** 
 692:le_phy.c      **** 	for (i = 0; i < 8; ++i) {
 693:le_phy.c      **** 		bit = (data >> (7-i)) & 1;
 694:le_phy.c      **** 		bit ^= whitening[idx];
 695:le_phy.c      **** 		idx = (idx + 1) % sizeof(whitening);
 696:le_phy.c      **** 		out |= bit << i;
 697:le_phy.c      **** 	}
 698:le_phy.c      **** 
 699:le_phy.c      **** 	return out;
 700:le_phy.c      **** }
 701:le_phy.c      **** 
 702:le_phy.c      **** // enqueue a packet for USB
 703:le_phy.c      **** // FIXME this is cribbed from existing code, but does not have enough
 704:le_phy.c      **** // room for larger LE packets
 705:le_phy.c      **** static int usb_enqueue_le(le_rx_t *packet) {
 706:le_phy.c      **** 	usb_pkt_rx* f = usb_enqueue();
 707:le_phy.c      **** 
 708:le_phy.c      **** 	// fail if queue is full
 709:le_phy.c      **** 	if (f == NULL) {
 710:le_phy.c      **** 		return 0;
 711:le_phy.c      **** 	}
 712:le_phy.c      **** 
 713:le_phy.c      **** 	f->pkt_type = LE_PACKET;
 714:le_phy.c      **** 
 715:le_phy.c      **** 	f->clkn_high = 0;
 716:le_phy.c      **** 	f->clk100ns = packet->timestamp;
 717:le_phy.c      **** 
 718:le_phy.c      **** 	f->channel = (uint8_t)((packet->channel - 2402) & 0xff);
 719:le_phy.c      **** 	f->rssi_avg = packet->rssi_sum / packet->size;
 720:le_phy.c      **** 	f->rssi_min = packet->rssi_min;
 721:le_phy.c      **** 	f->rssi_max = packet->rssi_max;
 722:le_phy.c      **** 	f->rssi_count = 0;
 723:le_phy.c      **** 
 724:le_phy.c      **** 	memcpy(f->data, &packet->access_address, 4);
 725:le_phy.c      **** 	memcpy(f->data+4, packet->data, DMA_SIZE-4);
 726:le_phy.c      **** 
 727:le_phy.c      **** 	f->status = 0;
 728:le_phy.c      **** 
 729:le_phy.c      **** 	return 1;
 730:le_phy.c      **** }
 731:le_phy.c      **** 
 732:le_phy.c      **** static unsigned extract_field(le_rx_t *buf, size_t offset, unsigned size) {
 165              		.loc 1 732 0
 166              		.cfi_startproc
 167              		@ args = 0, pretend = 0, frame = 0
 168              		@ frame_needed = 0, uses_anonymous_args = 0
 169              	.LVL4:
 170 0000 30B5     		push	{r4, r5, lr}
 171              		.cfi_def_cfa_offset 12
 172              		.cfi_offset 4, -12
 173              		.cfi_offset 5, -8
 174              		.cfi_offset 14, -4
 175              	.LVL5:
 733:le_phy.c      **** 	unsigned i, ret = 0;
 176              		.loc 1 733 0
ARM GAS  /tmp/ccnRyoKo.s 			page 17


 177 0002 0024     		movs	r4, #0
 734:le_phy.c      **** 
 735:le_phy.c      **** 	// this could just be replaced by memcpy... right?
 736:le_phy.c      **** 	for (i = 0; i < size; ++i)
 178              		.loc 1 736 0
 179 0004 2346     		mov	r3, r4
 737:le_phy.c      **** 		ret |= buf->data[offset + i] << (i*8);
 180              		.loc 1 737 0
 181 0006 0144     		add	r1, r1, r0
 182              	.LVL6:
 183              	.L11:
 736:le_phy.c      **** 		ret |= buf->data[offset + i] << (i*8);
 184              		.loc 1 736 0 discriminator 1
 185 0008 9342     		cmp	r3, r2
 186 000a 01D1     		bne	.L12
 738:le_phy.c      **** 
 739:le_phy.c      **** 	return ret;
 740:le_phy.c      **** }
 187              		.loc 1 740 0
 188 000c 2046     		mov	r0, r4
 189 000e 30BD     		pop	{r4, r5, pc}
 190              	.LVL7:
 191              	.L12:
 737:le_phy.c      **** 
 192              		.loc 1 737 0 discriminator 3
 193 0010 CD5C     		ldrb	r5, [r1, r3]	@ zero_extendqisi2
 194 0012 D800     		lsls	r0, r3, #3
 195 0014 8540     		lsls	r5, r5, r0
 196 0016 2C43     		orrs	r4, r4, r5
 197              	.LVL8:
 736:le_phy.c      **** 		ret |= buf->data[offset + i] << (i*8);
 198              		.loc 1 736 0 discriminator 3
 199 0018 0133     		adds	r3, r3, #1
 200              	.LVL9:
 201 001a F5E7     		b	.L11
 202              		.cfi_endproc
 203              	.LFE23:
 205              		.section	.text.bd_addr_cmp,"ax",%progbits
 206              		.align	1
 207              		.syntax unified
 208              		.thumb
 209              		.thumb_func
 210              		.fpu softvfp
 212              	bd_addr_cmp:
 213              	.LFB28:
 741:le_phy.c      **** 
 742:le_phy.c      **** static void le_connect_handler(le_rx_t *buf) {
 743:le_phy.c      **** 	uint32_t aa, crc_init;
 744:le_phy.c      **** 	uint32_t win_size, max_win_size;
 745:le_phy.c      **** 
 746:le_phy.c      **** 	if (!le.do_follow)
 747:le_phy.c      **** 		return;
 748:le_phy.c      **** 
 749:le_phy.c      **** 	if (buf->size != 2 + 6 + 6 + 22 + 3)
 750:le_phy.c      **** 		return;
 751:le_phy.c      **** 
 752:le_phy.c      **** 	// FIXME ugly hack
ARM GAS  /tmp/ccnRyoKo.s 			page 18


 753:le_phy.c      **** 	if (cancel_follow)
 754:le_phy.c      **** 		cancel_follow = 0;
 755:le_phy.c      **** 
 756:le_phy.c      **** 	conn.access_address     = extract_field(buf, 14, 4);
 757:le_phy.c      **** 	conn.crc_init           = extract_field(buf, 18, 3);
 758:le_phy.c      **** 	conn.crc_init_reversed  = rbit(conn.crc_init);
 759:le_phy.c      **** 	conn.win_size           = extract_field(buf, 21, 1);
 760:le_phy.c      **** 	conn.win_offset         = extract_field(buf, 22, 2);
 761:le_phy.c      **** 	conn.conn_interval      = extract_field(buf, 24, 2);
 762:le_phy.c      **** 	conn.supervision_timeout = extract_field(buf, 28, 2);
 763:le_phy.c      **** 	conn.hop_increment      = extract_field(buf, 35, 1) & 0x1f;
 764:le_phy.c      **** 
 765:le_phy.c      **** 	if (conn.conn_interval < 6 || conn.conn_interval > 3200) {
 766:le_phy.c      **** 		goto err_out;
 767:le_phy.c      **** 	} else {
 768:le_phy.c      **** 		conn.conn_interval *= USEC(1250);
 769:le_phy.c      **** 	}
 770:le_phy.c      **** 
 771:le_phy.c      **** 	// window offset is in range [0, conn_interval]
 772:le_phy.c      **** 	conn.win_offset *= USEC(1250);
 773:le_phy.c      **** 	if (conn.win_offset > conn.conn_interval)
 774:le_phy.c      **** 		goto err_out;
 775:le_phy.c      **** 
 776:le_phy.c      **** 	// win size is in range [1.25 ms, MIN(10 ms, conn_interval - 1.25 ms)]
 777:le_phy.c      **** 	win_size = conn.win_size * USEC(1250);
 778:le_phy.c      **** 	max_win_size = conn.conn_interval - USEC(1250);
 779:le_phy.c      **** 	if (max_win_size > MSEC(10))
 780:le_phy.c      **** 		max_win_size = MSEC(10);
 781:le_phy.c      **** 	if (win_size < USEC(1250) || win_size > max_win_size)
 782:le_phy.c      **** 		goto err_out;
 783:le_phy.c      **** 
 784:le_phy.c      **** 	// The connSupervisionTimeout shall be a multiple of 10 ms in the
 785:le_phy.c      **** 	// range of 100 ms to 32.0 s and it shall be larger than (1 +
 786:le_phy.c      **** 	// connSlaveLatency) * connInterval * 2
 787:le_phy.c      **** 	conn.supervision_timeout *= MSEC(10);
 788:le_phy.c      **** 	if (conn.supervision_timeout < MSEC(100) || conn.supervision_timeout > SEC(32))
 789:le_phy.c      **** 		goto err_out;
 790:le_phy.c      **** 	// TODO handle slave latency
 791:le_phy.c      **** 
 792:le_phy.c      **** 	le_parse_channel_map(&buf->data[30], &conn.remapping);
 793:le_phy.c      **** 	if (conn.remapping.total_channels == 0)
 794:le_phy.c      **** 		goto err_out;
 795:le_phy.c      **** 
 796:le_phy.c      **** 	// cancel RX on advertising channel
 797:le_phy.c      **** 	timer1_cancel_fs_lock();
 798:le_phy.c      **** 
 799:le_phy.c      **** 	reset_conn_event();
 800:le_phy.c      **** 	timer1_set_match(buf->timestamp + PACKET_DURATION(buf) +
 801:le_phy.c      **** 			conn.win_offset + USEC(1250) - RX_WARMUP_TIME);
 802:le_phy.c      **** 	return;
 803:le_phy.c      **** 
 804:le_phy.c      **** 	// error condition: reset conn and return
 805:le_phy.c      **** err_out:
 806:le_phy.c      **** 	reset_conn();
 807:le_phy.c      **** }
 808:le_phy.c      **** 
 809:le_phy.c      **** static void connection_update_handler(le_rx_t *buf) {
ARM GAS  /tmp/ccnRyoKo.s 			page 19


 810:le_phy.c      **** 	conn.win_size            = extract_field(buf, 3, 1);
 811:le_phy.c      **** 	conn.win_offset          = extract_field(buf, 4, 2);
 812:le_phy.c      **** 	conn.conn_update_pending_interval = extract_field(buf, 6, 2);
 813:le_phy.c      **** 	conn.conn_update_pending_supervision_timeout = extract_field(buf, 10, 2);
 814:le_phy.c      **** 	conn.conn_update_instant = extract_field(buf, 12, 2);
 815:le_phy.c      **** 
 816:le_phy.c      **** 	// TODO check for invalid values. XXX what do we even do in that
 817:le_phy.c      **** 	// case? we will probably drop the connection, but at least it's on
 818:le_phy.c      **** 	// our own terms and not some impossibly long supervision timeout.
 819:le_phy.c      **** 	conn.win_size   *= USEC(1250);
 820:le_phy.c      **** 	conn.win_offset *= USEC(1250);
 821:le_phy.c      **** 	conn.conn_update_pending_interval *= USEC(1250);
 822:le_phy.c      **** 	conn.conn_update_pending_supervision_timeout *= MSEC(10);
 823:le_phy.c      **** 
 824:le_phy.c      **** 	conn.conn_update_pending = 1;
 825:le_phy.c      **** }
 826:le_phy.c      **** 
 827:le_phy.c      **** static void channel_map_update_handler(le_rx_t *buf) {
 828:le_phy.c      **** 	conn.channel_map_update_pending = 1;
 829:le_phy.c      **** 	conn.channel_map_update_instant = extract_field(buf, 8, 2);
 830:le_phy.c      **** 	le_parse_channel_map(&buf->data[3], &conn.pending_remapping);
 831:le_phy.c      **** }
 832:le_phy.c      **** 
 833:le_phy.c      **** static void packet_handler(le_rx_t *buf) {
 834:le_phy.c      **** 	// advertising packet
 835:le_phy.c      **** 	if (btle_channel_index(buf->channel) >= 37) {
 836:le_phy.c      **** 		switch (buf->data[0] & 0xf) {
 837:le_phy.c      **** 			// CONNECT_REQ
 838:le_phy.c      **** 			case 0x05:
 839:le_phy.c      **** 				// TODO validate length
 840:le_phy.c      **** 				le_connect_handler(buf);
 841:le_phy.c      **** 				break;
 842:le_phy.c      **** 		}
 843:le_phy.c      **** 	}
 844:le_phy.c      **** 
 845:le_phy.c      **** 	// data packet
 846:le_phy.c      **** 	else {
 847:le_phy.c      **** 		// LL control PDU
 848:le_phy.c      **** 		if ((buf->data[0] & 0b11) == 0b11 && buf->data[1] > 0) {
 849:le_phy.c      **** 			switch (buf->data[2]) {
 850:le_phy.c      **** 				// LE_CONNECTION_UPDATE_REQ -- update connection parameters
 851:le_phy.c      **** 				case 0x0:
 852:le_phy.c      **** 					if (buf->data[1] == 12)
 853:le_phy.c      **** 						connection_update_handler(buf);
 854:le_phy.c      **** 					break;
 855:le_phy.c      **** 
 856:le_phy.c      **** 				// LE_CHANNEL_MAP_REQ -- update channel map
 857:le_phy.c      **** 				case 0x1:
 858:le_phy.c      **** 					if (buf->data[1] == 8)
 859:le_phy.c      **** 						channel_map_update_handler(buf);
 860:le_phy.c      **** 					break;
 861:le_phy.c      **** 			}
 862:le_phy.c      **** 		}
 863:le_phy.c      **** 	}
 864:le_phy.c      **** }
 865:le_phy.c      **** 
 866:le_phy.c      **** // compare a BD addr against target with mask
ARM GAS  /tmp/ccnRyoKo.s 			page 20


 867:le_phy.c      **** static int bd_addr_cmp(uint8_t *bd_addr) {
 214              		.loc 1 867 0
 215              		.cfi_startproc
 216              		@ args = 0, pretend = 0, frame = 0
 217              		@ frame_needed = 0, uses_anonymous_args = 0
 218              	.LVL10:
 219 0000 10B5     		push	{r4, lr}
 220              		.cfi_def_cfa_offset 8
 221              		.cfi_offset 4, -8
 222              		.cfi_offset 14, -4
 223              	.LVL11:
 224 0002 084A     		ldr	r2, .L18
 225 0004 431E     		subs	r3, r0, #1
 226 0006 0530     		adds	r0, r0, #5
 227              	.LVL12:
 228              	.L15:
 868:le_phy.c      **** 	unsigned i;
 869:le_phy.c      **** 	for (i = 0; i < 6; ++i)
 870:le_phy.c      **** 		if ((bd_addr[i] & le.target_mask[i]) != le.target[i])
 229              		.loc 1 870 0
 230 0008 D479     		ldrb	r4, [r2, #7]	@ zero_extendqisi2
 231 000a 13F8011F 		ldrb	r1, [r3, #1]!	@ zero_extendqisi2
 232              	.LVL13:
 233 000e 2140     		ands	r1, r1, r4
 234 0010 12F8014F 		ldrb	r4, [r2, #1]!	@ zero_extendqisi2
 235 0014 8C42     		cmp	r4, r1
 236 0016 03D1     		bne	.L16
 237              	.LVL14:
 869:le_phy.c      **** 		if ((bd_addr[i] & le.target_mask[i]) != le.target[i])
 238              		.loc 1 869 0 discriminator 2
 239 0018 8342     		cmp	r3, r0
 240 001a F5D1     		bne	.L15
 871:le_phy.c      **** 			return 0;
 872:le_phy.c      **** 	return 1;
 241              		.loc 1 872 0
 242 001c 0120     		movs	r0, #1
 243              	.LVL15:
 244 001e 10BD     		pop	{r4, pc}
 245              	.LVL16:
 246              	.L16:
 871:le_phy.c      **** 			return 0;
 247              		.loc 1 871 0
 248 0020 0020     		movs	r0, #0
 873:le_phy.c      **** }
 249              		.loc 1 873 0
 250 0022 10BD     		pop	{r4, pc}
 251              	.L19:
 252              		.align	2
 253              	.L18:
 254 0024 37000000 		.word	le+55
 255              		.cfi_endproc
 256              	.LFE28:
 258              		.section	.text.reset_conn,"ax",%progbits
 259              		.align	1
 260              		.syntax unified
 261              		.thumb
 262              		.thumb_func
ARM GAS  /tmp/ccnRyoKo.s 			page 21


 263              		.fpu softvfp
 265              	reset_conn:
 266              	.LFB0:
 139:le_phy.c      **** 	memset(&conn, 0, sizeof(conn));
 267              		.loc 1 139 0
 268              		.cfi_startproc
 269              		@ args = 0, pretend = 0, frame = 0
 270              		@ frame_needed = 0, uses_anonymous_args = 0
 271 0000 10B5     		push	{r4, lr}
 272              		.cfi_def_cfa_offset 8
 273              		.cfi_offset 4, -8
 274              		.cfi_offset 14, -4
 140:le_phy.c      **** 	conn.access_address = ADVERTISING_AA;
 275              		.loc 1 140 0
 276 0002 054C     		ldr	r4, .L21
 277 0004 4FF4E472 		mov	r2, #456
 278 0008 0021     		movs	r1, #0
 279 000a 04F12000 		add	r0, r4, #32
 280 000e FFF7FEFF 		bl	memset
 281              	.LVL17:
 141:le_phy.c      **** }
 282              		.loc 1 141 0
 283 0012 024B     		ldr	r3, .L21+4
 284 0014 2362     		str	r3, [r4, #32]
 285 0016 10BD     		pop	{r4, pc}
 286              	.L22:
 287              		.align	2
 288              	.L21:
 289 0018 00000000 		.word	.LANCHOR0
 290 001c D6BE898E 		.word	-1903575338
 291              		.cfi_endproc
 292              	.LFE0:
 294              		.section	.text.buffer_get,"ax",%progbits
 295              		.align	1
 296              		.syntax unified
 297              		.thumb
 298              		.thumb_func
 299              		.fpu softvfp
 301              	buffer_get:
 302              	.LFB3:
 182:le_phy.c      **** 	int i;
 303              		.loc 1 182 0
 304              		.cfi_startproc
 305              		@ args = 0, pretend = 0, frame = 0
 306              		@ frame_needed = 0, uses_anonymous_args = 0
 307 0000 70B5     		push	{r4, r5, r6, lr}
 308              		.cfi_def_cfa_offset 16
 309              		.cfi_offset 4, -16
 310              		.cfi_offset 5, -12
 311              		.cfi_offset 6, -8
 312              		.cfi_offset 14, -4
 313              	.LVL18:
 185:le_phy.c      **** 		if (le_buffer_pool[i].available) {
 314              		.loc 1 185 0
 315 0002 0023     		movs	r3, #0
 316 0004 4FF49275 		mov	r5, #292
 317 0008 124C     		ldr	r4, .L28
ARM GAS  /tmp/ccnRyoKo.s 			page 22


 318 000a 04F5F471 		add	r1, r4, #488
 319              	.LVL19:
 320              	.L26:
 321 000e 05FB03F2 		mul	r2, r5, r3
 322 0012 8E18     		adds	r6, r1, r2
 186:le_phy.c      **** 			le_buffer_pool[i].available = 0;
 323              		.loc 1 186 0
 324 0014 D6F81801 		ldr	r0, [r6, #280]
 325 0018 B8B1     		cbz	r0, .L24
 187:le_phy.c      **** 			buffer_clear(&le_buffer_pool[i]);
 326              		.loc 1 187 0
 327 001a 0025     		movs	r5, #0
 328 001c 1444     		add	r4, r4, r2
 329 001e C4F80053 		str	r5, [r4, #768]
 330              	.LVL20:
 331              	.LBB7:
 332              	.LBB8:
 171:le_phy.c      **** 	buf->size = 0;
 333              		.loc 1 171 0
 334 0022 C4F8F052 		str	r5, [r4, #752]
 172:le_phy.c      **** 	memset(buf->data, 0, sizeof(buf->data));
 335              		.loc 1 172 0
 336 0026 C4F8EC52 		str	r5, [r4, #748]
 173:le_phy.c      **** 	buf->rssi_min = INT8_MAX;
 337              		.loc 1 173 0
 338 002a 4FF48272 		mov	r2, #260
 339 002e 2946     		mov	r1, r5
 340 0030 3046     		mov	r0, r6
 341 0032 FFF7FEFF 		bl	memset
 342              	.LVL21:
 174:le_phy.c      **** 	buf->rssi_max = INT8_MIN;
 343              		.loc 1 174 0
 344 0036 7F23     		movs	r3, #127
 345 0038 84F80433 		strb	r3, [r4, #772]
 175:le_phy.c      **** 	buf->rssi_sum = 0;
 346              		.loc 1 175 0
 347 003c 8023     		movs	r3, #128
 176:le_phy.c      **** }
 348              		.loc 1 176 0
 349 003e C4F80853 		str	r5, [r4, #776]
 175:le_phy.c      **** 	buf->rssi_sum = 0;
 350              		.loc 1 175 0
 351 0042 84F80533 		strb	r3, [r4, #773]
 176:le_phy.c      **** }
 352              		.loc 1 176 0
 353 0046 3046     		mov	r0, r6
 354 0048 70BD     		pop	{r4, r5, r6, pc}
 355              	.LVL22:
 356              	.L24:
 357              	.LBE8:
 358              	.LBE7:
 185:le_phy.c      **** 		if (le_buffer_pool[i].available) {
 359              		.loc 1 185 0 discriminator 2
 360 004a 0133     		adds	r3, r3, #1
 361              	.LVL23:
 362 004c 042B     		cmp	r3, #4
 363 004e DED1     		bne	.L26
ARM GAS  /tmp/ccnRyoKo.s 			page 23


 194:le_phy.c      **** 
 364              		.loc 1 194 0
 365 0050 70BD     		pop	{r4, r5, r6, pc}
 366              	.L29:
 367 0052 00BF     		.align	2
 368              	.L28:
 369 0054 00000000 		.word	.LANCHOR0
 370              		.cfi_endproc
 371              	.LFE3:
 373              		.section	.text.le_cc2400_init_rf,"ax",%progbits
 374              		.align	1
 375              		.syntax unified
 376              		.thumb
 377              		.thumb_func
 378              		.fpu softvfp
 380              	le_cc2400_init_rf:
 381              	.LFB10:
 441:le_phy.c      **** 	u16 grmdm, mdmctrl;
 382              		.loc 1 441 0
 383              		.cfi_startproc
 384              		@ args = 0, pretend = 0, frame = 0
 385              		@ frame_needed = 0, uses_anonymous_args = 0
 386 0000 10B5     		push	{r4, lr}
 387              		.cfi_def_cfa_offset 8
 388              		.cfi_offset 4, -8
 389              		.cfi_offset 14, -4
 443:le_phy.c      **** 
 390              		.loc 1 443 0
 391 0002 1B4B     		ldr	r3, .L34
 392 0004 186A     		ldr	r0, [r3, #32]
 393 0006 FFF7FEFF 		bl	rbit
 394              	.LVL24:
 395 000a 0446     		mov	r4, r0
 396              	.LVL25:
 455:le_phy.c      **** 	cc2400_set(LMTST,   0x2b22);
 397              		.loc 1 455 0
 398 000c 47F6FE71 		movw	r1, #32766
 399 0010 0D20     		movs	r0, #13
 400              	.LVL26:
 401 0012 FFF7FEFF 		bl	cc2400_set
 402              	.LVL27:
 456:le_phy.c      **** 
 403              		.loc 1 456 0
 404 0016 42F62231 		movw	r1, #11042
 405 001a 1220     		movs	r0, #18
 406 001c FFF7FEFF 		bl	cc2400_set
 407              	.LVL28:
 458:le_phy.c      **** 	// 1      2      4b
 408              		.loc 1 458 0
 409 0020 41F24B21 		movw	r1, #4683
 410 0024 1420     		movs	r0, #20
 411 0026 FFF7FEFF 		bl	cc2400_set
 412              	.LVL29:
 471:le_phy.c      **** 
 413              		.loc 1 471 0
 414 002a 44F2E141 		movw	r1, #17633
 415 002e 2020     		movs	r0, #32
ARM GAS  /tmp/ccnRyoKo.s 			page 24


 416 0030 FFF7FEFF 		bl	cc2400_set
 417              	.LVL30:
 473:le_phy.c      **** 	cc2400_set(SYNCH,   (sync >> 16) & 0xffff);
 418              		.loc 1 473 0
 419 0034 A1B2     		uxth	r1, r4
 420 0036 2C20     		movs	r0, #44
 421 0038 FFF7FEFF 		bl	cc2400_set
 422              	.LVL31:
 474:le_phy.c      **** 
 423              		.loc 1 474 0
 424 003c 210C     		lsrs	r1, r4, #16
 425 003e 2D20     		movs	r0, #45
 426 0040 FFF7FEFF 		bl	cc2400_set
 427              	.LVL32:
 476:le_phy.c      **** 	cc2400_set(MDMCTRL, mdmctrl);
 428              		.loc 1 476 0
 429 0044 0B4B     		ldr	r3, .L34+4
 430 0046 0220     		movs	r0, #2
 431 0048 1988     		ldrh	r1, [r3]
 432 004a 0139     		subs	r1, r1, #1
 433 004c 89B2     		uxth	r1, r1
 434 004e FFF7FEFF 		bl	cc2400_set
 435              	.LVL33:
 477:le_phy.c      **** 
 436              		.loc 1 477 0
 437 0052 4021     		movs	r1, #64
 438 0054 0320     		movs	r0, #3
 439 0056 FFF7FEFF 		bl	cc2400_set
 440              	.LVL34:
 441              	.L31:
 480:le_phy.c      **** 
 442              		.loc 1 480 0 discriminator 1
 443 005a FFF7FEFF 		bl	cc2400_status
 444              	.LVL35:
 445 005e 4306     		lsls	r3, r0, #25
 446 0060 FBD5     		bpl	.L31
 483:le_phy.c      **** 	timer1_wait_fs_lock();
 447              		.loc 1 483 0
 448 0062 6120     		movs	r0, #97
 449 0064 FFF7FEFF 		bl	cc2400_strobe
 450              	.LVL36:
 485:le_phy.c      **** 
 451              		.loc 1 485 0
 452 0068 BDE81040 		pop	{r4, lr}
 453              		.cfi_restore 14
 454              		.cfi_restore 4
 455              		.cfi_def_cfa_offset 0
 456              	.LVL37:
 484:le_phy.c      **** }
 457              		.loc 1 484 0
 458 006c FFF7FEBF 		b	timer1_wait_fs_lock
 459              	.LVL38:
 460              	.L35:
 461              		.align	2
 462              	.L34:
 463 0070 00000000 		.word	.LANCHOR0
 464 0074 00000000 		.word	rf_channel
ARM GAS  /tmp/ccnRyoKo.s 			page 25


 465              		.cfi_endproc
 466              	.LFE10:
 468              		.section	.text.change_channel,"ax",%progbits
 469              		.align	1
 470              		.syntax unified
 471              		.thumb
 472              		.thumb_func
 473              		.fpu softvfp
 475              	change_channel:
 476              	.LFB12:
 497:le_phy.c      **** 	uint8_t channel_idx = 0;
 477              		.loc 1 497 0
 478              		.cfi_startproc
 479              		@ args = 0, pretend = 0, frame = 0
 480              		@ frame_needed = 0, uses_anonymous_args = 0
 481 0000 70B5     		push	{r4, r5, r6, lr}
 482              		.cfi_def_cfa_offset 16
 483              		.cfi_offset 4, -16
 484              		.cfi_offset 5, -12
 485              		.cfi_offset 6, -8
 486              		.cfi_offset 14, -4
 487              	.LVL39:
 500:le_phy.c      **** 
 488              		.loc 1 500 0
 489 0002 6420     		movs	r0, #100
 490 0004 FFF7FEFF 		bl	cc2400_strobe
 491              	.LVL40:
 503:le_phy.c      **** 	while (SSP1SR & SSPSR_RNE) {
 492              		.loc 1 503 0
 493 0008 284A     		ldr	r2, .L44
 494 000a 1368     		ldr	r3, [r2]
 495              	.LBB12:
 505:le_phy.c      **** 	}
 496              		.loc 1 505 0
 497 000c 1C3A     		subs	r2, r2, #28
 498              	.LBE12:
 503:le_phy.c      **** 	while (SSP1SR & SSPSR_RNE) {
 499              		.loc 1 503 0
 500 000e 23F00103 		bic	r3, r3, #1
 501 0012 D361     		str	r3, [r2, #28]
 504:le_phy.c      **** 		uint8_t tmp = (uint8_t)DIO_SSP_DR;
 502              		.loc 1 504 0
 503 0014 264B     		ldr	r3, .L44+4
 504              	.L37:
 505 0016 1C68     		ldr	r4, [r3]
 506 0018 14F00404 		ands	r4, r4, #4
 507 001c 30D1     		bne	.L38
 508:le_phy.c      **** 	le_dma_init();
 508              		.loc 1 508 0
 509 001e 254D     		ldr	r5, .L44+8
 510              	.LBB13:
 511              	.LBB14:
 173:le_phy.c      **** 	buf->rssi_min = INT8_MAX;
 512              		.loc 1 173 0
 513 0020 4FF48272 		mov	r2, #260
 514              	.LBE14:
 515              	.LBE13:
ARM GAS  /tmp/ccnRyoKo.s 			page 26


 508:le_phy.c      **** 	le_dma_init();
 516              		.loc 1 508 0
 517 0024 D5F87866 		ldr	r6, [r5, #1656]
 518              	.LVL41:
 519              	.LBB16:
 520              	.LBB15:
 173:le_phy.c      **** 	buf->rssi_min = INT8_MAX;
 521              		.loc 1 173 0
 522 0028 2146     		mov	r1, r4
 171:le_phy.c      **** 	buf->size = 0;
 523              		.loc 1 171 0
 524 002a C6F80841 		str	r4, [r6, #264]
 172:le_phy.c      **** 	memset(buf->data, 0, sizeof(buf->data));
 525              		.loc 1 172 0
 526 002e C6F80441 		str	r4, [r6, #260]
 173:le_phy.c      **** 	buf->rssi_min = INT8_MAX;
 527              		.loc 1 173 0
 528 0032 3046     		mov	r0, r6
 529 0034 FFF7FEFF 		bl	memset
 530              	.LVL42:
 174:le_phy.c      **** 	buf->rssi_max = INT8_MIN;
 531              		.loc 1 174 0
 532 0038 7F23     		movs	r3, #127
 533 003a 86F81C31 		strb	r3, [r6, #284]
 175:le_phy.c      **** 	buf->rssi_sum = 0;
 534              		.loc 1 175 0
 535 003e 8023     		movs	r3, #128
 176:le_phy.c      **** }
 536              		.loc 1 176 0
 537 0040 C6F82041 		str	r4, [r6, #288]
 538              	.LVL43:
 175:le_phy.c      **** 	buf->rssi_sum = 0;
 539              		.loc 1 175 0
 540 0044 86F81D31 		strb	r3, [r6, #285]
 541              	.LBE15:
 542              	.LBE16:
 509:le_phy.c      **** 	dio_ssp_start();
 543              		.loc 1 509 0
 544 0048 FFF7FEFF 		bl	le_dma_init
 545              	.LVL44:
 510:le_phy.c      **** 
 546              		.loc 1 510 0
 547 004c FFF7FEFF 		bl	dio_ssp_start
 548              	.LVL45:
 512:le_phy.c      **** 		// FIXME
 549              		.loc 1 512 0
 550 0050 2A6A     		ldr	r2, [r5, #32]
 551 0052 194B     		ldr	r3, .L44+12
 552 0054 9A42     		cmp	r2, r3
 553 0056 17D1     		bne	.L39
 514:le_phy.c      **** 			case 2402: channel_idx = 37; break;
 554              		.loc 1 514 0
 555 0058 40F67A12 		movw	r2, #2426
 556 005c 174B     		ldr	r3, .L44+16
 557 005e 1B88     		ldrh	r3, [r3]
 558 0060 9BB2     		uxth	r3, r3
 559 0062 9342     		cmp	r3, r2
ARM GAS  /tmp/ccnRyoKo.s 			page 27


 560 0064 0ED0     		beq	.L41
 515:le_phy.c      **** 			case 2426: channel_idx = 38; break;
 561              		.loc 1 515 0
 562 0066 B3F51B6F 		cmp	r3, #2480
 563 006a 0CBF     		ite	eq
 564 006c 2720     		moveq	r0, #39
 565 006e 2520     		movne	r0, #37
 566              	.LVL46:
 567              	.L40:
 525:le_phy.c      **** 	le_cc2400_init_rf();
 568              		.loc 1 525 0
 569 0070 FFF7FEFF 		bl	btle_channel_index_to_phys
 570              	.LVL47:
 527:le_phy.c      **** 
 571              		.loc 1 527 0
 572 0074 BDE87040 		pop	{r4, r5, r6, lr}
 573              		.cfi_remember_state
 574              		.cfi_restore 14
 575              		.cfi_restore 6
 576              		.cfi_restore 5
 577              		.cfi_restore 4
 578              		.cfi_def_cfa_offset 0
 525:le_phy.c      **** 	le_cc2400_init_rf();
 579              		.loc 1 525 0
 580 0078 114B     		ldr	r3, .L44+20
 581 007a 1880     		strh	r0, [r3]	@ movhi
 526:le_phy.c      **** }
 582              		.loc 1 526 0
 583 007c FFF7FEBF 		b	le_cc2400_init_rf
 584              	.LVL48:
 585              	.L38:
 586              		.cfi_restore_state
 587              	.LBB17:
 505:le_phy.c      **** 	}
 588              		.loc 1 505 0
 589 0080 1168     		ldr	r1, [r2]
 590 0082 C8E7     		b	.L37
 591              	.L41:
 592              	.LBE17:
 516:le_phy.c      **** 			case 2480: channel_idx = 39; break;
 593              		.loc 1 516 0
 594 0084 2620     		movs	r0, #38
 595 0086 F3E7     		b	.L40
 596              	.L39:
 521:le_phy.c      **** 		channel_idx = le_map_channel(conn.channel_idx, &conn.remapping);
 597              		.loc 1 521 0
 598 0088 2522     		movs	r2, #37
 599 008a 95F82C00 		ldrb	r0, [r5, #44]	@ zero_extendqisi2
 600 008e 95F82D30 		ldrb	r3, [r5, #45]	@ zero_extendqisi2
 522:le_phy.c      **** 	}
 601              		.loc 1 522 0
 602 0092 05F14001 		add	r1, r5, #64
 521:le_phy.c      **** 		channel_idx = le_map_channel(conn.channel_idx, &conn.remapping);
 603              		.loc 1 521 0
 604 0096 0344     		add	r3, r3, r0
 605 0098 93FBF2F0 		sdiv	r0, r3, r2
 606 009c 02FB1030 		mls	r0, r2, r0, r3
ARM GAS  /tmp/ccnRyoKo.s 			page 28


 607 00a0 C0B2     		uxtb	r0, r0
 608 00a2 85F82C00 		strb	r0, [r5, #44]
 522:le_phy.c      **** 	}
 609              		.loc 1 522 0
 610 00a6 FFF7FEFF 		bl	le_map_channel
 611              	.LVL49:
 612 00aa E1E7     		b	.L40
 613              	.L45:
 614              		.align	2
 615              	.L44:
 616 00ac 24000340 		.word	1073938468
 617 00b0 0C000340 		.word	1073938444
 618 00b4 00000000 		.word	.LANCHOR0
 619 00b8 D6BE898E 		.word	-1903575338
 620 00bc 00000000 		.word	le_adv_channel
 621 00c0 00000000 		.word	rf_channel
 622              		.cfi_endproc
 623              	.LFE12:
 625              		.section	.text.finish_conn_event,"ax",%progbits
 626              		.align	1
 627              		.syntax unified
 628              		.thumb
 629              		.thumb_func
 630              		.fpu softvfp
 632              	finish_conn_event:
 633              	.LFB6:
 225:le_phy.c      **** 	uint32_t last_anchor = 0;
 634              		.loc 1 225 0
 635              		.cfi_startproc
 636              		@ args = 0, pretend = 0, frame = 0
 637              		@ frame_needed = 0, uses_anonymous_args = 0
 638 0000 38B5     		push	{r3, r4, r5, lr}
 639              		.cfi_def_cfa_offset 16
 640              		.cfi_offset 3, -16
 641              		.cfi_offset 4, -12
 642              		.cfi_offset 5, -8
 643              		.cfi_offset 14, -4
 644              	.LVL50:
 229:le_phy.c      **** 		last_anchor = conn_event.anchor;
 645              		.loc 1 229 0
 646 0002 2A4A     		ldr	r2, .L64
 647 0004 2A4B     		ldr	r3, .L64+4
 648 0006 5068     		ldr	r0, [r2, #4]
 649 0008 0228     		cmp	r0, #2
 650 000a 06D1     		bne	.L47
 230:le_phy.c      **** 		last_anchor_set = 1;
 651              		.loc 1 230 0
 652 000c 1468     		ldr	r4, [r2]
 653              	.LVL51:
 654              	.L48:
 250:le_phy.c      **** 	}
 655              		.loc 1 250 0
 656 000e 0121     		movs	r1, #1
 249:le_phy.c      **** 		conn.anchor_set = 1;
 657              		.loc 1 249 0
 658 0010 C3F80041 		str	r4, [r3, #256]
 250:le_phy.c      **** 	}
ARM GAS  /tmp/ccnRyoKo.s 			page 29


 659              		.loc 1 250 0
 660 0014 C3F80411 		str	r1, [r3, #260]
 661 0018 1EE0     		b	.L50
 662              	.LVL52:
 663              	.L47:
 235:le_phy.c      **** 		// calculate the difference between the estimated and observed anchor
 664              		.loc 1 235 0
 665 001a 0128     		cmp	r0, #1
 666 001c 0BD1     		bne	.L49
 235:le_phy.c      **** 		// calculate the difference between the estimated and observed anchor
 667              		.loc 1 235 0 is_stmt 0 discriminator 1
 668 001e D3F80411 		ldr	r1, [r3, #260]
 669 0022 41B1     		cbz	r1, .L49
 670              	.LVL53:
 671              	.LBB21:
 237:le_phy.c      **** 		uint32_t delta = estimated_anchor - conn_event.anchor;
 672              		.loc 1 237 0 is_stmt 1
 673 0024 D3F80011 		ldr	r1, [r3, #256]
 674 0028 1D6B     		ldr	r5, [r3, #48]
 238:le_phy.c      **** 		// see whether the observed anchor is within 3 us of the estimate
 675              		.loc 1 238 0
 676 002a 1468     		ldr	r4, [r2]
 677              	.LVL54:
 237:le_phy.c      **** 		uint32_t delta = estimated_anchor - conn_event.anchor;
 678              		.loc 1 237 0
 679 002c 2944     		add	r1, r1, r5
 680              	.LVL55:
 240:le_phy.c      **** 		if (delta < 2 * ANCHOR_EPSILON) {
 681              		.loc 1 240 0
 682 002e 1E31     		adds	r1, r1, #30
 683              	.LVL56:
 684 0030 091B     		subs	r1, r1, r4
 685              	.LVL57:
 241:le_phy.c      **** 			last_anchor = conn_event.anchor;
 686              		.loc 1 241 0
 687 0032 3B29     		cmp	r1, #59
 688 0034 EBD9     		bls	.L48
 689              	.LVL58:
 690              	.L49:
 691              	.LBE21:
 254:le_phy.c      **** 		conn.last_anchor += conn.conn_interval;
 692              		.loc 1 254 0
 693 0036 D3F80411 		ldr	r1, [r3, #260]
 694 003a 39B9     		cbnz	r1, .L54
 260:le_phy.c      **** 		conn.last_packet_ts = NOW; // FIXME gross hack
 695              		.loc 1 260 0
 696 003c 1168     		ldr	r1, [r2]
 697 003e C3F80011 		str	r1, [r3, #256]
 261:le_phy.c      **** 	}
 698              		.loc 1 261 0
 699 0042 1C49     		ldr	r1, .L64+8
 700 0044 0968     		ldr	r1, [r1]
 701 0046 C3F80811 		str	r1, [r3, #264]
 702 004a 05E0     		b	.L50
 703              	.L54:
 255:le_phy.c      **** 	}
 704              		.loc 1 255 0
ARM GAS  /tmp/ccnRyoKo.s 			page 30


 705 004c D3F80011 		ldr	r1, [r3, #256]
 706 0050 1C6B     		ldr	r4, [r3, #48]
 707 0052 2144     		add	r1, r1, r4
 708 0054 C3F80011 		str	r1, [r3, #256]
 709              	.LVL59:
 710              	.L50:
 711 0058 164C     		ldr	r4, .L64+8
 265:le_phy.c      **** 		conn.last_packet_ts = NOW;
 712              		.loc 1 265 0
 713 005a 10B1     		cbz	r0, .L51
 266:le_phy.c      **** 	}
 714              		.loc 1 266 0
 715 005c 2168     		ldr	r1, [r4]
 716 005e C3F80811 		str	r1, [r3, #264]
 717              	.L51:
 718              	.LBB22:
 719              	.LBB23:
 203:le_phy.c      **** 	conn_event.opened = 0;
 720              		.loc 1 203 0
 721 0062 0021     		movs	r1, #0
 722 0064 5160     		str	r1, [r2, #4]
 204:le_phy.c      **** }
 723              		.loc 1 204 0
 724 0066 9160     		str	r1, [r2, #8]
 725              	.LBE23:
 726              	.LBE22:
 272:le_phy.c      **** 
 727              		.loc 1 272 0
 728 0068 B3F80C21 		ldrh	r2, [r3, #268]
 275:le_phy.c      **** 		reset_conn();
 729              		.loc 1 275 0
 730 006c D3F80801 		ldr	r0, [r3, #264]
 272:le_phy.c      **** 
 731              		.loc 1 272 0
 732 0070 0132     		adds	r2, r2, #1
 733 0072 A3F80C21 		strh	r2, [r3, #268]	@ movhi
 275:le_phy.c      **** 		reset_conn();
 734              		.loc 1 275 0
 735 0076 2268     		ldr	r2, [r4]
 736 0078 121A     		subs	r2, r2, r0
 737 007a 586B     		ldr	r0, [r3, #52]
 738 007c 8242     		cmp	r2, r0
 739 007e 05D9     		bls	.L52
 740              	.L63:
 283:le_phy.c      **** 		change_channel();
 741              		.loc 1 283 0
 742 0080 FFF7FEFF 		bl	reset_conn
 743              	.LVL60:
 291:le_phy.c      **** 
 744              		.loc 1 291 0
 745 0084 BDE83840 		pop	{r3, r4, r5, lr}
 746              		.cfi_remember_state
 747              		.cfi_restore 14
 748              		.cfi_restore 5
 749              		.cfi_restore 4
 750              		.cfi_restore 3
 751              		.cfi_def_cfa_offset 0
ARM GAS  /tmp/ccnRyoKo.s 			page 31


 284:le_phy.c      **** 	}
 752              		.loc 1 284 0
 753 0088 FFF7FEBF 		b	change_channel
 754              	.LVL61:
 755              	.L52:
 756              		.cfi_restore_state
 281:le_phy.c      **** 		cancel_follow = 0;
 757              		.loc 1 281 0
 758 008c 0A4A     		ldr	r2, .L64+12
 759 008e 1068     		ldr	r0, [r2]
 760 0090 08B1     		cbz	r0, .L53
 282:le_phy.c      **** 		reset_conn();
 761              		.loc 1 282 0
 762 0092 1160     		str	r1, [r2]
 763 0094 F4E7     		b	.L63
 764              	.L53:
 289:le_phy.c      **** 	}
 765              		.loc 1 289 0
 766 0096 D3F80001 		ldr	r0, [r3, #256]
 767 009a 1B6B     		ldr	r3, [r3, #48]
 768 009c 1844     		add	r0, r0, r3
 769 009e A0F6B830 		subw	r0, r0, #3000
 291:le_phy.c      **** 
 770              		.loc 1 291 0
 771 00a2 BDE83840 		pop	{r3, r4, r5, lr}
 772              		.cfi_restore 14
 773              		.cfi_restore 5
 774              		.cfi_restore 4
 775              		.cfi_restore 3
 776              		.cfi_def_cfa_offset 0
 289:le_phy.c      **** 	}
 777              		.loc 1 289 0
 778 00a6 FFF7FEBF 		b	timer1_set_match
 779              	.LVL62:
 780              	.L65:
 781 00aa 00BF     		.align	2
 782              	.L64:
 783 00ac 00000000 		.word	conn_event
 784 00b0 00000000 		.word	.LANCHOR0
 785 00b4 08800040 		.word	1073774600
 786 00b8 00000000 		.word	cancel_follow
 787              		.cfi_endproc
 788              	.LFE6:
 790              		.section	.text.le_DMA_IRQHandler,"ax",%progbits
 791              		.align	1
 792              		.global	le_DMA_IRQHandler
 793              		.syntax unified
 794              		.thumb
 795              		.thumb_func
 796              		.fpu softvfp
 798              	le_DMA_IRQHandler:
 799              	.LFB7:
 297:le_phy.c      ****     debug_printf("le_DMA_IRQHandler\n");
 800              		.loc 1 297 0
 801              		.cfi_startproc
 802              		@ args = 0, pretend = 0, frame = 0
 803              		@ frame_needed = 0, uses_anonymous_args = 0
ARM GAS  /tmp/ccnRyoKo.s 			page 32


 804 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 805              		.cfi_def_cfa_offset 24
 806              		.cfi_offset 3, -24
 807              		.cfi_offset 4, -20
 808              		.cfi_offset 5, -16
 809              		.cfi_offset 6, -12
 810              		.cfi_offset 7, -8
 811              		.cfi_offset 14, -4
 298:le_phy.c      **** 	unsigned pos;
 812              		.loc 1 298 0
 813 0002 6948     		ldr	r0, .L89
 814 0004 FFF7FEFF 		bl	debug_printf
 815              	.LVL63:
 301:le_phy.c      **** 
 816              		.loc 1 301 0
 817 0008 684D     		ldr	r5, .L89+4
 304:le_phy.c      **** 		// terminal count - byte received
 818              		.loc 1 304 0
 819 000a 694B     		ldr	r3, .L89+8
 301:le_phy.c      **** 
 820              		.loc 1 301 0
 821 000c 2F68     		ldr	r7, [r5]
 822              	.LVL64:
 304:le_phy.c      **** 		// terminal count - byte received
 823              		.loc 1 304 0
 824 000e 1B68     		ldr	r3, [r3]
 825 0010 DE07     		lsls	r6, r3, #31
 826 0012 49D5     		bpl	.L66
 306:le_phy.c      **** 			DMACIntTCClear = (1 << 0);
 827              		.loc 1 306 0
 828 0014 674B     		ldr	r3, .L89+12
 829 0016 1B68     		ldr	r3, [r3]
 830 0018 DC07     		lsls	r4, r3, #31
 831 001a 3ED5     		bpl	.L75
 307:le_phy.c      **** 
 832              		.loc 1 307 0
 833 001c 0123     		movs	r3, #1
 834 001e 664E     		ldr	r6, .L89+16
 310:le_phy.c      **** 			current_rxbuf->rssi_sum += rssi;
 835              		.loc 1 310 0
 836 0020 0620     		movs	r0, #6
 307:le_phy.c      **** 
 837              		.loc 1 307 0
 838 0022 3360     		str	r3, [r6]
 310:le_phy.c      **** 			current_rxbuf->rssi_sum += rssi;
 839              		.loc 1 310 0
 840 0024 FFF7FEFF 		bl	cc2400_get
 841              	.LVL65:
 311:le_phy.c      **** 			if (rssi < current_rxbuf->rssi_min) current_rxbuf->rssi_min = rssi;
 842              		.loc 1 311 0
 843 0028 644C     		ldr	r4, .L89+20
 310:le_phy.c      **** 			current_rxbuf->rssi_sum += rssi;
 844              		.loc 1 310 0
 845 002a 40F30720 		sbfx	r0, r0, #8, #8
 846              	.LVL66:
 311:le_phy.c      **** 			if (rssi < current_rxbuf->rssi_min) current_rxbuf->rssi_min = rssi;
 847              		.loc 1 311 0
ARM GAS  /tmp/ccnRyoKo.s 			page 33


 848 002e D4F87836 		ldr	r3, [r4, #1656]
 312:le_phy.c      **** 			if (rssi > current_rxbuf->rssi_max) current_rxbuf->rssi_max = rssi;
 849              		.loc 1 312 0
 850 0032 93F91C21 		ldrsb	r2, [r3, #284]
 311:le_phy.c      **** 			if (rssi < current_rxbuf->rssi_min) current_rxbuf->rssi_min = rssi;
 851              		.loc 1 311 0
 852 0036 D3F82011 		ldr	r1, [r3, #288]
 312:le_phy.c      **** 			if (rssi > current_rxbuf->rssi_max) current_rxbuf->rssi_max = rssi;
 853              		.loc 1 312 0
 854 003a 8242     		cmp	r2, r0
 313:le_phy.c      **** 
 855              		.loc 1 313 0
 856 003c 93F91D21 		ldrsb	r2, [r3, #285]
 312:le_phy.c      **** 			if (rssi > current_rxbuf->rssi_max) current_rxbuf->rssi_max = rssi;
 857              		.loc 1 312 0
 858 0040 C8BF     		it	gt
 859 0042 83F81C01 		strbgt	r0, [r3, #284]
 313:le_phy.c      **** 
 860              		.loc 1 313 0
 861 0046 8242     		cmp	r2, r0
 316:le_phy.c      **** 			current_rxbuf->data[pos] = le_dma_dest[pos & 1]; // dirty hack
 862              		.loc 1 316 0
 863 0048 D3F80821 		ldr	r2, [r3, #264]
 864              	.LVL67:
 311:le_phy.c      **** 			if (rssi < current_rxbuf->rssi_min) current_rxbuf->rssi_min = rssi;
 865              		.loc 1 311 0
 866 004c 0144     		add	r1, r1, r0
 313:le_phy.c      **** 
 867              		.loc 1 313 0
 868 004e B8BF     		it	lt
 869 0050 83F81D01 		strblt	r0, [r3, #285]
 317:le_phy.c      **** 			pos += 1;
 870              		.loc 1 317 0
 871 0054 5A48     		ldr	r0, .L89+24
 872              	.LVL68:
 311:le_phy.c      **** 			if (rssi < current_rxbuf->rssi_min) current_rxbuf->rssi_min = rssi;
 873              		.loc 1 311 0
 874 0056 C3F82011 		str	r1, [r3, #288]
 317:le_phy.c      **** 			pos += 1;
 875              		.loc 1 317 0
 876 005a 02F00101 		and	r1, r2, #1
 877 005e 415C     		ldrb	r1, [r0, r1]	@ zero_extendqisi2
 878 0060 9954     		strb	r1, [r3, r2]
 318:le_phy.c      **** 			current_rxbuf->pos = pos;
 879              		.loc 1 318 0
 880 0062 0132     		adds	r2, r2, #1
 881              	.LVL69:
 321:le_phy.c      **** 				current_rxbuf->timestamp = timestamp - USEC(8 + 32); // packet starts at preamble
 882              		.loc 1 321 0
 883 0064 012A     		cmp	r2, #1
 319:le_phy.c      **** 
 884              		.loc 1 319 0
 885 0066 C3F80821 		str	r2, [r3, #264]
 321:le_phy.c      **** 				current_rxbuf->timestamp = timestamp - USEC(8 + 32); // packet starts at preamble
 886              		.loc 1 321 0
 887 006a 1ED1     		bne	.L72
 323:le_phy.c      **** 				current_rxbuf->access_address = conn.access_address;
ARM GAS  /tmp/ccnRyoKo.s 			page 34


 888              		.loc 1 323 0
 889 006c 5549     		ldr	r1, .L89+28
 322:le_phy.c      **** 				current_rxbuf->channel = rf_channel;
 890              		.loc 1 322 0
 891 006e A7F5C877 		sub	r7, r7, #400
 892              	.LVL70:
 323:le_phy.c      **** 				current_rxbuf->access_address = conn.access_address;
 893              		.loc 1 323 0
 894 0072 0A88     		ldrh	r2, [r1]
 895              	.LVL71:
 328:le_phy.c      **** 					timer1_clear_match();
 896              		.loc 1 328 0
 897 0074 0888     		ldrh	r0, [r1]
 323:le_phy.c      **** 				current_rxbuf->access_address = conn.access_address;
 898              		.loc 1 323 0
 899 0076 92B2     		uxth	r2, r2
 900 0078 C3F81021 		str	r2, [r3, #272]
 324:le_phy.c      **** 
 901              		.loc 1 324 0
 902 007c 226A     		ldr	r2, [r4, #32]
 322:le_phy.c      **** 				current_rxbuf->channel = rf_channel;
 903              		.loc 1 322 0
 904 007e C3F80C71 		str	r7, [r3, #268]
 324:le_phy.c      **** 
 905              		.loc 1 324 0
 906 0082 C3F81421 		str	r2, [r3, #276]
 328:le_phy.c      **** 					timer1_clear_match();
 907              		.loc 1 328 0
 908 0086 80B2     		uxth	r0, r0
 909 0088 FFF7FEFF 		bl	btle_channel_index
 910              	.LVL72:
 911 008c 2428     		cmp	r0, #36
 912 008e 04D8     		bhi	.L75
 913              	.LBB30:
 914              	.LBB31:
 554:le_phy.c      **** }
 915              		.loc 1 554 0
 916 0090 4D4A     		ldr	r2, .L89+32
 917 0092 1368     		ldr	r3, [r2]
 918 0094 23F00103 		bic	r3, r3, #1
 919 0098 1360     		str	r3, [r2]
 920              	.LVL73:
 921              	.L75:
 922              	.LBE31:
 923              	.LBE30:
 389:le_phy.c      **** 			// TODO error state transition
 924              		.loc 1 389 0
 925 009a 4C4B     		ldr	r3, .L89+36
 926 009c 1B68     		ldr	r3, [r3]
 927 009e DB07     		lsls	r3, r3, #31
 391:le_phy.c      **** 		}
 928              		.loc 1 391 0
 929 00a0 42BF     		ittt	mi
 930 00a2 0122     		movmi	r2, #1
 931 00a4 4A4B     		ldrmi	r3, .L89+40
 932 00a6 1A60     		strmi	r2, [r3]
 933              	.L66:
ARM GAS  /tmp/ccnRyoKo.s 			page 35


 934 00a8 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 935              	.LVL74:
 936              	.L72:
 334:le_phy.c      **** 				uint8_t length = dewhiten_length(current_rxbuf->channel, current_rxbuf->data[1]);
 937              		.loc 1 334 0
 938 00aa 022A     		cmp	r2, #2
 939 00ac 2ED1     		bne	.L73
 940              	.LBB32:
 941              	.LBB33:
 942              	.LBB34:
 686:le_phy.c      **** 	uint8_t out = 0;
 943              		.loc 1 686 0
 944 00ae B3F81001 		ldrh	r0, [r3, #272]
 945              	.LBE34:
 946              	.LBE33:
 335:le_phy.c      **** 				current_rxbuf->size = length + 2 + 3; // two bytes for header and three for CRC
 947              		.loc 1 335 0
 948 00b2 5E78     		ldrb	r6, [r3, #1]	@ zero_extendqisi2
 949              	.LVL75:
 950              	.LBB36:
 951              	.LBB35:
 686:le_phy.c      **** 	uint8_t out = 0;
 952              		.loc 1 686 0
 953 00b4 FFF7FEFF 		bl	btle_channel_index
 954              	.LVL76:
 690:le_phy.c      **** 
 955              		.loc 1 690 0
 956 00b8 7F27     		movs	r7, #127
 957              	.LVL77:
 687:le_phy.c      **** 
 958              		.loc 1 687 0
 959 00ba 0021     		movs	r1, #0
 686:le_phy.c      **** 	uint8_t out = 0;
 960              		.loc 1 686 0
 961 00bc 454D     		ldr	r5, .L89+44
 962 00be 2B5C     		ldrb	r3, [r5, r0]	@ zero_extendqisi2
 963 00c0 AE46     		mov	lr, r5
 690:le_phy.c      **** 
 964              		.loc 1 690 0
 965 00c2 0833     		adds	r3, r3, #8
 966 00c4 B3FBF7F2 		udiv	r2, r3, r7
 692:le_phy.c      **** 		bit = (data >> (7-i)) & 1;
 967              		.loc 1 692 0
 968 00c8 0846     		mov	r0, r1
 969              	.LVL78:
 690:le_phy.c      **** 
 970              		.loc 1 690 0
 971 00ca C2EBC212 		rsb	r2, r2, r2, lsl #7
 972 00ce 9B1A     		subs	r3, r3, r2
 973              	.LVL79:
 974              	.L74:
 693:le_phy.c      **** 		bit ^= whitening[idx];
 975              		.loc 1 693 0
 976 00d0 C0F10702 		rsb	r2, r0, #7
 977 00d4 46FA02F2 		asr	r2, r6, r2
 978 00d8 02F00105 		and	r5, r2, #1
 979              	.LVL80:
ARM GAS  /tmp/ccnRyoKo.s 			page 36


 694:le_phy.c      **** 		idx = (idx + 1) % sizeof(whitening);
 980              		.loc 1 694 0
 981 00dc 0EEB0302 		add	r2, lr, r3
 982 00e0 92F82820 		ldrb	r2, [r2, #40]	@ zero_extendqisi2
 695:le_phy.c      **** 		out |= bit << i;
 983              		.loc 1 695 0
 984 00e4 0133     		adds	r3, r3, #1
 985              	.LVL81:
 694:le_phy.c      **** 		idx = (idx + 1) % sizeof(whitening);
 986              		.loc 1 694 0
 987 00e6 6A40     		eors	r2, r2, r5
 988              	.LVL82:
 695:le_phy.c      **** 		out |= bit << i;
 989              		.loc 1 695 0
 990 00e8 B3FBF7F5 		udiv	r5, r3, r7
 696:le_phy.c      **** 	}
 991              		.loc 1 696 0
 992 00ec 8240     		lsls	r2, r2, r0
 993              	.LVL83:
 692:le_phy.c      **** 		bit = (data >> (7-i)) & 1;
 994              		.loc 1 692 0
 995 00ee 0130     		adds	r0, r0, #1
 996              	.LVL84:
 695:le_phy.c      **** 		out |= bit << i;
 997              		.loc 1 695 0
 998 00f0 C5EBC515 		rsb	r5, r5, r5, lsl #7
 696:le_phy.c      **** 	}
 999              		.loc 1 696 0
 1000 00f4 0A43     		orrs	r2, r2, r1
 692:le_phy.c      **** 		bit = (data >> (7-i)) & 1;
 1001              		.loc 1 692 0
 1002 00f6 0828     		cmp	r0, #8
 695:le_phy.c      **** 		out |= bit << i;
 1003              		.loc 1 695 0
 1004 00f8 A3EB0503 		sub	r3, r3, r5
 1005              	.LVL85:
 696:le_phy.c      **** 	}
 1006              		.loc 1 696 0
 1007 00fc D1B2     		uxtb	r1, r2
 1008              	.LVL86:
 692:le_phy.c      **** 		bit = (data >> (7-i)) & 1;
 1009              		.loc 1 692 0
 1010 00fe E7D1     		bne	.L74
 1011              	.LVL87:
 1012              	.LBE35:
 1013              	.LBE36:
 336:le_phy.c      **** 			}
 1014              		.loc 1 336 0
 1015 0100 D4F87836 		ldr	r3, [r4, #1656]
 1016 0104 0531     		adds	r1, r1, #5
 1017 0106 C3F80411 		str	r1, [r3, #260]
 1018 010a C6E7     		b	.L75
 1019              	.LVL88:
 1020              	.L73:
 1021              	.LBE32:
 340:le_phy.c      **** 				// stop the CC2400 before flushing SSP
 1022              		.loc 1 340 0
ARM GAS  /tmp/ccnRyoKo.s 			page 37


 1023 010c C5D9     		bls	.L75
 340:le_phy.c      **** 				// stop the CC2400 before flushing SSP
 1024              		.loc 1 340 0 is_stmt 0 discriminator 1
 1025 010e D3F80431 		ldr	r3, [r3, #260]
 1026 0112 9A42     		cmp	r2, r3
 1027 0114 C1D3     		bcc	.L75
 342:le_phy.c      **** 
 1028              		.loc 1 342 0 is_stmt 1
 1029 0116 6120     		movs	r0, #97
 1030 0118 FFF7FEFF 		bl	cc2400_strobe
 1031              	.LVL89:
 345:le_phy.c      **** 				DMACIntTCClear = (1 << 0); // if we don't clear a second time, data is corrupt
 1032              		.loc 1 345 0
 1033 011c 0022     		movs	r2, #0
 1034 011e 2E4B     		ldr	r3, .L89+48
 1035              	.LBB37:
 350:le_phy.c      **** 				}
 1036              		.loc 1 350 0
 1037 0120 2E49     		ldr	r1, .L89+52
 1038              	.LBE37:
 345:le_phy.c      **** 				DMACIntTCClear = (1 << 0); // if we don't clear a second time, data is corrupt
 1039              		.loc 1 345 0
 1040 0122 1A60     		str	r2, [r3]
 346:le_phy.c      **** 
 1041              		.loc 1 346 0
 1042 0124 0123     		movs	r3, #1
 348:le_phy.c      **** 				while (SSP1SR & SSPSR_RNE) {
 1043              		.loc 1 348 0
 1044 0126 2E4A     		ldr	r2, .L89+56
 346:le_phy.c      **** 
 1045              		.loc 1 346 0
 1046 0128 3360     		str	r3, [r6]
 348:le_phy.c      **** 				while (SSP1SR & SSPSR_RNE) {
 1047              		.loc 1 348 0
 1048 012a 1368     		ldr	r3, [r2]
 349:le_phy.c      **** 					uint8_t tmp = (uint8_t)DIO_SSP_DR;
 1049              		.loc 1 349 0
 1050 012c 183A     		subs	r2, r2, #24
 348:le_phy.c      **** 				while (SSP1SR & SSPSR_RNE) {
 1051              		.loc 1 348 0
 1052 012e 23F00103 		bic	r3, r3, #1
 1053 0132 9361     		str	r3, [r2, #24]
 1054              	.L76:
 349:le_phy.c      **** 					uint8_t tmp = (uint8_t)DIO_SSP_DR;
 1055              		.loc 1 349 0
 1056 0134 1368     		ldr	r3, [r2]
 1057 0136 5807     		lsls	r0, r3, #29
 1058 0138 26D4     		bmi	.L77
 354:le_phy.c      **** 
 1059              		.loc 1 354 0
 1060 013a D4F87816 		ldr	r1, [r4, #1656]
 1061 013e 2948     		ldr	r0, .L89+60
 1062 0140 FFF7FEFF 		bl	queue_insert
 1063              	.LVL90:
 357:le_phy.c      **** 					++conn_event.num_packets;
 1064              		.loc 1 357 0
 1065 0144 1F4B     		ldr	r3, .L89+28
ARM GAS  /tmp/ccnRyoKo.s 			page 38


 1066 0146 1888     		ldrh	r0, [r3]
 1067 0148 80B2     		uxth	r0, r0
 1068 014a FFF7FEFF 		bl	btle_channel_index
 1069              	.LVL91:
 1070 014e 2428     		cmp	r0, #36
 1071 0150 0FD8     		bhi	.L80
 358:le_phy.c      **** 
 1072              		.loc 1 358 0
 1073 0152 254A     		ldr	r2, .L89+64
 1074 0154 5368     		ldr	r3, [r2, #4]
 1075 0156 0133     		adds	r3, r3, #1
 361:le_phy.c      **** 						conn_event.anchor = current_rxbuf->timestamp;
 1076              		.loc 1 361 0
 1077 0158 012B     		cmp	r3, #1
 358:le_phy.c      **** 
 1078              		.loc 1 358 0
 1079 015a 5360     		str	r3, [r2, #4]
 361:le_phy.c      **** 						conn_event.anchor = current_rxbuf->timestamp;
 1080              		.loc 1 361 0
 1081 015c 16D1     		bne	.L79
 362:le_phy.c      **** 						timer1_set_match(NOW + IFS_TIMEOUT); // set a timeout for next packet
 1082              		.loc 1 362 0
 1083 015e D4F87836 		ldr	r3, [r4, #1656]
 1084 0162 D3F80C31 		ldr	r3, [r3, #268]
 1085 0166 1360     		str	r3, [r2]
 363:le_phy.c      **** 					}
 1086              		.loc 1 363 0
 1087 0168 2868     		ldr	r0, [r5]
 1088 016a 00F6B830 		addw	r0, r0, #3000
 1089 016e FFF7FEFF 		bl	timer1_set_match
 1090              	.LVL92:
 1091              	.L80:
 377:le_phy.c      **** 
 1092              		.loc 1 377 0
 1093 0172 FFF7FEFF 		bl	buffer_get
 1094              	.LVL93:
 1095 0176 C4F87806 		str	r0, [r4, #1656]
 380:le_phy.c      **** 				dio_ssp_start();
 1096              		.loc 1 380 0
 1097 017a FFF7FEFF 		bl	le_dma_init
 1098              	.LVL94:
 381:le_phy.c      **** 
 1099              		.loc 1 381 0
 1100 017e FFF7FEFF 		bl	dio_ssp_start
 1101              	.LVL95:
 384:le_phy.c      **** 			}
 1102              		.loc 1 384 0
 1103 0182 FFF7FEFF 		bl	timer1_wait_fs_lock
 1104              	.LVL96:
 1105 0186 88E7     		b	.L75
 1106              	.L77:
 1107              	.LBB38:
 350:le_phy.c      **** 				}
 1108              		.loc 1 350 0
 1109 0188 0B68     		ldr	r3, [r1]
 1110 018a D3E7     		b	.L76
 1111              	.L79:
ARM GAS  /tmp/ccnRyoKo.s 			page 39


 1112              	.LBE38:
 367:le_phy.c      **** 						cc2400_strobe(SRFOFF);
 1113              		.loc 1 367 0
 1114 018c 022B     		cmp	r3, #2
 1115 018e F0D1     		bne	.L80
 368:le_phy.c      **** 						current_rxbuf = buffer_get();
 1116              		.loc 1 368 0
 1117 0190 6420     		movs	r0, #100
 1118 0192 FFF7FEFF 		bl	cc2400_strobe
 1119              	.LVL97:
 369:le_phy.c      **** 						finish_conn_event();
 1120              		.loc 1 369 0
 1121 0196 FFF7FEFF 		bl	buffer_get
 1122              	.LVL98:
 1123 019a C4F87806 		str	r0, [r4, #1656]
 394:le_phy.c      **** 
 1124              		.loc 1 394 0
 1125 019e BDE8F840 		pop	{r3, r4, r5, r6, r7, lr}
 1126              		.cfi_restore 14
 1127              		.cfi_restore 7
 1128              		.cfi_restore 6
 1129              		.cfi_restore 5
 1130              		.cfi_restore 4
 1131              		.cfi_restore 3
 1132              		.cfi_def_cfa_offset 0
 1133              	.LVL99:
 370:le_phy.c      **** 						return;
 1134              		.loc 1 370 0
 1135 01a2 FFF7FEBF 		b	finish_conn_event
 1136              	.LVL100:
 1137              	.L90:
 1138 01a6 00BF     		.align	2
 1139              	.L89:
 1140 01a8 00000000 		.word	.LC0
 1141 01ac 08800040 		.word	1073774600
 1142 01b0 00400050 		.word	1342193664
 1143 01b4 04400050 		.word	1342193668
 1144 01b8 08400050 		.word	1342193672
 1145 01bc 00000000 		.word	.LANCHOR0
 1146 01c0 00000000 		.word	le_dma_dest
 1147 01c4 00000000 		.word	rf_channel
 1148 01c8 14800040 		.word	1073774612
 1149 01cc 0C400050 		.word	1342193676
 1150 01d0 10400050 		.word	1342193680
 1151 01d4 00000000 		.word	.LANCHOR1
 1152 01d8 10410050 		.word	1342193936
 1153 01dc 08000340 		.word	1073938440
 1154 01e0 24000340 		.word	1073938468
 1155 01e4 00000000 		.word	packet_queue
 1156 01e8 00000000 		.word	conn_event
 1157              		.cfi_endproc
 1158              	.LFE7:
 1160              		.section	.text.TIMER1_IRQHandler,"ax",%progbits
 1161              		.align	1
 1162              		.global	TIMER1_IRQHandler
 1163              		.syntax unified
 1164              		.thumb
ARM GAS  /tmp/ccnRyoKo.s 			page 40


 1165              		.thumb_func
 1166              		.fpu softvfp
 1168              	TIMER1_IRQHandler:
 1169              	.LFB19:
 566:le_phy.c      **** 	// MR0: connection events
 1170              		.loc 1 566 0
 1171              		.cfi_startproc
 1172              		@ args = 0, pretend = 0, frame = 0
 1173              		@ frame_needed = 0, uses_anonymous_args = 0
 1174 0000 38B5     		push	{r3, r4, r5, lr}
 1175              		.cfi_def_cfa_offset 16
 1176              		.cfi_offset 3, -16
 1177              		.cfi_offset 4, -12
 1178              		.cfi_offset 5, -8
 1179              		.cfi_offset 14, -4
 568:le_phy.c      **** 		// ack the interrupt
 1180              		.loc 1 568 0
 1181 0002 494B     		ldr	r3, .L118
 1182 0004 1A68     		ldr	r2, [r3]
 1183 0006 D007     		lsls	r0, r2, #31
 1184 0008 5AD5     		bpl	.L92
 570:le_phy.c      **** 
 1185              		.loc 1 570 0
 1186 000a 0121     		movs	r1, #1
 1187 000c 1960     		str	r1, [r3]
 573:le_phy.c      **** 				conn.conn_event_counter == conn.conn_update_instant) {
 1188              		.loc 1 573 0
 1189 000e 474B     		ldr	r3, .L118+4
 1190 0010 474D     		ldr	r5, .L118+8
 1191 0012 D3F81021 		ldr	r2, [r3, #272]
 1192 0016 1C46     		mov	r4, r3
 1193 0018 92B3     		cbz	r2, .L93
 573:le_phy.c      **** 				conn.conn_event_counter == conn.conn_update_instant) {
 1194              		.loc 1 573 0 is_stmt 0 discriminator 1
 1195 001a B3F80C01 		ldrh	r0, [r3, #268]
 1196 001e B3F81C21 		ldrh	r2, [r3, #284]
 1197 0022 9042     		cmp	r0, r2
 1198 0024 2CD1     		bne	.L93
 578:le_phy.c      **** 				timer1_set_match(conn.last_anchor + conn.conn_interval +
 1199              		.loc 1 578 0 is_stmt 1
 1200 0026 AA68     		ldr	r2, [r5, #8]
 1201 0028 62B9     		cbnz	r2, .L94
 578:le_phy.c      **** 				timer1_set_match(conn.last_anchor + conn.conn_interval +
 1202              		.loc 1 578 0 is_stmt 0 discriminator 1
 1203 002a D86B     		ldr	r0, [r3, #60]
 1204 002c 50B1     		cbz	r0, .L94
 579:le_phy.c      **** 						conn.win_offset - RX_WARMUP_TIME);
 1205              		.loc 1 579 0 is_stmt 1
 1206 002e D3F80021 		ldr	r2, [r3, #256]
 1207 0032 1B6B     		ldr	r3, [r3, #48]
 1208 0034 1044     		add	r0, r0, r2
 1209 0036 A0F6B830 		subw	r0, r0, #3000
 1210 003a 1844     		add	r0, r0, r3
 1211 003c FFF7FEFF 		bl	timer1_set_match
 1212              	.LVL101:
 581:le_phy.c      **** 			}
 1213              		.loc 1 581 0
ARM GAS  /tmp/ccnRyoKo.s 			page 41


 1214 0040 A960     		str	r1, [r5, #8]
 1215 0042 38BD     		pop	{r3, r4, r5, pc}
 1216              	.L94:
 588:le_phy.c      **** 
 1217              		.loc 1 588 0
 1218 0044 0123     		movs	r3, #1
 1219 0046 AB60     		str	r3, [r5, #8]
 592:le_phy.c      **** 				conn.conn_interval = conn.conn_update_pending_interval;
 1220              		.loc 1 592 0
 1221 0048 0023     		movs	r3, #0
 593:le_phy.c      **** 				conn.supervision_timeout = conn.conn_update_pending_supervision_timeout;
 1222              		.loc 1 593 0
 1223 004a D4F81401 		ldr	r0, [r4, #276]
 592:le_phy.c      **** 				conn.conn_interval = conn.conn_update_pending_interval;
 1224              		.loc 1 592 0
 1225 004e C4F80431 		str	r3, [r4, #260]
 595:le_phy.c      **** 
 1226              		.loc 1 595 0
 1227 0052 C4F81031 		str	r3, [r4, #272]
 598:le_phy.c      **** 						conn.win_offset + conn.win_size + USEC(2120));
 1228              		.loc 1 598 0
 1229 0056 D4F80031 		ldr	r3, [r4, #256]
 593:le_phy.c      **** 				conn.supervision_timeout = conn.conn_update_pending_supervision_timeout;
 1230              		.loc 1 593 0
 1231 005a 2063     		str	r0, [r4, #48]
 598:le_phy.c      **** 						conn.win_offset + conn.win_size + USEC(2120));
 1232              		.loc 1 598 0
 1233 005c 1844     		add	r0, r0, r3
 1234 005e 00F5A540 		add	r0, r0, #21120
 1235 0062 E36B     		ldr	r3, [r4, #60]
 1236 0064 5030     		adds	r0, r0, #80
 1237 0066 1844     		add	r0, r0, r3
 599:le_phy.c      **** 				change_channel();
 1238              		.loc 1 599 0
 1239 0068 94F83830 		ldrb	r3, [r4, #56]	@ zero_extendqisi2
 594:le_phy.c      **** 				conn.conn_update_pending = 0;
 1240              		.loc 1 594 0
 1241 006c D4F81821 		ldr	r2, [r4, #280]
 598:le_phy.c      **** 						conn.win_offset + conn.win_size + USEC(2120));
 1242              		.loc 1 598 0
 1243 0070 1844     		add	r0, r0, r3
 594:le_phy.c      **** 				conn.conn_update_pending = 0;
 1244              		.loc 1 594 0
 1245 0072 6263     		str	r2, [r4, #52]
 598:le_phy.c      **** 						conn.win_offset + conn.win_size + USEC(2120));
 1246              		.loc 1 598 0
 1247 0074 FFF7FEFF 		bl	timer1_set_match
 1248              	.LVL102:
 667:le_phy.c      **** 
 1249              		.loc 1 667 0
 1250 0078 BDE83840 		pop	{r3, r4, r5, lr}
 1251              		.cfi_remember_state
 1252              		.cfi_restore 14
 1253              		.cfi_restore 5
 1254              		.cfi_restore 4
 1255              		.cfi_restore 3
 1256              		.cfi_def_cfa_offset 0
ARM GAS  /tmp/ccnRyoKo.s 			page 42


 600:le_phy.c      **** 			}
 1257              		.loc 1 600 0
 1258 007c FFF7FEBF 		b	change_channel
 1259              	.LVL103:
 1260              	.L93:
 1261              		.cfi_restore_state
 606:le_phy.c      **** 				conn.conn_event_counter == conn.channel_map_update_instant) {
 1262              		.loc 1 606 0
 1263 0080 D4F82031 		ldr	r3, [r4, #288]
 1264 0084 73B1     		cbz	r3, .L96
 606:le_phy.c      **** 				conn.conn_event_counter == conn.channel_map_update_instant) {
 1265              		.loc 1 606 0 is_stmt 0 discriminator 1
 1266 0086 B4F80C21 		ldrh	r2, [r4, #268]
 1267 008a B4F82431 		ldrh	r3, [r4, #292]
 1268 008e 9A42     		cmp	r2, r3
 1269 0090 08D1     		bne	.L96
 608:le_phy.c      **** 			conn.channel_map_update_pending = 0;
 1270              		.loc 1 608 0 is_stmt 1
 1271 0092 2849     		ldr	r1, .L118+12
 1272 0094 C022     		movs	r2, #192
 1273 0096 A1F1E800 		sub	r0, r1, #232
 1274 009a FFF7FEFF 		bl	memcpy
 1275              	.LVL104:
 609:le_phy.c      **** 		}
 1276              		.loc 1 609 0
 1277 009e 0023     		movs	r3, #0
 1278 00a0 C4F82031 		str	r3, [r4, #288]
 1279              	.L96:
 613:le_phy.c      **** 			conn_event.opened = 1;
 1280              		.loc 1 613 0
 1281 00a4 AB68     		ldr	r3, [r5, #8]
 1282 00a6 002B     		cmp	r3, #0
 1283 00a8 35D1     		bne	.L97
 614:le_phy.c      **** 			// timeout is max packet length + warmup time (slack)
 1284              		.loc 1 614 0
 1285 00aa 0123     		movs	r3, #1
 1286 00ac AB60     		str	r3, [r5, #8]
 616:le_phy.c      **** 			change_channel();
 1287              		.loc 1 616 0
 1288 00ae 224B     		ldr	r3, .L118+16
 1289 00b0 1868     		ldr	r0, [r3]
 1290 00b2 00F5BD40 		add	r0, r0, #24192
 1291 00b6 0830     		adds	r0, r0, #8
 1292 00b8 FFF7FEFF 		bl	timer1_set_match
 1293              	.LVL105:
 617:le_phy.c      **** 		}
 1294              		.loc 1 617 0
 1295 00bc FFF7FEFF 		bl	change_channel
 1296              	.LVL106:
 1297              	.L92:
 643:le_phy.c      **** 		T1IR = TIR_MR1_Interrupt;
 1298              		.loc 1 643 0
 1299 00c0 194B     		ldr	r3, .L118
 1300 00c2 1A68     		ldr	r2, [r3]
 1301 00c4 9107     		lsls	r1, r2, #30
 1302 00c6 0DD5     		bpl	.L98
 644:le_phy.c      **** 		T1MCR &= ~TMCR_MR1I;
ARM GAS  /tmp/ccnRyoKo.s 			page 43


 1303              		.loc 1 644 0
 1304 00c8 0222     		movs	r2, #2
 645:le_phy.c      **** 
 1305              		.loc 1 645 0
 1306 00ca 1C49     		ldr	r1, .L118+20
 644:le_phy.c      **** 		T1MCR &= ~TMCR_MR1I;
 1307              		.loc 1 644 0
 1308 00cc 1A60     		str	r2, [r3]
 645:le_phy.c      **** 
 1309              		.loc 1 645 0
 1310 00ce 0B68     		ldr	r3, [r1]
 1311 00d0 23F00803 		bic	r3, r3, #8
 1312 00d4 0B60     		str	r3, [r1]
 647:le_phy.c      **** 		RXLED_CLR;
 1313              		.loc 1 647 0
 1314 00d6 4FF48071 		mov	r1, #256
 1315 00da 194B     		ldr	r3, .L118+24
 1316 00dc 1960     		str	r1, [r3]
 648:le_phy.c      **** 		USRLED_CLR;
 1317              		.loc 1 648 0
 1318 00de 1021     		movs	r1, #16
 1319 00e0 1960     		str	r1, [r3]
 649:le_phy.c      **** 	}
 1320              		.loc 1 649 0
 1321 00e2 1A60     		str	r2, [r3]
 1322              	.L98:
 653:le_phy.c      **** 		T1IR = TIR_MR2_Interrupt;
 1323              		.loc 1 653 0
 1324 00e4 104B     		ldr	r3, .L118
 1325 00e6 1A68     		ldr	r2, [r3]
 1326 00e8 5207     		lsls	r2, r2, #29
 1327 00ea 1BD5     		bpl	.L91
 654:le_phy.c      **** 
 1328              		.loc 1 654 0
 1329 00ec 0422     		movs	r2, #4
 1330 00ee 1A60     		str	r2, [r3]
 657:le_phy.c      **** 			le_cc2400_strobe_rx();
 1331              		.loc 1 657 0
 1332 00f0 FFF7FEFF 		bl	cc2400_status
 1333              	.LVL107:
 1334 00f4 4307     		lsls	r3, r0, #29
 1335 00f6 11D5     		bpl	.L99
 1336              	.LBB41:
 1337              	.LBB42:
 489:le_phy.c      **** #ifdef UBERTOOTH_ONE
 1338              		.loc 1 489 0
 1339 00f8 6220     		movs	r0, #98
 1340 00fa FFF7FEFF 		bl	cc2400_strobe
 1341              	.LVL108:
 491:le_phy.c      **** 	HGM_SET;
 1342              		.loc 1 491 0
 1343 00fe 8022     		movs	r2, #128
 1344 0100 104B     		ldr	r3, .L118+28
 1345 0102 1A60     		str	r2, [r3]
 492:le_phy.c      **** #endif
 1346              		.loc 1 492 0
 1347 0104 4FF48072 		mov	r2, #256
ARM GAS  /tmp/ccnRyoKo.s 			page 44


 1348 0108 1A60     		str	r2, [r3]
 1349              	.LBE42:
 1350              	.LBE41:
 659:le_phy.c      **** 		}
 1351              		.loc 1 659 0
 1352 010a 0C4A     		ldr	r2, .L118+20
 1353 010c 1368     		ldr	r3, [r2]
 1354 010e 23F04003 		bic	r3, r3, #64
 1355 0112 1360     		str	r3, [r2]
 1356 0114 38BD     		pop	{r3, r4, r5, pc}
 1357              	.L97:
 637:le_phy.c      **** 			}
 1358              		.loc 1 637 0
 1359 0116 FFF7FEFF 		bl	finish_conn_event
 1360              	.LVL109:
 1361 011a D1E7     		b	.L92
 1362              	.L99:
 667:le_phy.c      **** 
 1363              		.loc 1 667 0
 1364 011c BDE83840 		pop	{r3, r4, r5, lr}
 1365              		.cfi_remember_state
 1366              		.cfi_restore 14
 1367              		.cfi_restore 5
 1368              		.cfi_restore 4
 1369              		.cfi_restore 3
 1370              		.cfi_def_cfa_offset 0
 664:le_phy.c      **** 		}
 1371              		.loc 1 664 0
 1372 0120 FFF7FEBF 		b	timer1_wait_fs_lock
 1373              	.LVL110:
 1374              	.L91:
 1375              		.cfi_restore_state
 1376 0124 38BD     		pop	{r3, r4, r5, pc}
 1377              	.L119:
 1378 0126 00BF     		.align	2
 1379              	.L118:
 1380 0128 00800040 		.word	1073774592
 1381 012c 00000000 		.word	.LANCHOR0
 1382 0130 00000000 		.word	conn_event
 1383 0134 28010000 		.word	.LANCHOR0+296
 1384 0138 08800040 		.word	1073774600
 1385 013c 14800040 		.word	1073774612
 1386 0140 3CC00920 		.word	537509948
 1387 0144 58C00920 		.word	537509976
 1388              		.cfi_endproc
 1389              	.LFE19:
 1391              		.section	.text.le_phy_main,"ax",%progbits
 1392              		.align	1
 1393              		.global	le_phy_main
 1394              		.syntax unified
 1395              		.thumb
 1396              		.thumb_func
 1397              		.fpu softvfp
 1399              	le_phy_main:
 1400              	.LFB30:
 874:le_phy.c      **** 
 875:le_phy.c      **** static int filter_match(le_rx_t *buf) {
ARM GAS  /tmp/ccnRyoKo.s 			page 45


 876:le_phy.c      **** 	if (!le.target_set)
 877:le_phy.c      **** 		return 1;
 878:le_phy.c      **** 
 879:le_phy.c      **** 	// allow all data channel packets
 880:le_phy.c      **** 	if (btle_channel_index(buf->channel) < 37)
 881:le_phy.c      **** 		return 1;
 882:le_phy.c      **** 
 883:le_phy.c      **** 	switch (buf->data[0] & 0xf) {
 884:le_phy.c      **** 		// ADV_IND, ADV_NONCONN_IND, ADV_SCAN_IND, SCAN_RSP
 885:le_phy.c      **** 		case 0x00:
 886:le_phy.c      **** 		case 0x02:
 887:le_phy.c      **** 		case 0x06:
 888:le_phy.c      **** 		case 0x04:
 889:le_phy.c      **** 			// header + one address
 890:le_phy.c      **** 			if (buf->size < 2 + 6)
 891:le_phy.c      **** 				return 0;
 892:le_phy.c      **** 			return bd_addr_cmp(&buf->data[2]);
 893:le_phy.c      **** 			break;
 894:le_phy.c      **** 
 895:le_phy.c      **** 		// ADV_DIRECT_IND, SCAN_REQ, CONNECT_REQ
 896:le_phy.c      **** 		case 0x01:
 897:le_phy.c      **** 		case 0x03:
 898:le_phy.c      **** 		case 0x05:
 899:le_phy.c      **** 			// header + two addresses
 900:le_phy.c      **** 			if (buf->size < 2 + 6 + 6)
 901:le_phy.c      **** 				return 0;
 902:le_phy.c      **** 			return bd_addr_cmp(&buf->data[2]) ||
 903:le_phy.c      **** 				   bd_addr_cmp(&buf->data[8]);
 904:le_phy.c      **** 			break;
 905:le_phy.c      **** 
 906:le_phy.c      **** 		default:
 907:le_phy.c      **** 			break;
 908:le_phy.c      **** 	}
 909:le_phy.c      **** 
 910:le_phy.c      **** 	return 0;
 911:le_phy.c      **** }
 912:le_phy.c      **** 
 913:le_phy.c      **** void le_phy_main(void) {
 1401              		.loc 1 913 0
 1402              		.cfi_startproc
 1403              		@ args = 0, pretend = 0, frame = 24
 1404              		@ frame_needed = 0, uses_anonymous_args = 0
 1405 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 1406              		.cfi_def_cfa_offset 36
 1407              		.cfi_offset 4, -36
 1408              		.cfi_offset 5, -32
 1409              		.cfi_offset 6, -28
 1410              		.cfi_offset 7, -24
 1411              		.cfi_offset 8, -20
 1412              		.cfi_offset 9, -16
 1413              		.cfi_offset 10, -12
 1414              		.cfi_offset 11, -8
 1415              		.cfi_offset 14, -4
 1416 0004 87B0     		sub	sp, sp, #28
 1417              		.cfi_def_cfa_offset 64
 914:le_phy.c      **** 	// disable USB interrupts -- we poll them below
 915:le_phy.c      **** 	// n.b., they should not be enabled but let's be careful
ARM GAS  /tmp/ccnRyoKo.s 			page 46


 916:le_phy.c      **** 	ICER0 = ICER0_ICE_USB;
 1418              		.loc 1 916 0
 1419 0006 4FF08073 		mov	r3, #16777216
 1420              	.LBB72:
 1421              	.LBB73:
 166:le_phy.c      **** }
 1422              		.loc 1 166 0
 1423 000a 0125     		movs	r5, #1
 1424              	.LBE73:
 1425              	.LBE72:
 1426              		.loc 1 916 0
 1427 000c DFF85083 		ldr	r8, .L160+76
 1428              	.LBB76:
 1429              	.LBB74:
 166:le_phy.c      **** }
 1430              		.loc 1 166 0
 1431 0010 C04C     		ldr	r4, .L160
 1432              	.LBE74:
 1433              	.LBE76:
 1434              		.loc 1 916 0
 1435 0012 C8F80030 		str	r3, [r8]
 917:le_phy.c      **** 	// disable clkn and timer0
 918:le_phy.c      **** 	clkn_disable();
 1436              		.loc 1 918 0
 1437 0016 FFF7FEFF 		bl	clkn_disable
 1438              	.LVL111:
 919:le_phy.c      **** 
 920:le_phy.c      **** 	buffers_init();
 921:le_phy.c      **** 	queue_init(&packet_queue);
 1439              		.loc 1 921 0
 1440 001a BF48     		ldr	r0, .L160+4
 1441              	.LBB77:
 1442              	.LBB75:
 166:le_phy.c      **** }
 1443              		.loc 1 166 0
 1444 001c C4F80053 		str	r5, [r4, #768]
 1445              	.LVL112:
 1446 0020 C4F82454 		str	r5, [r4, #1060]
 1447              	.LVL113:
 1448 0024 C4F84855 		str	r5, [r4, #1352]
 1449              	.LVL114:
 1450 0028 C4F86C56 		str	r5, [r4, #1644]
 1451              	.LVL115:
 1452              	.LBE75:
 1453              	.LBE77:
 1454              		.loc 1 921 0
 1455 002c FFF7FEFF 		bl	queue_init
 1456              	.LVL116:
 1457              	.LBB78:
 1458              	.LBB79:
 533:le_phy.c      **** 	T1PR = 4; // 100 ns
 1459              		.loc 1 533 0
 1460 0030 0223     		movs	r3, #2
 1461 0032 BA4E     		ldr	r6, .L160+8
 534:le_phy.c      **** 	T1TCR = TCR_Counter_Enable;
 1462              		.loc 1 534 0
 1463 0034 BA4A     		ldr	r2, .L160+12
ARM GAS  /tmp/ccnRyoKo.s 			page 47


 533:le_phy.c      **** 	T1PR = 4; // 100 ns
 1464              		.loc 1 533 0
 1465 0036 3360     		str	r3, [r6]
 534:le_phy.c      **** 	T1TCR = TCR_Counter_Enable;
 1466              		.loc 1 534 0
 1467 0038 0423     		movs	r3, #4
 1468 003a 1360     		str	r3, [r2]
 538:le_phy.c      **** }
 1469              		.loc 1 538 0
 1470 003c B94A     		ldr	r2, .L160+16
 535:le_phy.c      **** 
 1471              		.loc 1 535 0
 1472 003e 3560     		str	r5, [r6]
 538:le_phy.c      **** }
 1473              		.loc 1 538 0
 1474 0040 1360     		str	r3, [r2]
 1475              	.LBE79:
 1476              	.LBE78:
 922:le_phy.c      **** 	timer1_start();
 923:le_phy.c      **** 
 924:le_phy.c      **** 	current_rxbuf = buffer_get();
 1477              		.loc 1 924 0
 1478 0042 FFF7FEFF 		bl	buffer_get
 1479              	.LVL117:
 925:le_phy.c      **** 	rf_channel = le_adv_channel; // FIXME
 1480              		.loc 1 925 0
 1481 0046 B84B     		ldr	r3, .L160+20
 1482 0048 B84A     		ldr	r2, .L160+24
 1483 004a 1B88     		ldrh	r3, [r3]
 924:le_phy.c      **** 	rf_channel = le_adv_channel; // FIXME
 1484              		.loc 1 924 0
 1485 004c C4F87806 		str	r0, [r4, #1656]
 1486              		.loc 1 925 0
 1487 0050 9BB2     		uxth	r3, r3
 1488 0052 1380     		strh	r3, [r2]	@ movhi
 926:le_phy.c      **** 	conn.access_address = ADVERTISING_AA;
 1489              		.loc 1 926 0
 1490 0054 B64B     		ldr	r3, .L160+28
 927:le_phy.c      **** 	le_sys_init();
 928:le_phy.c      **** 	le_cc2400_init_rf();
 929:le_phy.c      **** 
 930:le_phy.c      **** 	cancel_follow = 0;
 1491              		.loc 1 930 0
 1492 0056 B74F     		ldr	r7, .L160+32
 926:le_phy.c      **** 	conn.access_address = ADVERTISING_AA;
 1493              		.loc 1 926 0
 1494 0058 2362     		str	r3, [r4, #32]
 1495              	.LBB80:
 1496              	.LBB81:
 434:le_phy.c      **** 	dio_ssp_init();   // init SSP and raise !CS (self-routed GPIO)
 1497              		.loc 1 434 0
 1498 005a FFF7FEFF 		bl	usb_queue_init
 1499              	.LVL118:
 435:le_phy.c      **** 	le_dma_init();    // prepare DMA + interrupts
 1500              		.loc 1 435 0
 1501 005e FFF7FEFF 		bl	dio_ssp_init
 1502              	.LVL119:
ARM GAS  /tmp/ccnRyoKo.s 			page 48


 436:le_phy.c      **** 	dio_ssp_start();  // enable SSP + DMA
 1503              		.loc 1 436 0
 1504 0062 FFF7FEFF 		bl	le_dma_init
 1505              	.LVL120:
 437:le_phy.c      **** }
 1506              		.loc 1 437 0
 1507 0066 FFF7FEFF 		bl	dio_ssp_start
 1508              	.LVL121:
 1509              	.LBE81:
 1510              	.LBE80:
 928:le_phy.c      **** 
 1511              		.loc 1 928 0
 1512 006a FFF7FEFF 		bl	le_cc2400_init_rf
 1513              	.LVL122:
 1514              		.loc 1 930 0
 1515 006e 0020     		movs	r0, #0
 1516              	.LBB82:
 1517              	.LBB83:
 1518              	.LBB84:
 679:le_phy.c      **** }
 1519              		.loc 1 679 0
 1520 0070 DFF8F092 		ldr	r9, .L160+80
 1521              	.LBE84:
 1522              	.LBE83:
 1523              	.LBE82:
 1524              		.loc 1 930 0
 1525 0074 3860     		str	r0, [r7]
 931:le_phy.c      **** 	debug_uart_init(0);
 1526              		.loc 1 931 0
 1527 0076 FFF7FEFF 		bl	debug_uart_init
 1528              	.LVL123:
 1529 007a CDF80480 		str	r8, [sp, #4]
 1530 007e 0296     		str	r6, [sp, #8]
 1531              	.L121:
 932:le_phy.c      **** 	while (requested_mode == MODE_BT_FOLLOW_LE) {
 1532              		.loc 1 932 0
 1533 0080 AD4B     		ldr	r3, .L160+36
 1534 0082 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1535 0084 092B     		cmp	r3, #9
 1536 0086 11D0     		beq	.L138
 1537              	.LBB123:
 1538              	.LBB124:
 542:le_phy.c      **** 
 1539              		.loc 1 542 0
 1540 0088 0222     		movs	r2, #2
 1541 008a 029B     		ldr	r3, [sp, #8]
 545:le_phy.c      **** }
 1542              		.loc 1 545 0
 1543 008c 0199     		ldr	r1, [sp, #4]
 542:le_phy.c      **** 
 1544              		.loc 1 542 0
 1545 008e 1A60     		str	r2, [r3]
 545:le_phy.c      **** }
 1546              		.loc 1 545 0
 1547 0090 0423     		movs	r3, #4
 1548 0092 0B60     		str	r3, [r1]
 1549              	.LBE124:
ARM GAS  /tmp/ccnRyoKo.s 			page 49


 1550              	.LBE123:
 933:le_phy.c      **** 		le_rx_t *packet = NULL;
 934:le_phy.c      **** 		if (queue_remove(&packet_queue, (void **)&packet)) {
 935:le_phy.c      **** 			le_dewhiten(packet->data, packet->size, packet->channel);
 936:le_phy.c      **** 
 937:le_phy.c      **** 			if (filter_match(packet)) {
 938:le_phy.c      **** 				blink(0, 1, 0); // RX LED
 939:le_phy.c      **** 				usb_enqueue_le(packet);
 940:le_phy.c      **** 				packet_handler(packet);
 941:le_phy.c      **** 			}
 942:le_phy.c      **** 
 943:le_phy.c      **** 			buffer_release(packet);
 944:le_phy.c      **** 		}
 945:le_phy.c      **** 
 946:le_phy.c      **** 		// polled USB handling
 947:le_phy.c      **** 		handle_usb(0);
 948:le_phy.c      **** 
 949:le_phy.c      **** 		// XXX maybe LED light show?
 950:le_phy.c      **** 	}
 951:le_phy.c      **** 
 952:le_phy.c      **** 	timer1_stop();
 953:le_phy.c      **** 
 954:le_phy.c      **** 	// reset state
 955:le_phy.c      **** 	RXLED_CLR;
 1551              		.loc 1 955 0
 1552 0094 1021     		movs	r1, #16
 1553 0096 A94B     		ldr	r3, .L160+40
 1554 0098 1960     		str	r1, [r3]
 956:le_phy.c      **** 	TXLED_CLR;
 1555              		.loc 1 956 0
 1556 009a 4FF48071 		mov	r1, #256
 1557 009e 1960     		str	r1, [r3]
 957:le_phy.c      **** 	USRLED_CLR;
 1558              		.loc 1 957 0
 1559 00a0 1A60     		str	r2, [r3]
 958:le_phy.c      **** 	clkn_init();
 1560              		.loc 1 958 0
 1561 00a2 FFF7FEFF 		bl	clkn_init
 1562              	.LVL124:
 959:le_phy.c      **** 
 960:le_phy.c      **** 	// TODO kill CC2400
 961:le_phy.c      **** }
 1563              		.loc 1 961 0
 1564 00a6 07B0     		add	sp, sp, #28
 1565              		.cfi_remember_state
 1566              		.cfi_def_cfa_offset 36
 1567              		@ sp needed
 1568 00a8 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1569              	.L138:
 1570              		.cfi_restore_state
 1571              	.LBB125:
 933:le_phy.c      **** 		if (queue_remove(&packet_queue, (void **)&packet)) {
 1572              		.loc 1 933 0
 1573 00ac 0023     		movs	r3, #0
 1574 00ae 06A9     		add	r1, sp, #24
 1575 00b0 41F8043D 		str	r3, [r1, #-4]!
 934:le_phy.c      **** 			le_dewhiten(packet->data, packet->size, packet->channel);
ARM GAS  /tmp/ccnRyoKo.s 			page 50


 1576              		.loc 1 934 0
 1577 00b4 9848     		ldr	r0, .L160+4
 1578 00b6 FFF7FEFF 		bl	queue_remove
 1579              	.LVL125:
 1580 00ba 0028     		cmp	r0, #0
 1581 00bc 00F0DD80 		beq	.L122
 935:le_phy.c      **** 
 1582              		.loc 1 935 0
 1583 00c0 0598     		ldr	r0, [sp, #20]
 1584              	.LBB87:
 1585              	.LBB88:
 876:le_phy.c      **** 		return 1;
 1586              		.loc 1 876 0
 1587 00c2 9F4E     		ldr	r6, .L160+44
 1588              	.LBE88:
 1589              	.LBE87:
 935:le_phy.c      **** 
 1590              		.loc 1 935 0
 1591 00c4 D0F81021 		ldr	r2, [r0, #272]
 1592 00c8 D0F80411 		ldr	r1, [r0, #260]
 1593 00cc FFF7FEFF 		bl	le_dewhiten
 1594              	.LVL126:
 1595              	.LBB92:
 1596              	.LBB89:
 876:le_phy.c      **** 		return 1;
 1597              		.loc 1 876 0
 1598 00d0 736C     		ldr	r3, [r6, #68]
 1599 00d2 002B     		cmp	r3, #0
 1600 00d4 40F0B880 		bne	.L123
 1601              	.LVL127:
 1602              	.L126:
 1603              	.LBE89:
 1604              	.LBE92:
 1605              	.LBB93:
 1606              	.LBB85:
 673:le_phy.c      **** 	if (usr)
 1607              		.loc 1 673 0
 1608 00d8 1023     		movs	r3, #16
 1609 00da 9A4A     		ldr	r2, .L160+48
 1610              	.LBE85:
 1611              	.LBE93:
 939:le_phy.c      **** 				packet_handler(packet);
 1612              		.loc 1 939 0
 1613 00dc DDF81480 		ldr	r8, [sp, #20]
 1614              	.LBB94:
 1615              	.LBB86:
 673:le_phy.c      **** 	if (usr)
 1616              		.loc 1 673 0
 1617 00e0 1360     		str	r3, [r2]
 678:le_phy.c      **** 	T1MCR |= TMCR_MR1I;
 1618              		.loc 1 678 0
 1619 00e2 994B     		ldr	r3, .L160+52
 1620 00e4 994A     		ldr	r2, .L160+56
 1621 00e6 1B68     		ldr	r3, [r3]
 1622 00e8 03F5C333 		add	r3, r3, #99840
 1623 00ec A033     		adds	r3, r3, #160
 1624 00ee 1360     		str	r3, [r2]
ARM GAS  /tmp/ccnRyoKo.s 			page 51


 679:le_phy.c      **** }
 1625              		.loc 1 679 0
 1626 00f0 D9F80030 		ldr	r3, [r9]
 1627 00f4 43F00803 		orr	r3, r3, #8
 1628 00f8 C9F80030 		str	r3, [r9]
 1629              	.LVL128:
 1630              	.LBE86:
 1631              	.LBE94:
 1632              	.LBB95:
 1633              	.LBB96:
 706:le_phy.c      **** 
 1634              		.loc 1 706 0
 1635 00fc FFF7FEFF 		bl	usb_enqueue
 1636              	.LVL129:
 709:le_phy.c      **** 		return 0;
 1637              		.loc 1 709 0
 1638 0100 0546     		mov	r5, r0
 1639 0102 0028     		cmp	r0, #0
 1640 0104 40F0D480 		bne	.L157
 1641              	.LVL130:
 1642              	.L124:
 1643              	.LBE96:
 1644              	.LBE95:
 940:le_phy.c      **** 			}
 1645              		.loc 1 940 0
 1646 0108 059D     		ldr	r5, [sp, #20]
 1647              	.LVL131:
 1648              	.LBB98:
 1649              	.LBB99:
 835:le_phy.c      **** 		switch (buf->data[0] & 0xf) {
 1650              		.loc 1 835 0
 1651 010a B5F81001 		ldrh	r0, [r5, #272]
 1652 010e FFF7FEFF 		bl	btle_channel_index
 1653              	.LVL132:
 1654 0112 2428     		cmp	r0, #36
 1655 0114 2978     		ldrb	r1, [r5]	@ zero_extendqisi2
 1656 0116 40F22781 		bls	.L132
 836:le_phy.c      **** 			// CONNECT_REQ
 1657              		.loc 1 836 0
 1658 011a 01F00F01 		and	r1, r1, #15
 1659 011e 0529     		cmp	r1, #5
 1660 0120 40F0A780 		bne	.L128
 1661              	.LVL133:
 1662              	.LBB100:
 1663              	.LBB101:
 746:le_phy.c      **** 		return;
 1664              		.loc 1 746 0
 1665 0124 736B     		ldr	r3, [r6, #52]
 1666 0126 002B     		cmp	r3, #0
 1667 0128 00F0A380 		beq	.L128
 749:le_phy.c      **** 		return;
 1668              		.loc 1 749 0
 1669 012c D5F80431 		ldr	r3, [r5, #260]
 1670 0130 272B     		cmp	r3, #39
 1671 0132 40F09E80 		bne	.L128
 753:le_phy.c      **** 		cancel_follow = 0;
 1672              		.loc 1 753 0
ARM GAS  /tmp/ccnRyoKo.s 			page 52


 1673 0136 3B68     		ldr	r3, [r7]
 1674 0138 0BB1     		cbz	r3, .L134
 754:le_phy.c      **** 
 1675              		.loc 1 754 0
 1676 013a 0023     		movs	r3, #0
 1677 013c 3B60     		str	r3, [r7]
 1678              	.L134:
 756:le_phy.c      **** 	conn.crc_init           = extract_field(buf, 18, 3);
 1679              		.loc 1 756 0
 1680 013e 0422     		movs	r2, #4
 1681 0140 0E21     		movs	r1, #14
 1682 0142 2846     		mov	r0, r5
 1683 0144 FFF7FEFF 		bl	extract_field
 1684              	.LVL134:
 757:le_phy.c      **** 	conn.crc_init_reversed  = rbit(conn.crc_init);
 1685              		.loc 1 757 0
 1686 0148 0322     		movs	r2, #3
 1687 014a 1221     		movs	r1, #18
 756:le_phy.c      **** 	conn.crc_init           = extract_field(buf, 18, 3);
 1688              		.loc 1 756 0
 1689 014c 2062     		str	r0, [r4, #32]
 757:le_phy.c      **** 	conn.crc_init_reversed  = rbit(conn.crc_init);
 1690              		.loc 1 757 0
 1691 014e 2846     		mov	r0, r5
 1692 0150 FFF7FEFF 		bl	extract_field
 1693              	.LVL135:
 1694 0154 6062     		str	r0, [r4, #36]
 758:le_phy.c      **** 	conn.win_size           = extract_field(buf, 21, 1);
 1695              		.loc 1 758 0
 1696 0156 FFF7FEFF 		bl	rbit
 1697              	.LVL136:
 759:le_phy.c      **** 	conn.win_offset         = extract_field(buf, 22, 2);
 1698              		.loc 1 759 0
 1699 015a 0122     		movs	r2, #1
 758:le_phy.c      **** 	conn.win_size           = extract_field(buf, 21, 1);
 1700              		.loc 1 758 0
 1701 015c A062     		str	r0, [r4, #40]
 759:le_phy.c      **** 	conn.win_offset         = extract_field(buf, 22, 2);
 1702              		.loc 1 759 0
 1703 015e 1521     		movs	r1, #21
 1704 0160 2846     		mov	r0, r5
 1705 0162 FFF7FEFF 		bl	extract_field
 1706              	.LVL137:
 760:le_phy.c      **** 	conn.conn_interval      = extract_field(buf, 24, 2);
 1707              		.loc 1 760 0
 1708 0166 0222     		movs	r2, #2
 759:le_phy.c      **** 	conn.win_offset         = extract_field(buf, 22, 2);
 1709              		.loc 1 759 0
 1710 0168 84F83800 		strb	r0, [r4, #56]
 760:le_phy.c      **** 	conn.conn_interval      = extract_field(buf, 24, 2);
 1711              		.loc 1 760 0
 1712 016c 1621     		movs	r1, #22
 759:le_phy.c      **** 	conn.win_offset         = extract_field(buf, 22, 2);
 1713              		.loc 1 759 0
 1714 016e 8246     		mov	r10, r0
 760:le_phy.c      **** 	conn.conn_interval      = extract_field(buf, 24, 2);
 1715              		.loc 1 760 0
ARM GAS  /tmp/ccnRyoKo.s 			page 53


 1716 0170 2846     		mov	r0, r5
 1717 0172 FFF7FEFF 		bl	extract_field
 1718              	.LVL138:
 761:le_phy.c      **** 	conn.supervision_timeout = extract_field(buf, 28, 2);
 1719              		.loc 1 761 0
 1720 0176 0222     		movs	r2, #2
 760:le_phy.c      **** 	conn.conn_interval      = extract_field(buf, 24, 2);
 1721              		.loc 1 760 0
 1722 0178 E063     		str	r0, [r4, #60]
 761:le_phy.c      **** 	conn.supervision_timeout = extract_field(buf, 28, 2);
 1723              		.loc 1 761 0
 1724 017a 1821     		movs	r1, #24
 760:le_phy.c      **** 	conn.conn_interval      = extract_field(buf, 24, 2);
 1725              		.loc 1 760 0
 1726 017c 8046     		mov	r8, r0
 761:le_phy.c      **** 	conn.supervision_timeout = extract_field(buf, 28, 2);
 1727              		.loc 1 761 0
 1728 017e 2846     		mov	r0, r5
 1729 0180 FFF7FEFF 		bl	extract_field
 1730              	.LVL139:
 762:le_phy.c      **** 	conn.hop_increment      = extract_field(buf, 35, 1) & 0x1f;
 1731              		.loc 1 762 0
 1732 0184 0222     		movs	r2, #2
 761:le_phy.c      **** 	conn.supervision_timeout = extract_field(buf, 28, 2);
 1733              		.loc 1 761 0
 1734 0186 0646     		mov	r6, r0
 1735 0188 2063     		str	r0, [r4, #48]
 762:le_phy.c      **** 	conn.hop_increment      = extract_field(buf, 35, 1) & 0x1f;
 1736              		.loc 1 762 0
 1737 018a 1C21     		movs	r1, #28
 1738 018c 2846     		mov	r0, r5
 1739 018e FFF7FEFF 		bl	extract_field
 1740              	.LVL140:
 763:le_phy.c      **** 
 1741              		.loc 1 763 0
 1742 0192 0122     		movs	r2, #1
 762:le_phy.c      **** 	conn.hop_increment      = extract_field(buf, 35, 1) & 0x1f;
 1743              		.loc 1 762 0
 1744 0194 6063     		str	r0, [r4, #52]
 1745 0196 8346     		mov	fp, r0
 763:le_phy.c      **** 
 1746              		.loc 1 763 0
 1747 0198 2321     		movs	r1, #35
 1748 019a 2846     		mov	r0, r5
 1749 019c FFF7FEFF 		bl	extract_field
 1750              	.LVL141:
 765:le_phy.c      **** 		goto err_out;
 1751              		.loc 1 765 0
 1752 01a0 40F67A43 		movw	r3, #3194
 1753 01a4 B21F     		subs	r2, r6, #6
 763:le_phy.c      **** 
 1754              		.loc 1 763 0
 1755 01a6 00F01F00 		and	r0, r0, #31
 765:le_phy.c      **** 		goto err_out;
 1756              		.loc 1 765 0
 1757 01aa 9A42     		cmp	r2, r3
 763:le_phy.c      **** 
ARM GAS  /tmp/ccnRyoKo.s 			page 54


 1758              		.loc 1 763 0
 1759 01ac 84F82D00 		strb	r0, [r4, #45]
 765:le_phy.c      **** 		goto err_out;
 1760              		.loc 1 765 0
 1761 01b0 00F2AD80 		bhi	.L135
 768:le_phy.c      **** 	}
 1762              		.loc 1 768 0
 1763 01b4 43F2D403 		movw	r3, #12500
 1764 01b8 5E43     		muls	r6, r3, r6
 772:le_phy.c      **** 	if (conn.win_offset > conn.conn_interval)
 1765              		.loc 1 772 0
 1766 01ba 03FB08F2 		mul	r2, r3, r8
 773:le_phy.c      **** 		goto err_out;
 1767              		.loc 1 773 0
 1768 01be 9642     		cmp	r6, r2
 768:le_phy.c      **** 	}
 1769              		.loc 1 768 0
 1770 01c0 2663     		str	r6, [r4, #48]
 772:le_phy.c      **** 	if (conn.win_offset > conn.conn_interval)
 1771              		.loc 1 772 0
 1772 01c2 E263     		str	r2, [r4, #60]
 773:le_phy.c      **** 		goto err_out;
 1773              		.loc 1 773 0
 1774 01c4 C0F0A380 		bcc	.L135
 777:le_phy.c      **** 	max_win_size = conn.conn_interval - USEC(1250);
 1775              		.loc 1 777 0
 1776 01c8 5FFA8AFA 		uxtb	r10, r10
 1777 01cc 03FB0AFA 		mul	r10, r3, r10
 1778              	.LVL142:
 781:le_phy.c      **** 		goto err_out;
 1779              		.loc 1 781 0
 1780 01d0 43F2D303 		movw	r3, #12499
 1781 01d4 9A45     		cmp	r10, r3
 1782 01d6 40F39A80 		ble	.L135
 1783 01da 5D4B     		ldr	r3, .L160+60
 778:le_phy.c      **** 	if (max_win_size > MSEC(10))
 1784              		.loc 1 778 0
 1785 01dc A6F54356 		sub	r6, r6, #12480
 1786              	.LVL143:
 1787 01e0 143E     		subs	r6, r6, #20
 781:le_phy.c      **** 		goto err_out;
 1788              		.loc 1 781 0
 1789 01e2 9E42     		cmp	r6, r3
 1790 01e4 28BF     		it	cs
 1791 01e6 1E46     		movcs	r6, r3
 1792 01e8 B245     		cmp	r10, r6
 1793 01ea 00F29080 		bhi	.L135
 787:le_phy.c      **** 	if (conn.supervision_timeout < MSEC(100) || conn.supervision_timeout > SEC(32))
 1794              		.loc 1 787 0
 1795 01ee 03FB0BF3 		mul	r3, r3, fp
 788:le_phy.c      **** 		goto err_out;
 1796              		.loc 1 788 0
 1797 01f2 A3F5742B 		sub	fp, r3, #999424
 787:le_phy.c      **** 	if (conn.supervision_timeout < MSEC(100) || conn.supervision_timeout > SEC(32))
 1798              		.loc 1 787 0
 1799 01f6 6363     		str	r3, [r4, #52]
 788:le_phy.c      **** 		goto err_out;
ARM GAS  /tmp/ccnRyoKo.s 			page 55


 1800              		.loc 1 788 0
 1801 01f8 564B     		ldr	r3, .L160+64
 1802 01fa ABF5107B 		sub	fp, fp, #576
 1803 01fe 9B45     		cmp	fp, r3
 1804 0200 00F28580 		bhi	.L135
 792:le_phy.c      **** 	if (conn.remapping.total_channels == 0)
 1805              		.loc 1 792 0
 1806 0204 5449     		ldr	r1, .L160+68
 1807 0206 05F11E00 		add	r0, r5, #30
 1808 020a FFF7FEFF 		bl	le_parse_channel_map
 1809              	.LVL144:
 793:le_phy.c      **** 		goto err_out;
 1810              		.loc 1 793 0
 1811 020e D4F8FC30 		ldr	r3, [r4, #252]
 1812 0212 002B     		cmp	r3, #0
 1813 0214 7BD0     		beq	.L135
 1814              	.LBB102:
 1815              	.LBB103:
 203:le_phy.c      **** 	conn_event.opened = 0;
 1816              		.loc 1 203 0
 1817 0216 0022     		movs	r2, #0
 1818              	.LBE103:
 1819              	.LBE102:
 1820              	.LBB106:
 1821              	.LBB107:
 563:le_phy.c      **** }
 1822              		.loc 1 563 0
 1823 0218 D9F80030 		ldr	r3, [r9]
 1824 021c 23F04003 		bic	r3, r3, #64
 1825 0220 C9F80030 		str	r3, [r9]
 1826              	.LBE107:
 1827              	.LBE106:
 1828              	.LBB108:
 1829              	.LBB104:
 203:le_phy.c      **** 	conn_event.opened = 0;
 1830              		.loc 1 203 0
 1831 0224 4D4B     		ldr	r3, .L160+72
 1832              	.LBE104:
 1833              	.LBE108:
 800:le_phy.c      **** 			conn.win_offset + USEC(1250) - RX_WARMUP_TIME);
 1834              		.loc 1 800 0
 1835 0226 E06B     		ldr	r0, [r4, #60]
 1836              	.LBB109:
 1837              	.LBB105:
 203:le_phy.c      **** 	conn_event.opened = 0;
 1838              		.loc 1 203 0
 1839 0228 5A60     		str	r2, [r3, #4]
 204:le_phy.c      **** }
 1840              		.loc 1 204 0
 1841 022a 9A60     		str	r2, [r3, #8]
 1842              	.LBE105:
 1843              	.LBE109:
 800:le_phy.c      **** 			conn.win_offset + USEC(1250) - RX_WARMUP_TIME);
 1844              		.loc 1 800 0
 1845 022c 5022     		movs	r2, #80
 1846 022e D5F80C31 		ldr	r3, [r5, #268]
 1847 0232 00F51A50 		add	r0, r0, #9856
ARM GAS  /tmp/ccnRyoKo.s 			page 56


 1848 0236 2C30     		adds	r0, r0, #44
 1849 0238 1844     		add	r0, r0, r3
 1850 023a D5F80431 		ldr	r3, [r5, #260]
 1851 023e 02FB0300 		mla	r0, r2, r3, r0
 1852 0242 FFF7FEFF 		bl	timer1_set_match
 1853              	.LVL145:
 1854 0246 14E0     		b	.L128
 1855              	.LVL146:
 1856              	.L123:
 1857              	.LBE101:
 1858              	.LBE100:
 1859              	.LBE99:
 1860              	.LBE98:
 937:le_phy.c      **** 				blink(0, 1, 0); // RX LED
 1861              		.loc 1 937 0
 1862 0248 059D     		ldr	r5, [sp, #20]
 1863              	.LBB117:
 1864              	.LBB90:
 880:le_phy.c      **** 		return 1;
 1865              		.loc 1 880 0
 1866 024a B5F81001 		ldrh	r0, [r5, #272]
 1867 024e FFF7FEFF 		bl	btle_channel_index
 1868              	.LVL147:
 1869 0252 2428     		cmp	r0, #36
 1870 0254 7FF640AF 		bls	.L126
 1871 0258 2B78     		ldrb	r3, [r5]	@ zero_extendqisi2
 1872 025a 03F00F02 		and	r2, r3, #15
 1873 025e 062A     		cmp	r2, #6
 1874 0260 07D8     		bhi	.L128
 1875 0262 0123     		movs	r3, #1
 1876 0264 9340     		lsls	r3, r3, r2
 1877 0266 13F0550F 		tst	r3, #85
 1878 026a 0AD1     		bne	.L129
 1879 026c 13F02A0F 		tst	r3, #42
 1880 0270 11D1     		bne	.L130
 1881              	.L128:
 1882              	.LVL148:
 1883              	.LBE90:
 1884              	.LBE117:
 1885              	.LBB118:
 1886              	.LBB119:
 198:le_phy.c      **** }
 1887              		.loc 1 198 0
 1888 0272 0122     		movs	r2, #1
 1889 0274 059B     		ldr	r3, [sp, #20]
 1890 0276 C3F81821 		str	r2, [r3, #280]
 1891              	.LVL149:
 1892              	.L122:
 1893              	.LBE119:
 1894              	.LBE118:
 947:le_phy.c      **** 
 1895              		.loc 1 947 0
 1896 027a 0020     		movs	r0, #0
 1897 027c FFF7FEFF 		bl	handle_usb
 1898              	.LVL150:
 1899 0280 FEE6     		b	.L121
 1900              	.L129:
ARM GAS  /tmp/ccnRyoKo.s 			page 57


 1901              	.LBB120:
 1902              	.LBB91:
 890:le_phy.c      **** 				return 0;
 1903              		.loc 1 890 0
 1904 0282 D5F80431 		ldr	r3, [r5, #260]
 1905 0286 072B     		cmp	r3, #7
 1906 0288 F3D9     		bls	.L128
 892:le_phy.c      **** 			break;
 1907              		.loc 1 892 0
 1908 028a A81C     		adds	r0, r5, #2
 1909              	.L159:
 903:le_phy.c      **** 			break;
 1910              		.loc 1 903 0
 1911 028c FFF7FEFF 		bl	bd_addr_cmp
 1912              	.LVL151:
 902:le_phy.c      **** 				   bd_addr_cmp(&buf->data[8]);
 1913              		.loc 1 902 0
 1914 0290 0028     		cmp	r0, #0
 1915 0292 EED0     		beq	.L128
 1916 0294 20E7     		b	.L126
 1917              	.L130:
 900:le_phy.c      **** 				return 0;
 1918              		.loc 1 900 0
 1919 0296 D5F80431 		ldr	r3, [r5, #260]
 1920 029a 0D2B     		cmp	r3, #13
 1921 029c E9D9     		bls	.L128
 902:le_phy.c      **** 				   bd_addr_cmp(&buf->data[8]);
 1922              		.loc 1 902 0
 1923 029e A81C     		adds	r0, r5, #2
 1924 02a0 FFF7FEFF 		bl	bd_addr_cmp
 1925              	.LVL152:
 1926 02a4 0028     		cmp	r0, #0
 1927 02a6 7FF417AF 		bne	.L126
 903:le_phy.c      **** 			break;
 1928              		.loc 1 903 0
 1929 02aa 05F10800 		add	r0, r5, #8
 1930 02ae EDE7     		b	.L159
 1931              	.LVL153:
 1932              	.L157:
 1933              	.LBE91:
 1934              	.LBE120:
 1935              	.LBB121:
 1936              	.LBB97:
 715:le_phy.c      **** 	f->clk100ns = packet->timestamp;
 1937              		.loc 1 715 0
 1938 02b0 4FF0000A 		mov	r10, #0
 713:le_phy.c      **** 
 1939              		.loc 1 713 0
 1940 02b4 0123     		movs	r3, #1
 715:le_phy.c      **** 	f->clk100ns = packet->timestamp;
 1941              		.loc 1 715 0
 1942 02b6 80F803A0 		strb	r10, [r0, #3]
 713:le_phy.c      **** 
 1943              		.loc 1 713 0
 1944 02ba 0370     		strb	r3, [r0]
 716:le_phy.c      **** 
 1945              		.loc 1 716 0
ARM GAS  /tmp/ccnRyoKo.s 			page 58


 1946 02bc D8F80C31 		ldr	r3, [r8, #268]
 724:le_phy.c      **** 	memcpy(f->data+4, packet->data, DMA_SIZE-4);
 1947              		.loc 1 724 0
 1948 02c0 08F58A71 		add	r1, r8, #276
 716:le_phy.c      **** 
 1949              		.loc 1 716 0
 1950 02c4 4360     		str	r3, [r0, #4]
 718:le_phy.c      **** 	f->rssi_avg = packet->rssi_sum / packet->size;
 1951              		.loc 1 718 0
 1952 02c6 D8F81031 		ldr	r3, [r8, #272]
 724:le_phy.c      **** 	memcpy(f->data+4, packet->data, DMA_SIZE-4);
 1953              		.loc 1 724 0
 1954 02ca 0E30     		adds	r0, r0, #14
 1955              	.LVL154:
 718:le_phy.c      **** 	f->rssi_avg = packet->rssi_sum / packet->size;
 1956              		.loc 1 718 0
 1957 02cc 623B     		subs	r3, r3, #98
 1958 02ce 00F80C3C 		strb	r3, [r0, #-12]
 719:le_phy.c      **** 	f->rssi_min = packet->rssi_min;
 1959              		.loc 1 719 0
 1960 02d2 D8F80421 		ldr	r2, [r8, #260]
 1961 02d6 D8F82031 		ldr	r3, [r8, #288]
 1962 02da B3FBF2F3 		udiv	r3, r3, r2
 1963 02de 00F8043C 		strb	r3, [r0, #-4]
 720:le_phy.c      **** 	f->rssi_max = packet->rssi_max;
 1964              		.loc 1 720 0
 1965 02e2 98F81C31 		ldrb	r3, [r8, #284]	@ zero_extendqisi2
 724:le_phy.c      **** 	memcpy(f->data+4, packet->data, DMA_SIZE-4);
 1966              		.loc 1 724 0
 1967 02e6 0422     		movs	r2, #4
 720:le_phy.c      **** 	f->rssi_max = packet->rssi_max;
 1968              		.loc 1 720 0
 1969 02e8 00F8053C 		strb	r3, [r0, #-5]
 721:le_phy.c      **** 	f->rssi_count = 0;
 1970              		.loc 1 721 0
 1971 02ec 98F81D31 		ldrb	r3, [r8, #285]	@ zero_extendqisi2
 722:le_phy.c      **** 
 1972              		.loc 1 722 0
 1973 02f0 00F803AC 		strb	r10, [r0, #-3]
 721:le_phy.c      **** 	f->rssi_count = 0;
 1974              		.loc 1 721 0
 1975 02f4 00F8063C 		strb	r3, [r0, #-6]
 724:le_phy.c      **** 	memcpy(f->data+4, packet->data, DMA_SIZE-4);
 1976              		.loc 1 724 0
 1977 02f8 FFF7FEFF 		bl	memcpy
 1978              	.LVL155:
 725:le_phy.c      **** 
 1979              		.loc 1 725 0
 1980 02fc 2E22     		movs	r2, #46
 1981 02fe 4146     		mov	r1, r8
 1982 0300 05F11200 		add	r0, r5, #18
 1983 0304 FFF7FEFF 		bl	memcpy
 1984              	.LVL156:
 727:le_phy.c      **** 
 1985              		.loc 1 727 0
 1986 0308 85F801A0 		strb	r10, [r5, #1]
 1987 030c FCE6     		b	.L124
ARM GAS  /tmp/ccnRyoKo.s 			page 59


 1988              	.LVL157:
 1989              	.L135:
 1990              	.LDL1:
 1991              	.LBE97:
 1992              	.LBE121:
 1993              	.LBB122:
 1994              	.LBB116:
 1995              	.LBB111:
 1996              	.LBB110:
 806:le_phy.c      **** }
 1997              		.loc 1 806 0
 1998 030e FFF7FEFF 		bl	reset_conn
 1999              	.LVL158:
 2000 0312 AEE7     		b	.L128
 2001              	.L161:
 2002              		.align	2
 2003              	.L160:
 2004 0314 00000000 		.word	.LANCHOR0
 2005 0318 00000000 		.word	packet_queue
 2006 031c 04800040 		.word	1073774596
 2007 0320 0C800040 		.word	1073774604
 2008 0324 00E100E0 		.word	-536813312
 2009 0328 00000000 		.word	le_adv_channel
 2010 032c 00000000 		.word	rf_channel
 2011 0330 D6BE898E 		.word	-1903575338
 2012 0334 00000000 		.word	cancel_follow
 2013 0338 00000000 		.word	requested_mode
 2014 033c 3CC00920 		.word	537509948
 2015 0340 00000000 		.word	le
 2016 0344 38C00920 		.word	537509944
 2017 0348 08800040 		.word	1073774600
 2018 034c 1C800040 		.word	1073774620
 2019 0350 A0860100 		.word	100000
 2020 0354 C08D0313 		.word	319000000
 2021 0358 40000000 		.word	.LANCHOR0+64
 2022 035c 00000000 		.word	conn_event
 2023 0360 80E100E0 		.word	-536813184
 2024 0364 14800040 		.word	1073774612
 2025              	.LVL159:
 2026              	.L132:
 2027              	.LBE110:
 2028              	.LBE111:
 848:le_phy.c      **** 			switch (buf->data[2]) {
 2029              		.loc 1 848 0
 2030 0368 01F00301 		and	r1, r1, #3
 2031 036c 0329     		cmp	r1, #3
 2032 036e 80D1     		bne	.L128
 2033 0370 95F80180 		ldrb	r8, [r5, #1]	@ zero_extendqisi2
 2034 0374 B8F1000F 		cmp	r8, #0
 2035 0378 3FF47BAF 		beq	.L128
 849:le_phy.c      **** 				// LE_CONNECTION_UPDATE_REQ -- update connection parameters
 2036              		.loc 1 849 0
 2037 037c AB78     		ldrb	r3, [r5, #2]	@ zero_extendqisi2
 2038 037e A3B1     		cbz	r3, .L136
 2039 0380 012B     		cmp	r3, #1
 2040 0382 7FF476AF 		bne	.L128
 858:le_phy.c      **** 						channel_map_update_handler(buf);
ARM GAS  /tmp/ccnRyoKo.s 			page 60


 2041              		.loc 1 858 0
 2042 0386 B8F1080F 		cmp	r8, #8
 2043 038a 7FF472AF 		bne	.L128
 2044              	.LVL160:
 2045              	.LBB112:
 2046              	.LBB113:
 829:le_phy.c      **** 	le_parse_channel_map(&buf->data[3], &conn.pending_remapping);
 2047              		.loc 1 829 0
 2048 038e 4146     		mov	r1, r8
 2049 0390 0222     		movs	r2, #2
 2050 0392 2846     		mov	r0, r5
 828:le_phy.c      **** 	conn.channel_map_update_instant = extract_field(buf, 8, 2);
 2051              		.loc 1 828 0
 2052 0394 C4F82031 		str	r3, [r4, #288]
 829:le_phy.c      **** 	le_parse_channel_map(&buf->data[3], &conn.pending_remapping);
 2053              		.loc 1 829 0
 2054 0398 FFF7FEFF 		bl	extract_field
 2055              	.LVL161:
 830:le_phy.c      **** }
 2056              		.loc 1 830 0
 2057 039c 2549     		ldr	r1, .L162
 829:le_phy.c      **** 	le_parse_channel_map(&buf->data[3], &conn.pending_remapping);
 2058              		.loc 1 829 0
 2059 039e A4F82401 		strh	r0, [r4, #292]	@ movhi
 830:le_phy.c      **** }
 2060              		.loc 1 830 0
 2061 03a2 E81C     		adds	r0, r5, #3
 2062 03a4 FFF7FEFF 		bl	le_parse_channel_map
 2063              	.LVL162:
 2064 03a8 63E7     		b	.L128
 2065              	.LVL163:
 2066              	.L136:
 2067              	.LBE113:
 2068              	.LBE112:
 852:le_phy.c      **** 						connection_update_handler(buf);
 2069              		.loc 1 852 0
 2070 03aa B8F10C0F 		cmp	r8, #12
 2071 03ae 7FF460AF 		bne	.L128
 2072              	.LVL164:
 2073              	.LBB114:
 2074              	.LBB115:
 810:le_phy.c      **** 	conn.win_offset          = extract_field(buf, 4, 2);
 2075              		.loc 1 810 0
 2076 03b2 0122     		movs	r2, #1
 2077 03b4 2846     		mov	r0, r5
 2078 03b6 FFF7FEFF 		bl	extract_field
 2079              	.LVL165:
 811:le_phy.c      **** 	conn.conn_update_pending_interval = extract_field(buf, 6, 2);
 2080              		.loc 1 811 0
 2081 03ba 0222     		movs	r2, #2
 810:le_phy.c      **** 	conn.win_offset          = extract_field(buf, 4, 2);
 2082              		.loc 1 810 0
 2083 03bc C6B2     		uxtb	r6, r0
 811:le_phy.c      **** 	conn.conn_update_pending_interval = extract_field(buf, 6, 2);
 2084              		.loc 1 811 0
 2085 03be 0421     		movs	r1, #4
 2086 03c0 2846     		mov	r0, r5
ARM GAS  /tmp/ccnRyoKo.s 			page 61


 810:le_phy.c      **** 	conn.win_offset          = extract_field(buf, 4, 2);
 2087              		.loc 1 810 0
 2088 03c2 84F83860 		strb	r6, [r4, #56]
 811:le_phy.c      **** 	conn.conn_update_pending_interval = extract_field(buf, 6, 2);
 2089              		.loc 1 811 0
 2090 03c6 FFF7FEFF 		bl	extract_field
 2091              	.LVL166:
 812:le_phy.c      **** 	conn.conn_update_pending_supervision_timeout = extract_field(buf, 10, 2);
 2092              		.loc 1 812 0
 2093 03ca 0222     		movs	r2, #2
 811:le_phy.c      **** 	conn.conn_update_pending_interval = extract_field(buf, 6, 2);
 2094              		.loc 1 811 0
 2095 03cc 8246     		mov	r10, r0
 2096 03ce E063     		str	r0, [r4, #60]
 812:le_phy.c      **** 	conn.conn_update_pending_supervision_timeout = extract_field(buf, 10, 2);
 2097              		.loc 1 812 0
 2098 03d0 0621     		movs	r1, #6
 2099 03d2 2846     		mov	r0, r5
 2100 03d4 FFF7FEFF 		bl	extract_field
 2101              	.LVL167:
 813:le_phy.c      **** 	conn.conn_update_instant = extract_field(buf, 12, 2);
 2102              		.loc 1 813 0
 2103 03d8 0222     		movs	r2, #2
 812:le_phy.c      **** 	conn.conn_update_pending_supervision_timeout = extract_field(buf, 10, 2);
 2104              		.loc 1 812 0
 2105 03da C4F81401 		str	r0, [r4, #276]
 2106 03de 0390     		str	r0, [sp, #12]
 813:le_phy.c      **** 	conn.conn_update_instant = extract_field(buf, 12, 2);
 2107              		.loc 1 813 0
 2108 03e0 0A21     		movs	r1, #10
 2109 03e2 2846     		mov	r0, r5
 2110 03e4 FFF7FEFF 		bl	extract_field
 2111              	.LVL168:
 814:le_phy.c      **** 
 2112              		.loc 1 814 0
 2113 03e8 0222     		movs	r2, #2
 813:le_phy.c      **** 	conn.conn_update_instant = extract_field(buf, 12, 2);
 2114              		.loc 1 813 0
 2115 03ea 8346     		mov	fp, r0
 2116 03ec C4F81801 		str	r0, [r4, #280]
 814:le_phy.c      **** 
 2117              		.loc 1 814 0
 2118 03f0 4146     		mov	r1, r8
 2119 03f2 2846     		mov	r0, r5
 2120 03f4 FFF7FEFF 		bl	extract_field
 2121              	.LVL169:
 819:le_phy.c      **** 	conn.win_offset *= USEC(1250);
 2122              		.loc 1 819 0
 2123 03f8 06EB4602 		add	r2, r6, r6, lsl #1
 2124 03fc 06EB8202 		add	r2, r6, r2, lsl #2
 2125 0400 06EB8206 		add	r6, r6, r2, lsl #2
 820:le_phy.c      **** 	conn.conn_update_pending_interval *= USEC(1250);
 2126              		.loc 1 820 0
 2127 0404 43F2D402 		movw	r2, #12500
 821:le_phy.c      **** 	conn.conn_update_pending_supervision_timeout *= MSEC(10);
 2128              		.loc 1 821 0
 2129 0408 039B     		ldr	r3, [sp, #12]
ARM GAS  /tmp/ccnRyoKo.s 			page 62


 820:le_phy.c      **** 	conn.conn_update_pending_interval *= USEC(1250);
 2130              		.loc 1 820 0
 2131 040a 02FB0AF1 		mul	r1, r2, r10
 821:le_phy.c      **** 	conn.conn_update_pending_supervision_timeout *= MSEC(10);
 2132              		.loc 1 821 0
 2133 040e 5343     		muls	r3, r2, r3
 2134 0410 C4F81431 		str	r3, [r4, #276]
 822:le_phy.c      **** 
 2135              		.loc 1 822 0
 2136 0414 084B     		ldr	r3, .L162+4
 819:le_phy.c      **** 	conn.win_offset *= USEC(1250);
 2137              		.loc 1 819 0
 2138 0416 B600     		lsls	r6, r6, #2
 822:le_phy.c      **** 
 2139              		.loc 1 822 0
 2140 0418 03FB0BF3 		mul	r3, r3, fp
 2141 041c C4F81831 		str	r3, [r4, #280]
 824:le_phy.c      **** }
 2142              		.loc 1 824 0
 2143 0420 0123     		movs	r3, #1
 814:le_phy.c      **** 
 2144              		.loc 1 814 0
 2145 0422 A4F81C01 		strh	r0, [r4, #284]	@ movhi
 819:le_phy.c      **** 	conn.win_offset *= USEC(1250);
 2146              		.loc 1 819 0
 2147 0426 84F83860 		strb	r6, [r4, #56]
 820:le_phy.c      **** 	conn.conn_update_pending_interval *= USEC(1250);
 2148              		.loc 1 820 0
 2149 042a E163     		str	r1, [r4, #60]
 824:le_phy.c      **** }
 2150              		.loc 1 824 0
 2151 042c C4F81031 		str	r3, [r4, #272]
 2152 0430 1FE7     		b	.L128
 2153              	.L163:
 2154 0432 00BF     		.align	2
 2155              	.L162:
 2156 0434 28010000 		.word	.LANCHOR0+296
 2157 0438 A0860100 		.word	100000
 2158              	.LBE115:
 2159              	.LBE114:
 2160              	.LBE116:
 2161              	.LBE122:
 2162              	.LBE125:
 2163              		.cfi_endproc
 2164              	.LFE30:
 2166              		.comm	conn_event,12,4
 2167              		.global	conn
 2168              		.comm	packet_queue,48,4
 2169              		.comm	le_dma_dest,2,1
 2170              		.comm	rf_channel,2,2
 2171              		.comm	rx_err,4,4
 2172              		.comm	rx_tc,4,4
 2173              		.comm	idle_rxbuf,4,4
 2174              		.comm	active_rxbuf,4,4
 2175              		.comm	rxbuf2,50,1
 2176              		.comm	rxbuf1,50,1
 2177              		.comm	clkn_next_drift_fix,4,4
ARM GAS  /tmp/ccnRyoKo.s 			page 63


 2178              		.comm	clkn_last_drift_fix,4,4
 2179              		.comm	clk_drift_correction,2,2
 2180              		.comm	clk_drift_ppm,2,2
 2181              		.comm	clk100ns_offset,2,2
 2182              		.comm	clkn_offset,4,4
 2183              		.comm	last_hop,4,4
 2184              		.comm	clkn,4,4
 2185              		.section	.rodata
 2186              		.set	.LANCHOR1,. + 0
 2189              	whitening_index:
 2190 0000 46       		.byte	70
 2191 0001 3E       		.byte	62
 2192 0002 78       		.byte	120
 2193 0003 6F       		.byte	111
 2194 0004 4D       		.byte	77
 2195 0005 2E       		.byte	46
 2196 0006 0F       		.byte	15
 2197 0007 65       		.byte	101
 2198 0008 42       		.byte	66
 2199 0009 27       		.byte	39
 2200 000a 1F       		.byte	31
 2201 000b 1A       		.byte	26
 2202 000c 50       		.byte	80
 2203 000d 53       		.byte	83
 2204 000e 7D       		.byte	125
 2205 000f 59       		.byte	89
 2206 0010 0A       		.byte	10
 2207 0011 23       		.byte	35
 2208 0012 08       		.byte	8
 2209 0013 36       		.byte	54
 2210 0014 7A       		.byte	122
 2211 0015 11       		.byte	17
 2212 0016 21       		.byte	33
 2213 0017 00       		.byte	0
 2214 0018 3A       		.byte	58
 2215 0019 73       		.byte	115
 2216 001a 06       		.byte	6
 2217 001b 5E       		.byte	94
 2218 001c 56       		.byte	86
 2219 001d 31       		.byte	49
 2220 001e 34       		.byte	52
 2221 001f 14       		.byte	20
 2222 0020 28       		.byte	40
 2223 0021 1B       		.byte	27
 2224 0022 54       		.byte	84
 2225 0023 5A       		.byte	90
 2226 0024 3F       		.byte	63
 2227 0025 70       		.byte	112
 2228 0026 2F       		.byte	47
 2229 0027 66       		.byte	102
 2232              	whitening:
 2233 0028 01       		.byte	1
 2234 0029 01       		.byte	1
 2235 002a 01       		.byte	1
 2236 002b 01       		.byte	1
 2237 002c 00       		.byte	0
 2238 002d 01       		.byte	1
ARM GAS  /tmp/ccnRyoKo.s 			page 64


 2239 002e 00       		.byte	0
 2240 002f 01       		.byte	1
 2241 0030 00       		.byte	0
 2242 0031 01       		.byte	1
 2243 0032 00       		.byte	0
 2244 0033 00       		.byte	0
 2245 0034 00       		.byte	0
 2246 0035 00       		.byte	0
 2247 0036 01       		.byte	1
 2248 0037 00       		.byte	0
 2249 0038 01       		.byte	1
 2250 0039 01       		.byte	1
 2251 003a 00       		.byte	0
 2252 003b 01       		.byte	1
 2253 003c 01       		.byte	1
 2254 003d 01       		.byte	1
 2255 003e 01       		.byte	1
 2256 003f 00       		.byte	0
 2257 0040 00       		.byte	0
 2258 0041 01       		.byte	1
 2259 0042 01       		.byte	1
 2260 0043 01       		.byte	1
 2261 0044 00       		.byte	0
 2262 0045 00       		.byte	0
 2263 0046 01       		.byte	1
 2264 0047 00       		.byte	0
 2265 0048 01       		.byte	1
 2266 0049 00       		.byte	0
 2267 004a 01       		.byte	1
 2268 004b 01       		.byte	1
 2269 004c 00       		.byte	0
 2270 004d 00       		.byte	0
 2271 004e 01       		.byte	1
 2272 004f 01       		.byte	1
 2273 0050 00       		.byte	0
 2274 0051 00       		.byte	0
 2275 0052 00       		.byte	0
 2276 0053 00       		.byte	0
 2277 0054 00       		.byte	0
 2278 0055 01       		.byte	1
 2279 0056 01       		.byte	1
 2280 0057 00       		.byte	0
 2281 0058 01       		.byte	1
 2282 0059 01       		.byte	1
 2283 005a 00       		.byte	0
 2284 005b 01       		.byte	1
 2285 005c 00       		.byte	0
 2286 005d 01       		.byte	1
 2287 005e 01       		.byte	1
 2288 005f 01       		.byte	1
 2289 0060 00       		.byte	0
 2290 0061 01       		.byte	1
 2291 0062 00       		.byte	0
 2292 0063 00       		.byte	0
 2293 0064 00       		.byte	0
 2294 0065 01       		.byte	1
 2295 0066 01       		.byte	1
ARM GAS  /tmp/ccnRyoKo.s 			page 65


 2296 0067 00       		.byte	0
 2297 0068 00       		.byte	0
 2298 0069 01       		.byte	1
 2299 006a 00       		.byte	0
 2300 006b 00       		.byte	0
 2301 006c 00       		.byte	0
 2302 006d 01       		.byte	1
 2303 006e 00       		.byte	0
 2304 006f 00       		.byte	0
 2305 0070 00       		.byte	0
 2306 0071 00       		.byte	0
 2307 0072 00       		.byte	0
 2308 0073 00       		.byte	0
 2309 0074 01       		.byte	1
 2310 0075 00       		.byte	0
 2311 0076 00       		.byte	0
 2312 0077 01       		.byte	1
 2313 0078 00       		.byte	0
 2314 0079 00       		.byte	0
 2315 007a 01       		.byte	1
 2316 007b 01       		.byte	1
 2317 007c 00       		.byte	0
 2318 007d 01       		.byte	1
 2319 007e 00       		.byte	0
 2320 007f 00       		.byte	0
 2321 0080 01       		.byte	1
 2322 0081 01       		.byte	1
 2323 0082 01       		.byte	1
 2324 0083 01       		.byte	1
 2325 0084 00       		.byte	0
 2326 0085 01       		.byte	1
 2327 0086 01       		.byte	1
 2328 0087 01       		.byte	1
 2329 0088 00       		.byte	0
 2330 0089 00       		.byte	0
 2331 008a 00       		.byte	0
 2332 008b 00       		.byte	0
 2333 008c 01       		.byte	1
 2334 008d 01       		.byte	1
 2335 008e 01       		.byte	1
 2336 008f 01       		.byte	1
 2337 0090 01       		.byte	1
 2338 0091 01       		.byte	1
 2339 0092 01       		.byte	1
 2340 0093 00       		.byte	0
 2341 0094 00       		.byte	0
 2342 0095 00       		.byte	0
 2343 0096 01       		.byte	1
 2344 0097 01       		.byte	1
 2345 0098 01       		.byte	1
 2346 0099 00       		.byte	0
 2347 009a 01       		.byte	1
 2348 009b 01       		.byte	1
 2349 009c 00       		.byte	0
 2350 009d 00       		.byte	0
 2351 009e 00       		.byte	0
 2352 009f 01       		.byte	1
ARM GAS  /tmp/ccnRyoKo.s 			page 66


 2353 00a0 00       		.byte	0
 2354 00a1 01       		.byte	1
 2355 00a2 00       		.byte	0
 2356 00a3 00       		.byte	0
 2357 00a4 01       		.byte	1
 2358 00a5 00       		.byte	0
 2359 00a6 01       		.byte	1
 2360              		.bss
 2361              		.align	2
 2362              		.set	.LANCHOR0,. + 0
 2365              	le_dma_lli.4940:
 2366 0000 00000000 		.space	32
 2366      00000000 
 2366      00000000 
 2366      00000000 
 2366      00000000 
 2369              	conn:
 2370 0020 00000000 		.space	456
 2370      00000000 
 2370      00000000 
 2370      00000000 
 2370      00000000 
 2373              	le_buffer_pool:
 2374 01e8 00000000 		.space	1168
 2374      00000000 
 2374      00000000 
 2374      00000000 
 2374      00000000 
 2377              	current_rxbuf:
 2378 0678 00000000 		.space	4
 2379              		.section	.rodata.str1.1,"aMS",%progbits,1
 2380              	.LC0:
 2381 0000 6C655F44 		.ascii	"le_DMA_IRQHandler\012\000"
 2381      4D415F49 
 2381      52514861 
 2381      6E646C65 
 2381      720A00
 2382              		.text
 2383              	.Letext0:
 2384              		.file 2 "/usr/lib/gcc/arm-none-eabi/6.3.1/include/stddef.h"
 2385              		.file 3 "/usr/include/newlib/sys/lock.h"
 2386              		.file 4 "/usr/include/newlib/sys/_types.h"
 2387              		.file 5 "/usr/include/newlib/sys/reent.h"
 2388              		.file 6 "/usr/include/newlib/stdlib.h"
 2389              		.file 7 "/usr/lib/gcc/arm-none-eabi/6.3.1/include/stdint-gcc.h"
 2390              		.file 8 "../../host/libubertooth/src/ubertooth_interface.h"
 2391              		.file 9 "../common/ubertooth.h"
 2392              		.file 10 "ubertooth_clock.h"
 2393              		.file 11 "ubertooth_dma.h"
 2394              		.file 12 "bluetooth_le.h"
 2395              		.file 13 "queue.h"
 2396              		.file 14 "ubertooth_usb.h"
 2397              		.file 15 "/usr/include/newlib/string.h"
ARM GAS  /tmp/ccnRyoKo.s 			page 67


DEFINED SYMBOLS
                            *ABS*:0000000000000000 le_phy.c
     /tmp/ccnRyoKo.s:16     .text.le_dma_init:0000000000000000 $t
     /tmp/ccnRyoKo.s:22     .text.le_dma_init:0000000000000000 le_dma_init
     /tmp/ccnRyoKo.s:81     .text.le_dma_init:0000000000000034 $d
                            *COM*:0000000000000002 le_dma_dest
     /tmp/ccnRyoKo.s:90     .text.timer1_set_match:0000000000000000 $t
     /tmp/ccnRyoKo.s:96     .text.timer1_set_match:0000000000000000 timer1_set_match
     /tmp/ccnRyoKo.s:118    .text.timer1_set_match:0000000000000010 $d
     /tmp/ccnRyoKo.s:124    .text.timer1_wait_fs_lock:0000000000000000 $t
     /tmp/ccnRyoKo.s:130    .text.timer1_wait_fs_lock:0000000000000000 timer1_wait_fs_lock
     /tmp/ccnRyoKo.s:151    .text.timer1_wait_fs_lock:0000000000000018 $d
     /tmp/ccnRyoKo.s:157    .text.extract_field:0000000000000000 $t
     /tmp/ccnRyoKo.s:163    .text.extract_field:0000000000000000 extract_field
     /tmp/ccnRyoKo.s:206    .text.bd_addr_cmp:0000000000000000 $t
     /tmp/ccnRyoKo.s:212    .text.bd_addr_cmp:0000000000000000 bd_addr_cmp
     /tmp/ccnRyoKo.s:254    .text.bd_addr_cmp:0000000000000024 $d
     /tmp/ccnRyoKo.s:259    .text.reset_conn:0000000000000000 $t
     /tmp/ccnRyoKo.s:265    .text.reset_conn:0000000000000000 reset_conn
     /tmp/ccnRyoKo.s:289    .text.reset_conn:0000000000000018 $d
     /tmp/ccnRyoKo.s:295    .text.buffer_get:0000000000000000 $t
     /tmp/ccnRyoKo.s:301    .text.buffer_get:0000000000000000 buffer_get
     /tmp/ccnRyoKo.s:369    .text.buffer_get:0000000000000054 $d
     /tmp/ccnRyoKo.s:374    .text.le_cc2400_init_rf:0000000000000000 $t
     /tmp/ccnRyoKo.s:380    .text.le_cc2400_init_rf:0000000000000000 le_cc2400_init_rf
     /tmp/ccnRyoKo.s:463    .text.le_cc2400_init_rf:0000000000000070 $d
                            *COM*:0000000000000002 rf_channel
     /tmp/ccnRyoKo.s:469    .text.change_channel:0000000000000000 $t
     /tmp/ccnRyoKo.s:475    .text.change_channel:0000000000000000 change_channel
     /tmp/ccnRyoKo.s:616    .text.change_channel:00000000000000ac $d
     /tmp/ccnRyoKo.s:626    .text.finish_conn_event:0000000000000000 $t
     /tmp/ccnRyoKo.s:632    .text.finish_conn_event:0000000000000000 finish_conn_event
     /tmp/ccnRyoKo.s:783    .text.finish_conn_event:00000000000000ac $d
                            *COM*:000000000000000c conn_event
     /tmp/ccnRyoKo.s:791    .text.le_DMA_IRQHandler:0000000000000000 $t
     /tmp/ccnRyoKo.s:798    .text.le_DMA_IRQHandler:0000000000000000 le_DMA_IRQHandler
     /tmp/ccnRyoKo.s:1140   .text.le_DMA_IRQHandler:00000000000001a8 $d
                            *COM*:0000000000000030 packet_queue
     /tmp/ccnRyoKo.s:1161   .text.TIMER1_IRQHandler:0000000000000000 $t
     /tmp/ccnRyoKo.s:1168   .text.TIMER1_IRQHandler:0000000000000000 TIMER1_IRQHandler
     /tmp/ccnRyoKo.s:1380   .text.TIMER1_IRQHandler:0000000000000128 $d
     /tmp/ccnRyoKo.s:1392   .text.le_phy_main:0000000000000000 $t
     /tmp/ccnRyoKo.s:1399   .text.le_phy_main:0000000000000000 le_phy_main
     /tmp/ccnRyoKo.s:2004   .text.le_phy_main:0000000000000314 $d
     /tmp/ccnRyoKo.s:2030   .text.le_phy_main:0000000000000368 $t
     /tmp/ccnRyoKo.s:2156   .text.le_phy_main:0000000000000434 $d
     /tmp/ccnRyoKo.s:2369   .bss:0000000000000020 conn
                            *COM*:0000000000000004 rx_err
                            *COM*:0000000000000004 rx_tc
                            *COM*:0000000000000004 idle_rxbuf
                            *COM*:0000000000000004 active_rxbuf
                            *COM*:0000000000000032 rxbuf2
                            *COM*:0000000000000032 rxbuf1
                            *COM*:0000000000000004 clkn_next_drift_fix
                            *COM*:0000000000000004 clkn_last_drift_fix
                            *COM*:0000000000000002 clk_drift_correction
                            *COM*:0000000000000002 clk_drift_ppm
ARM GAS  /tmp/ccnRyoKo.s 			page 68


                            *COM*:0000000000000002 clk100ns_offset
                            *COM*:0000000000000004 clkn_offset
                            *COM*:0000000000000004 last_hop
                            *COM*:0000000000000004 clkn
     /tmp/ccnRyoKo.s:2189   .rodata:0000000000000000 whitening_index
     /tmp/ccnRyoKo.s:2232   .rodata:0000000000000028 whitening
     /tmp/ccnRyoKo.s:2361   .bss:0000000000000000 $d
     /tmp/ccnRyoKo.s:2365   .bss:0000000000000000 le_dma_lli.4940
     /tmp/ccnRyoKo.s:2373   .bss:00000000000001e8 le_buffer_pool
     /tmp/ccnRyoKo.s:2377   .bss:0000000000000678 current_rxbuf
                     .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
le
memset
rbit
cc2400_set
cc2400_status
cc2400_strobe
dio_ssp_start
btle_channel_index_to_phys
le_map_channel
le_adv_channel
cancel_follow
debug_printf
cc2400_get
btle_channel_index
queue_insert
memcpy
clkn_disable
queue_init
usb_queue_init
dio_ssp_init
debug_uart_init
clkn_init
queue_remove
le_dewhiten
usb_enqueue
le_parse_channel_map
handle_usb
requested_mode
