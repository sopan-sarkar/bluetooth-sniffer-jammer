ARM GAS  /tmp/ccbEq2sz.s 			page 1


   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 4
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"le_phy.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.le_dma_init,"ax",%progbits
  16              		.align	1
  17              		.syntax unified
  18              		.thumb
  19              		.thumb_func
  20              		.fpu softvfp
  22              	le_dma_init:
  23              	.LFB8:
  24              		.file 1 "le_phy.c"
   1:le_phy.c      **** /*
   2:le_phy.c      ****  * Copyright 2017 Mike Ryan
   3:le_phy.c      ****  *
   4:le_phy.c      ****  * This file is part of Project Ubertooth and is released under the
   5:le_phy.c      ****  * terms of the GPL. Refer to COPYING for more information.
   6:le_phy.c      ****  */
   7:le_phy.c      **** 
   8:le_phy.c      **** #include <stdlib.h>
   9:le_phy.c      **** #include <string.h>
  10:le_phy.c      **** 
  11:le_phy.c      **** #include "ubertooth.h"
  12:le_phy.c      **** #include "ubertooth_clock.h"
  13:le_phy.c      **** #include "ubertooth_dma.h"
  14:le_phy.c      **** #include "ubertooth_usb.h"
  15:le_phy.c      **** #include "bluetooth_le.h"
  16:le_phy.c      **** #include "queue.h"
  17:le_phy.c      **** 
  18:le_phy.c      **** // current time, from timer1
  19:le_phy.c      **** #define NOW T1TC
  20:le_phy.c      **** #define USEC(X) ((X)*10)
  21:le_phy.c      **** #define MSEC(X) ((X)*10000)
  22:le_phy.c      **** #define  SEC(X) ((X)*10000000)
  23:le_phy.c      **** #define PACKET_DURATION(X) (USEC(40 + (X)->size * 8))
  24:le_phy.c      **** 
  25:le_phy.c      **** #define ADVERTISING_AA (0x8e89bed6)
  26:le_phy.c      **** 
  27:le_phy.c      **** ///////////////////////
  28:le_phy.c      **** // time constants
  29:le_phy.c      **** 
  30:le_phy.c      **** // time for the radio to warmup + some timing slack
  31:le_phy.c      **** #define RX_WARMUP_TIME USEC(300)
  32:le_phy.c      **** 
  33:le_phy.c      **** // max inter-frame space between packets in a connection event
  34:le_phy.c      **** #define IFS_TIMEOUT USEC(300)
ARM GAS  /tmp/ccbEq2sz.s 			page 2


  35:le_phy.c      **** 
  36:le_phy.c      **** // observed connection anchor must be within ANCHOR_EPSILON of
  37:le_phy.c      **** // calculated anchor
  38:le_phy.c      **** #define ANCHOR_EPSILON USEC(3)
  39:le_phy.c      **** 
  40:le_phy.c      **** 
  41:le_phy.c      **** //////////////////////
  42:le_phy.c      **** // global state
  43:le_phy.c      **** 
  44:le_phy.c      **** extern le_state_t le; // FIXME - refactor this struct
  45:le_phy.c      **** volatile uint16_t rf_channel;
  46:le_phy.c      **** uint8_t le_dma_dest[2];
  47:le_phy.c      **** 
  48:le_phy.c      **** extern volatile uint8_t mode;
  49:le_phy.c      **** extern volatile uint8_t requested_mode;
  50:le_phy.c      **** extern volatile uint16_t le_adv_channel;
  51:le_phy.c      **** extern volatile int cancel_follow;
  52:le_phy.c      **** 
  53:le_phy.c      **** ////////////////////
  54:le_phy.c      **** // buffers
  55:le_phy.c      **** 
  56:le_phy.c      **** // packet buffers live in a pool. a minimum of one buffer is always
  57:le_phy.c      **** // being used, either waiting to receive or actively receiving a packet
  58:le_phy.c      **** // (current_rxbuf). once a packet is received, it is placed into the
  59:le_phy.c      **** // packet queue. the main loop pulls packets from this queue and
  60:le_phy.c      **** // processes them, and then returns the buffers back to the pool by
  61:le_phy.c      **** // calling buffer_release()
  62:le_phy.c      **** 
  63:le_phy.c      **** #define LE_BUFFER_POOL_SIZE 4
  64:le_phy.c      **** typedef struct _le_rx_t {
  65:le_phy.c      **** 	uint8_t data[2 + 255 + 3];  // header + PDU + CRC
  66:le_phy.c      **** 	unsigned size;              // total data length (known after header rx)
  67:le_phy.c      **** 	unsigned pos;               // current input byte offset
  68:le_phy.c      **** 	uint32_t timestamp;         // timestamp taken after first byte rx
  69:le_phy.c      **** 	unsigned channel;           // physical channel
  70:le_phy.c      **** 	uint32_t access_address;    // access address
  71:le_phy.c      **** 	int available;              // 1 if available, 0 in use
  72:le_phy.c      **** 	int8_t rssi_min, rssi_max;  // min and max RSSI observed values
  73:le_phy.c      **** 	int rssi_sum;               // running sum of all RSSI values
  74:le_phy.c      **** } le_rx_t;
  75:le_phy.c      **** 
  76:le_phy.c      **** // pool of all buffers
  77:le_phy.c      **** static le_rx_t le_buffer_pool[LE_BUFFER_POOL_SIZE];
  78:le_phy.c      **** 
  79:le_phy.c      **** // buffer waiting for or actively receiving packet
  80:le_phy.c      **** static le_rx_t *current_rxbuf = NULL;
  81:le_phy.c      **** 
  82:le_phy.c      **** // received packets, waiting to be processed
  83:le_phy.c      **** queue_t packet_queue;
  84:le_phy.c      **** 
  85:le_phy.c      **** 
  86:le_phy.c      **** /////////////////////
  87:le_phy.c      **** // connections
  88:le_phy.c      **** 
  89:le_phy.c      **** // this system is architected so that following multiple connections may
  90:le_phy.c      **** // be possible in the future. all connection state lives in an le_conn_t
  91:le_phy.c      **** // struct. at present only one such structure exists. refer to
ARM GAS  /tmp/ccbEq2sz.s 			page 3


  92:le_phy.c      **** // connection event below for how anchors are handled.
  93:le_phy.c      **** 
  94:le_phy.c      **** typedef struct _le_conn_t {
  95:le_phy.c      **** 	uint32_t access_address;
  96:le_phy.c      **** 	uint32_t crc_init;
  97:le_phy.c      **** 	uint32_t crc_init_reversed;
  98:le_phy.c      **** 
  99:le_phy.c      **** 	uint8_t  channel_idx;
 100:le_phy.c      **** 	uint8_t  hop_increment;
 101:le_phy.c      **** 	uint32_t conn_interval; // in units of 100 ns
 102:le_phy.c      **** 	uint32_t supervision_timeout; // in units of 100 ns
 103:le_phy.c      **** 
 104:le_phy.c      **** 	uint8_t  win_size;
 105:le_phy.c      **** 	uint32_t win_offset; // in units of 100 ns
 106:le_phy.c      **** 
 107:le_phy.c      **** 	le_channel_remapping_t remapping;
 108:le_phy.c      **** 
 109:le_phy.c      **** 	uint32_t last_anchor;
 110:le_phy.c      **** 	int      anchor_set;
 111:le_phy.c      **** 	uint32_t last_packet_ts; // used to check supervision timeout
 112:le_phy.c      **** 
 113:le_phy.c      **** 	uint16_t conn_event_counter;
 114:le_phy.c      **** 
 115:le_phy.c      **** 	int      conn_update_pending;
 116:le_phy.c      **** 	uint32_t conn_update_pending_interval;
 117:le_phy.c      **** 	uint32_t conn_update_pending_supervision_timeout;
 118:le_phy.c      **** 	uint16_t conn_update_instant;
 119:le_phy.c      **** 
 120:le_phy.c      **** 	int      channel_map_update_pending;
 121:le_phy.c      **** 	uint16_t channel_map_update_instant;
 122:le_phy.c      **** 	le_channel_remapping_t pending_remapping;
 123:le_phy.c      **** } le_conn_t;
 124:le_phy.c      **** le_conn_t conn = { 0, };
 125:le_phy.c      **** 
 126:le_phy.c      **** // every connection event is tracked using this global le_conn_event_t
 127:le_phy.c      **** // structure named conn_event. when a packet is observed, anchor is set.
 128:le_phy.c      **** // the event may close due to receiving two packets, or if a timeout
 129:le_phy.c      **** // occurs. in both cases, finish_conn_event() is called, which updates
 130:le_phy.c      **** // the active connection's anchor. opened is set to 1 once the radio is
 131:le_phy.c      **** // tuned to the data channel for the connection event.
 132:le_phy.c      **** typedef struct _le_conn_event_t {
 133:le_phy.c      **** 	uint32_t anchor;
 134:le_phy.c      **** 	unsigned num_packets;
 135:le_phy.c      **** 	int opened;
 136:le_phy.c      **** } le_conn_event_t;
 137:le_phy.c      **** le_conn_event_t conn_event;
 138:le_phy.c      **** 
 139:le_phy.c      **** static void reset_conn(void) {
 140:le_phy.c      **** 	memset(&conn, 0, sizeof(conn));
 141:le_phy.c      **** 	conn.access_address = ADVERTISING_AA;
 142:le_phy.c      **** }
 143:le_phy.c      **** 
 144:le_phy.c      **** 
 145:le_phy.c      **** //////////////////////
 146:le_phy.c      **** // code
 147:le_phy.c      **** 
 148:le_phy.c      **** // pre-declarations for utility stuff
ARM GAS  /tmp/ccbEq2sz.s 			page 4


 149:le_phy.c      **** static void timer1_start(void);
 150:le_phy.c      **** static void timer1_stop(void);
 151:le_phy.c      **** static void timer1_set_match(uint32_t match);
 152:le_phy.c      **** static void timer1_clear_match(void);
 153:le_phy.c      **** static void timer1_wait_fs_lock(void);
 154:le_phy.c      **** static void timer1_cancel_fs_lock(void);
 155:le_phy.c      **** static void blink(int tx, int rx, int usr);
 156:le_phy.c      **** static void le_dma_init(void);
 157:le_phy.c      **** static void le_cc2400_strobe_rx(void);
 158:le_phy.c      **** static void change_channel(void);
 159:le_phy.c      **** static uint8_t dewhiten_length(unsigned channel, uint8_t data);
 160:le_phy.c      **** 
 161:le_phy.c      **** // resets the state of all available buffers
 162:le_phy.c      **** static void buffers_init(void) {
 163:le_phy.c      **** 	int i;
 164:le_phy.c      **** 
 165:le_phy.c      **** 	for (i = 0; i < LE_BUFFER_POOL_SIZE; ++i)
 166:le_phy.c      **** 		le_buffer_pool[i].available = 1;
 167:le_phy.c      **** }
 168:le_phy.c      **** 
 169:le_phy.c      **** // clear a buffer for new data
 170:le_phy.c      **** static void buffer_clear(le_rx_t *buf) {
 171:le_phy.c      **** 	buf->pos = 0;
 172:le_phy.c      **** 	buf->size = 0;
 173:le_phy.c      **** 	memset(buf->data, 0, sizeof(buf->data));
 174:le_phy.c      **** 	buf->rssi_min = INT8_MAX;
 175:le_phy.c      **** 	buf->rssi_max = INT8_MIN;
 176:le_phy.c      **** 	buf->rssi_sum = 0;
 177:le_phy.c      **** }
 178:le_phy.c      **** 
 179:le_phy.c      **** // get a packet buffer
 180:le_phy.c      **** // returns a pointer to a buffer if available
 181:le_phy.c      **** // returns NULL otherwise
 182:le_phy.c      **** static le_rx_t *buffer_get(void) {
 183:le_phy.c      **** 	int i;
 184:le_phy.c      **** 
 185:le_phy.c      **** 	for (i = 0; i < LE_BUFFER_POOL_SIZE; ++i) {
 186:le_phy.c      **** 		if (le_buffer_pool[i].available) {
 187:le_phy.c      **** 			le_buffer_pool[i].available = 0;
 188:le_phy.c      **** 			buffer_clear(&le_buffer_pool[i]);
 189:le_phy.c      **** 			return &le_buffer_pool[i];
 190:le_phy.c      **** 		}
 191:le_phy.c      **** 	}
 192:le_phy.c      **** 
 193:le_phy.c      **** 	return NULL;
 194:le_phy.c      **** }
 195:le_phy.c      **** 
 196:le_phy.c      **** // release a buffer back to the pool
 197:le_phy.c      **** static void buffer_release(le_rx_t *buffer) {
 198:le_phy.c      **** 	buffer->available = 1;
 199:le_phy.c      **** }
 200:le_phy.c      **** 
 201:le_phy.c      **** // clear a connection event
 202:le_phy.c      **** static void reset_conn_event(void) {
 203:le_phy.c      **** 	conn_event.num_packets = 0;
 204:le_phy.c      **** 	conn_event.opened = 0;
 205:le_phy.c      **** }
ARM GAS  /tmp/ccbEq2sz.s 			page 5


 206:le_phy.c      **** 
 207:le_phy.c      **** // finish a connection event
 208:le_phy.c      **** //
 209:le_phy.c      **** // 1) update the anchor point (see details below)
 210:le_phy.c      **** // 2) increment connection event counter
 211:le_phy.c      **** // 3) check if supervision timeout is exceeded
 212:le_phy.c      **** // 4) setup radio for next packet (data or adv if timeout exceeded)
 213:le_phy.c      **** //
 214:le_phy.c      **** // anchor update logic can be summarized thusly:
 215:le_phy.c      **** // 1) if we received two packets, set the connection anchor to the
 216:le_phy.c      **** //    observed value
 217:le_phy.c      **** // 2) if we received one packet, see if it's within ANCHOR_EPISLON
 218:le_phy.c      **** //    microseconds if the expected anchor time. if so, it's the master
 219:le_phy.c      **** //    and we can update the anchor
 220:le_phy.c      **** // 3) if the single packet is a slave or we received zero packets,
 221:le_phy.c      **** //    update the anchor to the estimated value
 222:le_phy.c      **** //
 223:le_phy.c      **** // FIXME this code does not properly handle the case where the initial
 224:le_phy.c      **** // connection transmit window has no received packets
 225:le_phy.c      **** static void finish_conn_event(void) {
 226:le_phy.c      **** 	uint32_t last_anchor = 0;
 227:le_phy.c      **** 	int last_anchor_set = 0;
 228:le_phy.c      ****     debug_printf("finish_conn_event\n");
 229:le_phy.c      **** 	// two packets -- update anchor
 230:le_phy.c      **** 	if (conn_event.num_packets == 2) {
 231:le_phy.c      **** 		last_anchor = conn_event.anchor;
 232:le_phy.c      **** 		last_anchor_set = 1;
 233:le_phy.c      **** 	}
 234:le_phy.c      **** 
 235:le_phy.c      **** 	// if there's one packet, we need to find out if it was the master
 236:le_phy.c      **** 	else if (conn_event.num_packets == 1 && conn.anchor_set) {
 237:le_phy.c      **** 		// calculate the difference between the estimated and observed anchor
 238:le_phy.c      **** 		uint32_t estimated_anchor = conn.last_anchor + conn.conn_interval;
 239:le_phy.c      **** 		uint32_t delta = estimated_anchor - conn_event.anchor;
 240:le_phy.c      **** 		// see whether the observed anchor is within 3 us of the estimate
 241:le_phy.c      **** 		delta += ANCHOR_EPSILON;
 242:le_phy.c      **** 		if (delta < 2 * ANCHOR_EPSILON) {
 243:le_phy.c      **** 			last_anchor = conn_event.anchor;
 244:le_phy.c      **** 			last_anchor_set = 1;
 245:le_phy.c      **** 		}
 246:le_phy.c      **** 	}
 247:le_phy.c      **** 
 248:le_phy.c      **** 	// if we observed a new anchor, set it
 249:le_phy.c      **** 	if (last_anchor_set) {
 250:le_phy.c      **** 		conn.last_anchor = last_anchor;
 251:le_phy.c      **** 		conn.anchor_set = 1;
 252:le_phy.c      **** 	}
 253:le_phy.c      **** 
 254:le_phy.c      **** 	// without a new anchor, estimate the next anchor
 255:le_phy.c      **** 	else if (conn.anchor_set) {
 256:le_phy.c      **** 		conn.last_anchor += conn.conn_interval;
 257:le_phy.c      **** 	}
 258:le_phy.c      **** 
 259:le_phy.c      **** 	else {
 260:le_phy.c      **** 		// FIXME this is totally broken if we receive the slave's packet first
 261:le_phy.c      **** 		conn.last_anchor = conn_event.anchor;
 262:le_phy.c      **** 		conn.last_packet_ts = NOW; // FIXME gross hack
ARM GAS  /tmp/ccbEq2sz.s 			page 6


 263:le_phy.c      **** 	}
 264:le_phy.c      **** 
 265:le_phy.c      **** 	// update last packet for supervision timeout
 266:le_phy.c      **** 	if (conn_event.num_packets > 0) {
 267:le_phy.c      **** 		conn.last_packet_ts = NOW;
 268:le_phy.c      **** 	}
 269:le_phy.c      **** 
 270:le_phy.c      **** 	reset_conn_event();
 271:le_phy.c      **** 
 272:le_phy.c      **** 	// increment connection event counter
 273:le_phy.c      **** 	++conn.conn_event_counter;
 274:le_phy.c      **** 
 275:le_phy.c      **** 	// supervision timeout reached - switch back to advertising
 276:le_phy.c      **** 	if (NOW - conn.last_packet_ts > conn.supervision_timeout) {
 277:le_phy.c      **** 		reset_conn();
 278:le_phy.c      **** 		change_channel();
 279:le_phy.c      **** 	}
 280:le_phy.c      **** 
 281:le_phy.c      **** 	// FIXME - hack to cancel following a connection
 282:le_phy.c      **** 	else if (cancel_follow) {
 283:le_phy.c      **** 		cancel_follow = 0;
 284:le_phy.c      **** 		reset_conn();
 285:le_phy.c      **** 		change_channel();
 286:le_phy.c      **** 	}
 287:le_phy.c      **** 
 288:le_phy.c      **** 	// supervision timeout not reached - hop to next channel
 289:le_phy.c      **** 	else {
 290:le_phy.c      **** 		timer1_set_match(conn.last_anchor + conn.conn_interval - RX_WARMUP_TIME);
 291:le_phy.c      **** 	}
 292:le_phy.c      **** }
 293:le_phy.c      **** 
 294:le_phy.c      **** // DMA handler
 295:le_phy.c      **** // called once per byte. handles all incoming data, but only minimally
 296:le_phy.c      **** // processes received data. at the end of a packet, it enqueues the
 297:le_phy.c      **** // received packet, fetches a new buffer, and restarts RX.
 298:le_phy.c      **** void le_DMA_IRQHandler(void) {
 299:le_phy.c      ****     debug_printf("le_DMA_IRQHandler\n");
 300:le_phy.c      **** 	unsigned pos;
 301:le_phy.c      **** 	int8_t rssi;
 302:le_phy.c      **** 	uint32_t timestamp = NOW; // sampled early for most accurate measurement
 303:le_phy.c      **** 
 304:le_phy.c      **** 	// channel 0
 305:le_phy.c      **** 	if (DMACIntStat & (1 << 0)) {
 306:le_phy.c      **** 		// terminal count - byte received
 307:le_phy.c      **** 		if (DMACIntTCStat & (1 << 0)) {
 308:le_phy.c      **** 			DMACIntTCClear = (1 << 0);
 309:le_phy.c      **** 
 310:le_phy.c      **** 			// poll RSSI
 311:le_phy.c      **** 			rssi = (int8_t)(cc2400_get(RSSI) >> 8);
 312:le_phy.c      **** 			current_rxbuf->rssi_sum += rssi;
 313:le_phy.c      **** 			if (rssi < current_rxbuf->rssi_min) current_rxbuf->rssi_min = rssi;
 314:le_phy.c      **** 			if (rssi > current_rxbuf->rssi_max) current_rxbuf->rssi_max = rssi;
 315:le_phy.c      **** 
 316:le_phy.c      **** 			// grab byte from DMA buffer
 317:le_phy.c      **** 			pos = current_rxbuf->pos;
 318:le_phy.c      **** 			current_rxbuf->data[pos] = le_dma_dest[pos & 1]; // dirty hack
 319:le_phy.c      **** 			pos += 1;
ARM GAS  /tmp/ccbEq2sz.s 			page 7


 320:le_phy.c      **** 			current_rxbuf->pos = pos;
 321:le_phy.c      **** 
 322:le_phy.c      **** 			if (pos == 1) {
 323:le_phy.c      **** 				current_rxbuf->timestamp = timestamp - USEC(8 + 32); // packet starts at preamble
 324:le_phy.c      **** 				current_rxbuf->channel = rf_channel;
 325:le_phy.c      **** 				current_rxbuf->access_address = conn.access_address;
 326:le_phy.c      **** 
 327:le_phy.c      **** 				// data packet received: cancel timeout
 328:le_phy.c      **** 				// new timeout or hop timer will be set at end of packet RX
 329:le_phy.c      **** 				if (btle_channel_index(rf_channel) < 37) {
 330:le_phy.c      **** 					timer1_clear_match();
 331:le_phy.c      **** 				}
 332:le_phy.c      **** 			}
 333:le_phy.c      **** 
 334:le_phy.c      **** 			// get length from header
 335:le_phy.c      **** 			if (pos == 2) {
 336:le_phy.c      **** 				uint8_t length = dewhiten_length(current_rxbuf->channel, current_rxbuf->data[1]);
 337:le_phy.c      **** 				current_rxbuf->size = length + 2 + 3; // two bytes for header and three for CRC
 338:le_phy.c      **** 			}
 339:le_phy.c      **** 
 340:le_phy.c      **** 			// finished packet - state transition
 341:le_phy.c      **** 			if (pos > 2 && pos >= current_rxbuf->size) {
 342:le_phy.c      **** 				// stop the CC2400 before flushing SSP
 343:le_phy.c      **** 				cc2400_strobe(SFSON);
 344:le_phy.c      **** 
 345:le_phy.c      **** 				// stop DMA on this channel and flush SSP
 346:le_phy.c      **** 				DMACC0Config = 0;
 347:le_phy.c      **** 				DMACIntTCClear = (1 << 0); // if we don't clear a second time, data is corrupt
 348:le_phy.c      **** 
 349:le_phy.c      **** 				DIO_SSP_DMACR &= ~SSPDMACR_RXDMAE;
 350:le_phy.c      **** 				while (SSP1SR & SSPSR_RNE) {
 351:le_phy.c      **** 					uint8_t tmp = (uint8_t)DIO_SSP_DR;
 352:le_phy.c      **** 				}
 353:le_phy.c      **** 
 354:le_phy.c      **** 				// TODO error transition on queue_insert
 355:le_phy.c      **** 				queue_insert(&packet_queue, current_rxbuf);
 356:le_phy.c      **** 
 357:le_phy.c      **** 				// track connection events
 358:le_phy.c      **** 				if (btle_channel_index(rf_channel) < 37) {
 359:le_phy.c      **** 					++conn_event.num_packets;
 360:le_phy.c      **** 
 361:le_phy.c      **** 					// first packet: set connection anchor
 362:le_phy.c      **** 					if (conn_event.num_packets == 1) {
 363:le_phy.c      **** 						conn_event.anchor = current_rxbuf->timestamp;
 364:le_phy.c      **** 						timer1_set_match(NOW + IFS_TIMEOUT); // set a timeout for next packet
 365:le_phy.c      **** 					}
 366:le_phy.c      **** 
 367:le_phy.c      **** 					// second packet: close connection event, and set hop timer
 368:le_phy.c      **** 					else if (conn_event.num_packets == 2) {
 369:le_phy.c      **** 						cc2400_strobe(SRFOFF);
 370:le_phy.c      **** 						current_rxbuf = buffer_get();
 371:le_phy.c      **** 						finish_conn_event();
 372:le_phy.c      **** 						return;
 373:le_phy.c      **** 					}
 374:le_phy.c      **** 				}
 375:le_phy.c      **** 
 376:le_phy.c      **** 				// get a new packet
ARM GAS  /tmp/ccbEq2sz.s 			page 8


 377:le_phy.c      **** 				// TODO handle error transition
 378:le_phy.c      **** 				current_rxbuf = buffer_get();
 379:le_phy.c      **** 
 380:le_phy.c      **** 				// restart DMA and SSP
 381:le_phy.c      **** 				le_dma_init();
 382:le_phy.c      **** 				dio_ssp_start();
 383:le_phy.c      **** 
 384:le_phy.c      **** 				// wait for FS_LOCK in background
 385:le_phy.c      **** 				timer1_wait_fs_lock();
 386:le_phy.c      **** 			}
 387:le_phy.c      **** 		}
 388:le_phy.c      **** 
 389:le_phy.c      **** 		// error - transition to error state
 390:le_phy.c      **** 		if (DMACIntErrStat & (1 << 0)) {
 391:le_phy.c      **** 			// TODO error state transition
 392:le_phy.c      **** 			DMACIntErrClr = (1 << 0);
 393:le_phy.c      **** 		}
 394:le_phy.c      **** 	}
 395:le_phy.c      **** }
 396:le_phy.c      **** 
 397:le_phy.c      **** static void le_dma_init(void) {
  25              		.loc 1 397 0
  26              		.cfi_startproc
  27              		@ args = 0, pretend = 0, frame = 0
  28              		@ frame_needed = 0, uses_anonymous_args = 0
  29 0000 30B5     		push	{r4, r5, lr}
  30              		.cfi_def_cfa_offset 12
  31              		.cfi_offset 4, -12
  32              		.cfi_offset 5, -8
  33              		.cfi_offset 14, -4
  34              	.LVL0:
 398:le_phy.c      **** 	int i;
 399:le_phy.c      **** 
 400:le_phy.c      **** 	// DMA linked list items
 401:le_phy.c      **** 	typedef struct {
 402:le_phy.c      **** 		uint32_t src;
 403:le_phy.c      **** 		uint32_t dest;
 404:le_phy.c      **** 		uint32_t next_lli;
 405:le_phy.c      **** 		uint32_t control;
 406:le_phy.c      **** 	} dma_lli;
 407:le_phy.c      **** 	static dma_lli le_dma_lli[2];
 408:le_phy.c      **** 
 409:le_phy.c      **** 	for (i = 0; i < 2; ++i) {
 410:le_phy.c      **** 		le_dma_lli[i].src = (uint32_t)&(DIO_SSP_DR);
  35              		.loc 1 410 0
  36 0002 0C4B     		ldr	r3, .L2
 411:le_phy.c      **** 		le_dma_lli[i].dest = (uint32_t)&le_dma_dest[i];
  37              		.loc 1 411 0
  38 0004 0C49     		ldr	r1, .L2+4
 412:le_phy.c      **** 		le_dma_lli[i].next_lli = (uint32_t)&le_dma_lli[1-i]; // two elements pointing back at each other
 413:le_phy.c      **** 		le_dma_lli[i].control = 1 |
  39              		.loc 1 413 0
  40 0006 0D4A     		ldr	r2, .L2+8
 410:le_phy.c      **** 		le_dma_lli[i].dest = (uint32_t)&le_dma_dest[i];
  41              		.loc 1 410 0
  42 0008 0D48     		ldr	r0, .L2+12
 412:le_phy.c      **** 		le_dma_lli[i].next_lli = (uint32_t)&le_dma_lli[1-i]; // two elements pointing back at each other
ARM GAS  /tmp/ccbEq2sz.s 			page 9


  43              		.loc 1 412 0
  44 000a 03F11004 		add	r4, r3, #16
 411:le_phy.c      **** 		le_dma_lli[i].dest = (uint32_t)&le_dma_dest[i];
  45              		.loc 1 411 0
  46 000e 4D1C     		adds	r5, r1, #1
  47              		.loc 1 413 0
  48 0010 DA60     		str	r2, [r3, #12]
  49              	.LVL1:
 410:le_phy.c      **** 		le_dma_lli[i].dest = (uint32_t)&le_dma_dest[i];
  50              		.loc 1 410 0
  51 0012 1860     		str	r0, [r3]
 411:le_phy.c      **** 		le_dma_lli[i].dest = (uint32_t)&le_dma_dest[i];
  52              		.loc 1 411 0
  53 0014 5960     		str	r1, [r3, #4]
 412:le_phy.c      **** 		le_dma_lli[i].next_lli = (uint32_t)&le_dma_lli[1-i]; // two elements pointing back at each other
  54              		.loc 1 412 0
  55 0016 9C60     		str	r4, [r3, #8]
 410:le_phy.c      **** 		le_dma_lli[i].dest = (uint32_t)&le_dma_dest[i];
  56              		.loc 1 410 0
  57 0018 1861     		str	r0, [r3, #16]
  58              		.loc 1 413 0
  59 001a DA61     		str	r2, [r3, #28]
  60              	.LVL2:
 411:le_phy.c      **** 		le_dma_lli[i].dest = (uint32_t)&le_dma_dest[i];
  61              		.loc 1 411 0
  62 001c 5D61     		str	r5, [r3, #20]
 412:le_phy.c      **** 		le_dma_lli[i].next_lli = (uint32_t)&le_dma_lli[1-i]; // two elements pointing back at each other
  63              		.loc 1 412 0
  64 001e 9B61     		str	r3, [r3, #24]
 414:le_phy.c      **** 				(0 << 12) |        // source burst size = 1
 415:le_phy.c      **** 				(0 << 15) |        // destination burst size = 1
 416:le_phy.c      **** 				(0 << 18) |        // source width 8 bits
 417:le_phy.c      **** 				(0 << 21) |        // destination width 8 bits
 418:le_phy.c      **** 				DMACCxControl_I;   // terminal count interrupt enable
 419:le_phy.c      **** 	}
 420:le_phy.c      **** 
 421:le_phy.c      **** 	// configure DMA channel 0
 422:le_phy.c      **** 	DMACC0SrcAddr = le_dma_lli[0].src;
  65              		.loc 1 422 0
  66 0020 084B     		ldr	r3, .L2+16
  67 0022 1860     		str	r0, [r3]
 423:le_phy.c      **** 	DMACC0DestAddr = le_dma_lli[0].dest;
  68              		.loc 1 423 0
  69 0024 5960     		str	r1, [r3, #4]
 424:le_phy.c      **** 	DMACC0LLI = le_dma_lli[0].next_lli;
  70              		.loc 1 424 0
  71 0026 9C60     		str	r4, [r3, #8]
 425:le_phy.c      **** 	DMACC0Control = le_dma_lli[0].control;
  72              		.loc 1 425 0
  73 0028 DA60     		str	r2, [r3, #12]
 426:le_phy.c      **** 	DMACC0Config =
  74              		.loc 1 426 0
  75 002a 4DF20602 		movw	r2, #53254
  76 002e 1A61     		str	r2, [r3, #16]
  77 0030 30BD     		pop	{r4, r5, pc}
  78              	.L3:
  79 0032 00BF     		.align	2
ARM GAS  /tmp/ccbEq2sz.s 			page 10


  80              	.L2:
  81 0034 00000000 		.word	.LANCHOR0
  82 0038 00000000 		.word	le_dma_dest
  83 003c 01000080 		.word	-2147483647
  84 0040 08000340 		.word	1073938440
  85 0044 00410050 		.word	1342193920
  86              		.cfi_endproc
  87              	.LFE8:
  89              		.section	.text.timer1_set_match,"ax",%progbits
  90              		.align	1
  91              		.syntax unified
  92              		.thumb
  93              		.thumb_func
  94              		.fpu softvfp
  96              	timer1_set_match:
  97              	.LFB15:
 427:le_phy.c      **** 			DIO_SSP_SRC |
 428:le_phy.c      **** 			(0x2 << 11) |     // peripheral to memory
 429:le_phy.c      **** 			DMACCxConfig_IE | // allow error interrupts
 430:le_phy.c      **** 			DMACCxConfig_ITC; // allow terminal count interrupts
 431:le_phy.c      **** }
 432:le_phy.c      **** 
 433:le_phy.c      **** // initalize USB, SSP, and DMA
 434:le_phy.c      **** static void le_sys_init(void) {
 435:le_phy.c      **** 	usb_queue_init(); // USB FIFO FIXME replace with safer queue
 436:le_phy.c      **** 	dio_ssp_init();   // init SSP and raise !CS (self-routed GPIO)
 437:le_phy.c      **** 	le_dma_init();    // prepare DMA + interrupts
 438:le_phy.c      **** 	dio_ssp_start();  // enable SSP + DMA
 439:le_phy.c      **** }
 440:le_phy.c      **** 
 441:le_phy.c      **** // initialize RF and strobe FSON
 442:le_phy.c      **** static void le_cc2400_init_rf(void) {
 443:le_phy.c      **** 	u16 grmdm, mdmctrl;
 444:le_phy.c      **** 	uint32_t sync = rbit(conn.access_address);
 445:le_phy.c      **** 
 446:le_phy.c      **** 	mdmctrl = 0x0040; // 250 kHz frequency deviation
 447:le_phy.c      **** 	grmdm = 0x44E1; // un-buffered mode, packet w/ sync word detection
 448:le_phy.c      **** 	// 0 10 00 1 001 11 0 00 0 1
 449:le_phy.c      **** 	//   |  |  | |   |  +--------> CRC off
 450:le_phy.c      **** 	//   |  |  | |   +-----------> sync word: 32 MSB bits of SYNC_WORD
 451:le_phy.c      **** 	//   |  |  | +---------------> 1 preamble byte of 01010101
 452:le_phy.c      **** 	//   |  |  +-----------------> packet mode
 453:le_phy.c      **** 	//   |  +--------------------> un-buffered mode
 454:le_phy.c      **** 	//   +-----------------------> sync error bits: 2
 455:le_phy.c      **** 
 456:le_phy.c      **** 	cc2400_set(MANAND,  0x7ffe);
 457:le_phy.c      **** 	cc2400_set(LMTST,   0x2b22);
 458:le_phy.c      **** 
 459:le_phy.c      **** 	cc2400_set(MDMTST0, 0x124b);
 460:le_phy.c      **** 	// 1      2      4b
 461:le_phy.c      **** 	// 00 0 1 0 0 10 01001011
 462:le_phy.c      **** 	//    | | | | |  +---------> AFC_DELTA = ??
 463:le_phy.c      **** 	//    | | | | +------------> AFC settling = 4 pairs (8 bit preamble)
 464:le_phy.c      **** 	//    | | | +--------------> no AFC adjust on packet
 465:le_phy.c      **** 	//    | | +----------------> do not invert data
 466:le_phy.c      **** 	//    | +------------------> TX IF freq 1 0Hz
 467:le_phy.c      **** 	//    +--------------------> PRNG off
ARM GAS  /tmp/ccbEq2sz.s 			page 11


 468:le_phy.c      **** 	//
 469:le_phy.c      **** 	// ref: CC2400 datasheet page 67
 470:le_phy.c      **** 	// AFC settling explained page 41/42
 471:le_phy.c      **** 
 472:le_phy.c      **** 	cc2400_set(GRMDM,   grmdm);
 473:le_phy.c      **** 
 474:le_phy.c      **** 	cc2400_set(SYNCL,   sync & 0xffff);
 475:le_phy.c      **** 	cc2400_set(SYNCH,   (sync >> 16) & 0xffff);
 476:le_phy.c      **** 
 477:le_phy.c      **** 	cc2400_set(FSDIV,   rf_channel - 1); // 1 MHz IF
 478:le_phy.c      **** 	cc2400_set(MDMCTRL, mdmctrl);
 479:le_phy.c      **** 
 480:le_phy.c      **** 	// XOSC16M should always be stable, but leave this test anyway
 481:le_phy.c      **** 	while (!(cc2400_status() & XOSC16M_STABLE));
 482:le_phy.c      **** 
 483:le_phy.c      **** 	// wait for FS_LOCK in background
 484:le_phy.c      **** 	cc2400_strobe(SFSON);
 485:le_phy.c      **** 	timer1_wait_fs_lock();
 486:le_phy.c      **** }
 487:le_phy.c      **** 
 488:le_phy.c      **** // strobe RX and enable PA
 489:le_phy.c      **** static void le_cc2400_strobe_rx(void) {
 490:le_phy.c      **** 	cc2400_strobe(SRX);
 491:le_phy.c      **** #ifdef UBERTOOTH_ONE
 492:le_phy.c      **** 	PAEN_SET;
 493:le_phy.c      **** 	HGM_SET;
 494:le_phy.c      **** #endif
 495:le_phy.c      **** }
 496:le_phy.c      **** 
 497:le_phy.c      **** // change channel and init rx
 498:le_phy.c      **** static void change_channel(void) {
 499:le_phy.c      **** 	uint8_t channel_idx = 0;
 500:le_phy.c      **** 
 501:le_phy.c      **** 	cc2400_strobe(SRFOFF);
 502:le_phy.c      **** 
 503:le_phy.c      **** 	// stop DMA and flush SSP
 504:le_phy.c      **** 	DIO_SSP_DMACR &= ~SSPDMACR_RXDMAE;
 505:le_phy.c      **** 	while (SSP1SR & SSPSR_RNE) {
 506:le_phy.c      **** 		uint8_t tmp = (uint8_t)DIO_SSP_DR;
 507:le_phy.c      **** 	}
 508:le_phy.c      **** 
 509:le_phy.c      **** 	buffer_clear(current_rxbuf);
 510:le_phy.c      **** 	le_dma_init();
 511:le_phy.c      **** 	dio_ssp_start();
 512:le_phy.c      **** 
 513:le_phy.c      **** 	if (conn.access_address == ADVERTISING_AA) {
 514:le_phy.c      **** 		// FIXME
 515:le_phy.c      **** 		switch (le_adv_channel) {
 516:le_phy.c      **** 			case 2402: channel_idx = 37; break;
 517:le_phy.c      **** 			case 2426: channel_idx = 38; break;
 518:le_phy.c      **** 			case 2480: channel_idx = 39; break;
 519:le_phy.c      **** 			default:   channel_idx = 37; break;
 520:le_phy.c      **** 		}
 521:le_phy.c      **** 	} else {
 522:le_phy.c      **** 		conn.channel_idx = (conn.channel_idx + conn.hop_increment) % 37;
 523:le_phy.c      **** 		channel_idx = le_map_channel(conn.channel_idx, &conn.remapping);
 524:le_phy.c      **** 	}
ARM GAS  /tmp/ccbEq2sz.s 			page 12


 525:le_phy.c      **** 
 526:le_phy.c      **** 	rf_channel = btle_channel_index_to_phys(channel_idx);
 527:le_phy.c      **** 	le_cc2400_init_rf();
 528:le_phy.c      **** }
 529:le_phy.c      **** 
 530:le_phy.c      **** ///////
 531:le_phy.c      **** // timer stuff
 532:le_phy.c      **** 
 533:le_phy.c      **** static void timer1_start(void) {
 534:le_phy.c      **** 	T1TCR = TCR_Counter_Reset;
 535:le_phy.c      **** 	T1PR = 4; // 100 ns
 536:le_phy.c      **** 	T1TCR = TCR_Counter_Enable;
 537:le_phy.c      **** 
 538:le_phy.c      **** 	// set up interrupt handler
 539:le_phy.c      **** 	ISER0 = ISER0_ISE_TIMER1;
 540:le_phy.c      **** }
 541:le_phy.c      **** 
 542:le_phy.c      **** static void timer1_stop(void) {
 543:le_phy.c      **** 	T1TCR = TCR_Counter_Reset;
 544:le_phy.c      **** 
 545:le_phy.c      **** 	// clear interrupt handler
 546:le_phy.c      **** 	ICER0 = ICER0_ICE_TIMER1;
 547:le_phy.c      **** }
 548:le_phy.c      **** 
 549:le_phy.c      **** static void timer1_set_match(uint32_t match) {
  98              		.loc 1 549 0
  99              		.cfi_startproc
 100              		@ args = 0, pretend = 0, frame = 0
 101              		@ frame_needed = 0, uses_anonymous_args = 0
 102              		@ link register save eliminated.
 103              	.LVL3:
 550:le_phy.c      **** 	T1MR0 = match;
 104              		.loc 1 550 0
 105 0000 034B     		ldr	r3, .L5
 551:le_phy.c      **** 	T1MCR |= TMCR_MR0I;
 106              		.loc 1 551 0
 107 0002 044A     		ldr	r2, .L5+4
 550:le_phy.c      **** 	T1MR0 = match;
 108              		.loc 1 550 0
 109 0004 1860     		str	r0, [r3]
 110              		.loc 1 551 0
 111 0006 1368     		ldr	r3, [r2]
 112 0008 43F00103 		orr	r3, r3, #1
 113 000c 1360     		str	r3, [r2]
 114 000e 7047     		bx	lr
 115              	.L6:
 116              		.align	2
 117              	.L5:
 118 0010 18800040 		.word	1073774616
 119 0014 14800040 		.word	1073774612
 120              		.cfi_endproc
 121              	.LFE15:
 123              		.section	.text.timer1_wait_fs_lock,"ax",%progbits
 124              		.align	1
 125              		.syntax unified
 126              		.thumb
 127              		.thumb_func
ARM GAS  /tmp/ccbEq2sz.s 			page 13


 128              		.fpu softvfp
 130              	timer1_wait_fs_lock:
 131              	.LFB17:
 552:le_phy.c      **** }
 553:le_phy.c      **** 
 554:le_phy.c      **** static void timer1_clear_match(void) {
 555:le_phy.c      **** 	T1MCR &= ~TMCR_MR0I;
 556:le_phy.c      **** }
 557:le_phy.c      **** 
 558:le_phy.c      **** static void timer1_wait_fs_lock(void) {
 132              		.loc 1 558 0
 133              		.cfi_startproc
 134              		@ args = 0, pretend = 0, frame = 0
 135              		@ frame_needed = 0, uses_anonymous_args = 0
 136              		@ link register save eliminated.
 559:le_phy.c      **** 	T1MR2 = NOW + USEC(3);
 137              		.loc 1 559 0
 138 0000 054B     		ldr	r3, .L8
 139 0002 064A     		ldr	r2, .L8+4
 140 0004 1B68     		ldr	r3, [r3]
 141 0006 1E33     		adds	r3, r3, #30
 142 0008 1360     		str	r3, [r2]
 560:le_phy.c      **** 	T1MCR |= TMCR_MR2I;
 143              		.loc 1 560 0
 144 000a 52F80C3C 		ldr	r3, [r2, #-12]
 145 000e 43F04003 		orr	r3, r3, #64
 146 0012 42F80C3C 		str	r3, [r2, #-12]
 147 0016 7047     		bx	lr
 148              	.L9:
 149              		.align	2
 150              	.L8:
 151 0018 08800040 		.word	1073774600
 152 001c 20800040 		.word	1073774624
 153              		.cfi_endproc
 154              	.LFE17:
 156              		.section	.text.extract_field,"ax",%progbits
 157              		.align	1
 158              		.syntax unified
 159              		.thumb
 160              		.thumb_func
 161              		.fpu softvfp
 163              	extract_field:
 164              	.LFB23:
 561:le_phy.c      **** }
 562:le_phy.c      **** 
 563:le_phy.c      **** static void timer1_cancel_fs_lock(void) {
 564:le_phy.c      **** 	T1MCR &= ~TMCR_MR2I;
 565:le_phy.c      **** }
 566:le_phy.c      **** 
 567:le_phy.c      **** void TIMER1_IRQHandler(void) {
 568:le_phy.c      **** 	// MR0: connection events
 569:le_phy.c      **** 	if (T1IR & TIR_MR0_Interrupt) {
 570:le_phy.c      **** 		// ack the interrupt
 571:le_phy.c      **** 		T1IR = TIR_MR0_Interrupt;
 572:le_phy.c      **** 
 573:le_phy.c      **** 		// connection update procedure
 574:le_phy.c      **** 		if (conn.conn_update_pending &&
ARM GAS  /tmp/ccbEq2sz.s 			page 14


 575:le_phy.c      **** 				conn.conn_event_counter == conn.conn_update_instant) {
 576:le_phy.c      **** 
 577:le_phy.c      **** 			// on the first past through, handle the transmit window
 578:le_phy.c      **** 			// offset. if there's no offset, skip down to else block
 579:le_phy.c      **** 			if (!conn_event.opened && conn.win_offset > 0) {
 580:le_phy.c      **** 				timer1_set_match(conn.last_anchor + conn.conn_interval +
 581:le_phy.c      **** 						conn.win_offset - RX_WARMUP_TIME);
 582:le_phy.c      **** 				conn_event.opened = 1;
 583:le_phy.c      **** 			}
 584:le_phy.c      **** 
 585:le_phy.c      **** 			// after the transmit window offset, or if there is no
 586:le_phy.c      **** 			// transmit window, set a packet timeout and change the
 587:le_phy.c      **** 			// channel
 588:le_phy.c      **** 			else { // conn_event.opened || conn.win_offset == 0
 589:le_phy.c      **** 				conn_event.opened = 1;
 590:le_phy.c      **** 
 591:le_phy.c      **** 				// this is like a new connection, so set all values
 592:le_phy.c      **** 				// accordingly
 593:le_phy.c      **** 				conn.anchor_set = 0;
 594:le_phy.c      **** 				conn.conn_interval = conn.conn_update_pending_interval;
 595:le_phy.c      **** 				conn.supervision_timeout = conn.conn_update_pending_supervision_timeout;
 596:le_phy.c      **** 				conn.conn_update_pending = 0;
 597:le_phy.c      **** 
 598:le_phy.c      **** 				// timeout after conn window + max packet length
 599:le_phy.c      **** 				timer1_set_match(conn.last_anchor + conn.conn_interval +
 600:le_phy.c      **** 						conn.win_offset + conn.win_size + USEC(2120));
 601:le_phy.c      **** 				change_channel();
 602:le_phy.c      **** 			}
 603:le_phy.c      **** 			return;
 604:le_phy.c      **** 		}
 605:le_phy.c      **** 
 606:le_phy.c      **** 		// channel map update
 607:le_phy.c      **** 		if (conn.channel_map_update_pending &&
 608:le_phy.c      **** 				conn.conn_event_counter == conn.channel_map_update_instant) {
 609:le_phy.c      **** 			conn.remapping = conn.pending_remapping;
 610:le_phy.c      **** 			conn.channel_map_update_pending = 0;
 611:le_phy.c      **** 		}
 612:le_phy.c      **** 
 613:le_phy.c      **** 		// new connection event: set timeout and change channel
 614:le_phy.c      **** 		if (!conn_event.opened) {
 615:le_phy.c      **** 			conn_event.opened = 1;
 616:le_phy.c      **** 			// timeout is max packet length + warmup time (slack)
 617:le_phy.c      **** 			timer1_set_match(NOW + USEC(2120) + RX_WARMUP_TIME);
 618:le_phy.c      **** 			change_channel();
 619:le_phy.c      **** 		}
 620:le_phy.c      **** 
 621:le_phy.c      **** 		// regular connection event, plus timeout from connection updates
 622:le_phy.c      **** 		// FIXME connection update timeouts and initial connection
 623:le_phy.c      **** 		// timeouts need to be handled differently: they should have a
 624:le_phy.c      **** 		// full window until the packets from the new connection are
 625:le_phy.c      **** 		// captured and a new anchor is set.
 626:le_phy.c      **** 		else {
 627:le_phy.c      **** 			// new connection event: set timeout and change channel
 628:le_phy.c      **** 			if (!conn_event.opened) {
 629:le_phy.c      **** 				conn_event.opened = 1;
 630:le_phy.c      **** 
 631:le_phy.c      **** 				// timeout is max packet length + warmup time (slack)
ARM GAS  /tmp/ccbEq2sz.s 			page 15


 632:le_phy.c      **** 				timer1_set_match(NOW + USEC(2120) + RX_WARMUP_TIME);
 633:le_phy.c      **** 				change_channel();
 634:le_phy.c      **** 			}
 635:le_phy.c      **** 
 636:le_phy.c      **** 			// timeout: close connection event and set timer for next hop
 637:le_phy.c      **** 			else {
 638:le_phy.c      **** 				finish_conn_event();
 639:le_phy.c      **** 			}
 640:le_phy.c      **** 		}
 641:le_phy.c      **** 	}
 642:le_phy.c      **** 
 643:le_phy.c      **** 	// LEDs
 644:le_phy.c      **** 	if (T1IR & TIR_MR1_Interrupt) {
 645:le_phy.c      **** 		T1IR = TIR_MR1_Interrupt;
 646:le_phy.c      **** 		T1MCR &= ~TMCR_MR1I;
 647:le_phy.c      **** 
 648:le_phy.c      **** 		TXLED_CLR;
 649:le_phy.c      **** 		RXLED_CLR;
 650:le_phy.c      **** 		USRLED_CLR;
 651:le_phy.c      **** 	}
 652:le_phy.c      **** 
 653:le_phy.c      **** 	// check FS_LOCK
 654:le_phy.c      **** 	if (T1IR & TIR_MR2_Interrupt) {
 655:le_phy.c      **** 		T1IR = TIR_MR2_Interrupt;
 656:le_phy.c      **** 
 657:le_phy.c      **** 		// if FS is locked, strobe RX and clear interrupt
 658:le_phy.c      **** 		if (cc2400_status() & FS_LOCK) {
 659:le_phy.c      **** 			le_cc2400_strobe_rx();
 660:le_phy.c      **** 			T1MCR &= ~TMCR_MR2I;
 661:le_phy.c      **** 		}
 662:le_phy.c      **** 
 663:le_phy.c      **** 		// if FS is not locked, check again in 3 us
 664:le_phy.c      **** 		else {
 665:le_phy.c      **** 			timer1_wait_fs_lock();
 666:le_phy.c      **** 		}
 667:le_phy.c      **** 	}
 668:le_phy.c      **** }
 669:le_phy.c      **** 
 670:le_phy.c      **** static void blink(int tx, int rx, int usr) {
 671:le_phy.c      **** 	if (tx)
 672:le_phy.c      **** 		TXLED_SET;
 673:le_phy.c      **** 	if (rx)
 674:le_phy.c      **** 		RXLED_SET;
 675:le_phy.c      **** 	if (usr)
 676:le_phy.c      **** 		USRLED_SET;
 677:le_phy.c      **** 
 678:le_phy.c      **** 	// blink for 10 ms
 679:le_phy.c      **** 	T1MR1 = NOW + MSEC(10);
 680:le_phy.c      **** 	T1MCR |= TMCR_MR1I;
 681:le_phy.c      **** }
 682:le_phy.c      **** 
 683:le_phy.c      **** // helper function to dewhiten length from whitened data (only used
 684:le_phy.c      **** // during DMA)
 685:le_phy.c      **** static uint8_t dewhiten_length(unsigned channel, uint8_t data) {
 686:le_phy.c      **** 	unsigned int i, bit;
 687:le_phy.c      **** 	int idx = whitening_index[btle_channel_index(channel)];
 688:le_phy.c      **** 	uint8_t out = 0;
ARM GAS  /tmp/ccbEq2sz.s 			page 16


 689:le_phy.c      **** 
 690:le_phy.c      **** 	// length is second byte of packet
 691:le_phy.c      **** 	idx = (idx + 8) % sizeof(whitening);
 692:le_phy.c      **** 
 693:le_phy.c      **** 	for (i = 0; i < 8; ++i) {
 694:le_phy.c      **** 		bit = (data >> (7-i)) & 1;
 695:le_phy.c      **** 		bit ^= whitening[idx];
 696:le_phy.c      **** 		idx = (idx + 1) % sizeof(whitening);
 697:le_phy.c      **** 		out |= bit << i;
 698:le_phy.c      **** 	}
 699:le_phy.c      **** 
 700:le_phy.c      **** 	return out;
 701:le_phy.c      **** }
 702:le_phy.c      **** 
 703:le_phy.c      **** // enqueue a packet for USB
 704:le_phy.c      **** // FIXME this is cribbed from existing code, but does not have enough
 705:le_phy.c      **** // room for larger LE packets
 706:le_phy.c      **** static int usb_enqueue_le(le_rx_t *packet) {
 707:le_phy.c      **** 	usb_pkt_rx* f = usb_enqueue();
 708:le_phy.c      **** 
 709:le_phy.c      **** 	// fail if queue is full
 710:le_phy.c      **** 	if (f == NULL) {
 711:le_phy.c      **** 		return 0;
 712:le_phy.c      **** 	}
 713:le_phy.c      **** 
 714:le_phy.c      **** 	f->pkt_type = LE_PACKET;
 715:le_phy.c      **** 
 716:le_phy.c      **** 	f->clkn_high = 0;
 717:le_phy.c      **** 	f->clk100ns = packet->timestamp;
 718:le_phy.c      **** 
 719:le_phy.c      **** 	f->channel = (uint8_t)((packet->channel - 2402) & 0xff);
 720:le_phy.c      **** 	f->rssi_avg = packet->rssi_sum / packet->size;
 721:le_phy.c      **** 	f->rssi_min = packet->rssi_min;
 722:le_phy.c      **** 	f->rssi_max = packet->rssi_max;
 723:le_phy.c      **** 	f->rssi_count = 0;
 724:le_phy.c      **** 
 725:le_phy.c      **** 	memcpy(f->data, &packet->access_address, 4);
 726:le_phy.c      **** 	memcpy(f->data+4, packet->data, DMA_SIZE-4);
 727:le_phy.c      **** 
 728:le_phy.c      **** 	f->status = 0;
 729:le_phy.c      **** 
 730:le_phy.c      **** 	return 1;
 731:le_phy.c      **** }
 732:le_phy.c      **** 
 733:le_phy.c      **** static unsigned extract_field(le_rx_t *buf, size_t offset, unsigned size) {
 165              		.loc 1 733 0
 166              		.cfi_startproc
 167              		@ args = 0, pretend = 0, frame = 0
 168              		@ frame_needed = 0, uses_anonymous_args = 0
 169              	.LVL4:
 170 0000 30B5     		push	{r4, r5, lr}
 171              		.cfi_def_cfa_offset 12
 172              		.cfi_offset 4, -12
 173              		.cfi_offset 5, -8
 174              		.cfi_offset 14, -4
 175              	.LVL5:
 734:le_phy.c      **** 	unsigned i, ret = 0;
ARM GAS  /tmp/ccbEq2sz.s 			page 17


 176              		.loc 1 734 0
 177 0002 0024     		movs	r4, #0
 735:le_phy.c      **** 
 736:le_phy.c      **** 	// this could just be replaced by memcpy... right?
 737:le_phy.c      **** 	for (i = 0; i < size; ++i)
 178              		.loc 1 737 0
 179 0004 2346     		mov	r3, r4
 738:le_phy.c      **** 		ret |= buf->data[offset + i] << (i*8);
 180              		.loc 1 738 0
 181 0006 0144     		add	r1, r1, r0
 182              	.LVL6:
 183              	.L11:
 737:le_phy.c      **** 		ret |= buf->data[offset + i] << (i*8);
 184              		.loc 1 737 0 discriminator 1
 185 0008 9342     		cmp	r3, r2
 186 000a 01D1     		bne	.L12
 739:le_phy.c      **** 
 740:le_phy.c      **** 	return ret;
 741:le_phy.c      **** }
 187              		.loc 1 741 0
 188 000c 2046     		mov	r0, r4
 189 000e 30BD     		pop	{r4, r5, pc}
 190              	.LVL7:
 191              	.L12:
 738:le_phy.c      **** 
 192              		.loc 1 738 0 discriminator 3
 193 0010 CD5C     		ldrb	r5, [r1, r3]	@ zero_extendqisi2
 194 0012 D800     		lsls	r0, r3, #3
 195 0014 8540     		lsls	r5, r5, r0
 196 0016 2C43     		orrs	r4, r4, r5
 197              	.LVL8:
 737:le_phy.c      **** 		ret |= buf->data[offset + i] << (i*8);
 198              		.loc 1 737 0 discriminator 3
 199 0018 0133     		adds	r3, r3, #1
 200              	.LVL9:
 201 001a F5E7     		b	.L11
 202              		.cfi_endproc
 203              	.LFE23:
 205              		.section	.text.bd_addr_cmp,"ax",%progbits
 206              		.align	1
 207              		.syntax unified
 208              		.thumb
 209              		.thumb_func
 210              		.fpu softvfp
 212              	bd_addr_cmp:
 213              	.LFB28:
 742:le_phy.c      **** 
 743:le_phy.c      **** static void le_connect_handler(le_rx_t *buf) {
 744:le_phy.c      **** 	uint32_t aa, crc_init;
 745:le_phy.c      **** 	uint32_t win_size, max_win_size;
 746:le_phy.c      **** 
 747:le_phy.c      **** 	if (!le.do_follow)
 748:le_phy.c      **** 		return;
 749:le_phy.c      **** 
 750:le_phy.c      **** 	if (buf->size != 2 + 6 + 6 + 22 + 3)
 751:le_phy.c      **** 		return;
 752:le_phy.c      **** 
ARM GAS  /tmp/ccbEq2sz.s 			page 18


 753:le_phy.c      **** 	// FIXME ugly hack
 754:le_phy.c      **** 	if (cancel_follow)
 755:le_phy.c      **** 		cancel_follow = 0;
 756:le_phy.c      **** 
 757:le_phy.c      **** 	conn.access_address     = extract_field(buf, 14, 4);
 758:le_phy.c      **** 	conn.crc_init           = extract_field(buf, 18, 3);
 759:le_phy.c      **** 	conn.crc_init_reversed  = rbit(conn.crc_init);
 760:le_phy.c      **** 	conn.win_size           = extract_field(buf, 21, 1);
 761:le_phy.c      **** 	conn.win_offset         = extract_field(buf, 22, 2);
 762:le_phy.c      **** 	conn.conn_interval      = extract_field(buf, 24, 2);
 763:le_phy.c      **** 	conn.supervision_timeout = extract_field(buf, 28, 2);
 764:le_phy.c      **** 	conn.hop_increment      = extract_field(buf, 35, 1) & 0x1f;
 765:le_phy.c      **** 
 766:le_phy.c      **** 	if (conn.conn_interval < 6 || conn.conn_interval > 3200) {
 767:le_phy.c      **** 		goto err_out;
 768:le_phy.c      **** 	} else {
 769:le_phy.c      **** 		conn.conn_interval *= USEC(1250);
 770:le_phy.c      **** 	}
 771:le_phy.c      **** 
 772:le_phy.c      **** 	// window offset is in range [0, conn_interval]
 773:le_phy.c      **** 	conn.win_offset *= USEC(1250);
 774:le_phy.c      **** 	if (conn.win_offset > conn.conn_interval)
 775:le_phy.c      **** 		goto err_out;
 776:le_phy.c      **** 
 777:le_phy.c      **** 	// win size is in range [1.25 ms, MIN(10 ms, conn_interval - 1.25 ms)]
 778:le_phy.c      **** 	win_size = conn.win_size * USEC(1250);
 779:le_phy.c      **** 	max_win_size = conn.conn_interval - USEC(1250);
 780:le_phy.c      **** 	if (max_win_size > MSEC(10))
 781:le_phy.c      **** 		max_win_size = MSEC(10);
 782:le_phy.c      **** 	if (win_size < USEC(1250) || win_size > max_win_size)
 783:le_phy.c      **** 		goto err_out;
 784:le_phy.c      **** 
 785:le_phy.c      **** 	// The connSupervisionTimeout shall be a multiple of 10 ms in the
 786:le_phy.c      **** 	// range of 100 ms to 32.0 s and it shall be larger than (1 +
 787:le_phy.c      **** 	// connSlaveLatency) * connInterval * 2
 788:le_phy.c      **** 	conn.supervision_timeout *= MSEC(10);
 789:le_phy.c      **** 	if (conn.supervision_timeout < MSEC(100) || conn.supervision_timeout > SEC(32))
 790:le_phy.c      **** 		goto err_out;
 791:le_phy.c      **** 	// TODO handle slave latency
 792:le_phy.c      **** 
 793:le_phy.c      **** 	le_parse_channel_map(&buf->data[30], &conn.remapping);
 794:le_phy.c      **** 	if (conn.remapping.total_channels == 0)
 795:le_phy.c      **** 		goto err_out;
 796:le_phy.c      **** 
 797:le_phy.c      **** 	// cancel RX on advertising channel
 798:le_phy.c      **** 	timer1_cancel_fs_lock();
 799:le_phy.c      **** 
 800:le_phy.c      **** 	reset_conn_event();
 801:le_phy.c      **** 	timer1_set_match(buf->timestamp + PACKET_DURATION(buf) +
 802:le_phy.c      **** 			conn.win_offset + USEC(1250) - RX_WARMUP_TIME);
 803:le_phy.c      **** 	return;
 804:le_phy.c      **** 
 805:le_phy.c      **** 	// error condition: reset conn and return
 806:le_phy.c      **** err_out:
 807:le_phy.c      **** 	reset_conn();
 808:le_phy.c      **** }
 809:le_phy.c      **** 
ARM GAS  /tmp/ccbEq2sz.s 			page 19


 810:le_phy.c      **** static void connection_update_handler(le_rx_t *buf) {
 811:le_phy.c      **** 	conn.win_size            = extract_field(buf, 3, 1);
 812:le_phy.c      **** 	conn.win_offset          = extract_field(buf, 4, 2);
 813:le_phy.c      **** 	conn.conn_update_pending_interval = extract_field(buf, 6, 2);
 814:le_phy.c      **** 	conn.conn_update_pending_supervision_timeout = extract_field(buf, 10, 2);
 815:le_phy.c      **** 	conn.conn_update_instant = extract_field(buf, 12, 2);
 816:le_phy.c      **** 
 817:le_phy.c      **** 	// TODO check for invalid values. XXX what do we even do in that
 818:le_phy.c      **** 	// case? we will probably drop the connection, but at least it's on
 819:le_phy.c      **** 	// our own terms and not some impossibly long supervision timeout.
 820:le_phy.c      **** 	conn.win_size   *= USEC(1250);
 821:le_phy.c      **** 	conn.win_offset *= USEC(1250);
 822:le_phy.c      **** 	conn.conn_update_pending_interval *= USEC(1250);
 823:le_phy.c      **** 	conn.conn_update_pending_supervision_timeout *= MSEC(10);
 824:le_phy.c      **** 
 825:le_phy.c      **** 	conn.conn_update_pending = 1;
 826:le_phy.c      **** }
 827:le_phy.c      **** 
 828:le_phy.c      **** static void channel_map_update_handler(le_rx_t *buf) {
 829:le_phy.c      **** 	conn.channel_map_update_pending = 1;
 830:le_phy.c      **** 	conn.channel_map_update_instant = extract_field(buf, 8, 2);
 831:le_phy.c      **** 	le_parse_channel_map(&buf->data[3], &conn.pending_remapping);
 832:le_phy.c      **** }
 833:le_phy.c      **** 
 834:le_phy.c      **** static void packet_handler(le_rx_t *buf) {
 835:le_phy.c      **** 	// advertising packet
 836:le_phy.c      **** 	if (btle_channel_index(buf->channel) >= 37) {
 837:le_phy.c      **** 		switch (buf->data[0] & 0xf) {
 838:le_phy.c      **** 			// CONNECT_REQ
 839:le_phy.c      **** 			case 0x05:
 840:le_phy.c      **** 				// TODO validate length
 841:le_phy.c      **** 				le_connect_handler(buf);
 842:le_phy.c      **** 				break;
 843:le_phy.c      **** 		}
 844:le_phy.c      **** 	}
 845:le_phy.c      **** 
 846:le_phy.c      **** 	// data packet
 847:le_phy.c      **** 	else {
 848:le_phy.c      **** 		// LL control PDU
 849:le_phy.c      **** 		if ((buf->data[0] & 0b11) == 0b11 && buf->data[1] > 0) {
 850:le_phy.c      **** 			switch (buf->data[2]) {
 851:le_phy.c      **** 				// LE_CONNECTION_UPDATE_REQ -- update connection parameters
 852:le_phy.c      **** 				case 0x0:
 853:le_phy.c      **** 					if (buf->data[1] == 12)
 854:le_phy.c      **** 						connection_update_handler(buf);
 855:le_phy.c      **** 					break;
 856:le_phy.c      **** 
 857:le_phy.c      **** 				// LE_CHANNEL_MAP_REQ -- update channel map
 858:le_phy.c      **** 				case 0x1:
 859:le_phy.c      **** 					if (buf->data[1] == 8)
 860:le_phy.c      **** 						channel_map_update_handler(buf);
 861:le_phy.c      **** 					break;
 862:le_phy.c      **** 			}
 863:le_phy.c      **** 		}
 864:le_phy.c      **** 	}
 865:le_phy.c      **** }
 866:le_phy.c      **** 
ARM GAS  /tmp/ccbEq2sz.s 			page 20


 867:le_phy.c      **** // compare a BD addr against target with mask
 868:le_phy.c      **** static int bd_addr_cmp(uint8_t *bd_addr) {
 214              		.loc 1 868 0
 215              		.cfi_startproc
 216              		@ args = 0, pretend = 0, frame = 0
 217              		@ frame_needed = 0, uses_anonymous_args = 0
 218              	.LVL10:
 219 0000 10B5     		push	{r4, lr}
 220              		.cfi_def_cfa_offset 8
 221              		.cfi_offset 4, -8
 222              		.cfi_offset 14, -4
 223              	.LVL11:
 224 0002 084A     		ldr	r2, .L18
 225 0004 431E     		subs	r3, r0, #1
 226 0006 0530     		adds	r0, r0, #5
 227              	.LVL12:
 228              	.L15:
 869:le_phy.c      **** 	unsigned i;
 870:le_phy.c      **** 	for (i = 0; i < 6; ++i)
 871:le_phy.c      **** 		if ((bd_addr[i] & le.target_mask[i]) != le.target[i])
 229              		.loc 1 871 0
 230 0008 D479     		ldrb	r4, [r2, #7]	@ zero_extendqisi2
 231 000a 13F8011F 		ldrb	r1, [r3, #1]!	@ zero_extendqisi2
 232              	.LVL13:
 233 000e 2140     		ands	r1, r1, r4
 234 0010 12F8014F 		ldrb	r4, [r2, #1]!	@ zero_extendqisi2
 235 0014 8C42     		cmp	r4, r1
 236 0016 03D1     		bne	.L16
 237              	.LVL14:
 870:le_phy.c      **** 		if ((bd_addr[i] & le.target_mask[i]) != le.target[i])
 238              		.loc 1 870 0 discriminator 2
 239 0018 8342     		cmp	r3, r0
 240 001a F5D1     		bne	.L15
 872:le_phy.c      **** 			return 0;
 873:le_phy.c      **** 	return 1;
 241              		.loc 1 873 0
 242 001c 0120     		movs	r0, #1
 243              	.LVL15:
 244 001e 10BD     		pop	{r4, pc}
 245              	.LVL16:
 246              	.L16:
 872:le_phy.c      **** 			return 0;
 247              		.loc 1 872 0
 248 0020 0020     		movs	r0, #0
 874:le_phy.c      **** }
 249              		.loc 1 874 0
 250 0022 10BD     		pop	{r4, pc}
 251              	.L19:
 252              		.align	2
 253              	.L18:
 254 0024 37000000 		.word	le+55
 255              		.cfi_endproc
 256              	.LFE28:
 258              		.section	.text.reset_conn,"ax",%progbits
 259              		.align	1
 260              		.syntax unified
 261              		.thumb
ARM GAS  /tmp/ccbEq2sz.s 			page 21


 262              		.thumb_func
 263              		.fpu softvfp
 265              	reset_conn:
 266              	.LFB0:
 139:le_phy.c      **** 	memset(&conn, 0, sizeof(conn));
 267              		.loc 1 139 0
 268              		.cfi_startproc
 269              		@ args = 0, pretend = 0, frame = 0
 270              		@ frame_needed = 0, uses_anonymous_args = 0
 271 0000 10B5     		push	{r4, lr}
 272              		.cfi_def_cfa_offset 8
 273              		.cfi_offset 4, -8
 274              		.cfi_offset 14, -4
 140:le_phy.c      **** 	conn.access_address = ADVERTISING_AA;
 275              		.loc 1 140 0
 276 0002 054C     		ldr	r4, .L21
 277 0004 4FF4E472 		mov	r2, #456
 278 0008 0021     		movs	r1, #0
 279 000a 04F12000 		add	r0, r4, #32
 280 000e FFF7FEFF 		bl	memset
 281              	.LVL17:
 141:le_phy.c      **** }
 282              		.loc 1 141 0
 283 0012 024B     		ldr	r3, .L21+4
 284 0014 2362     		str	r3, [r4, #32]
 285 0016 10BD     		pop	{r4, pc}
 286              	.L22:
 287              		.align	2
 288              	.L21:
 289 0018 00000000 		.word	.LANCHOR0
 290 001c D6BE898E 		.word	-1903575338
 291              		.cfi_endproc
 292              	.LFE0:
 294              		.section	.text.buffer_get,"ax",%progbits
 295              		.align	1
 296              		.syntax unified
 297              		.thumb
 298              		.thumb_func
 299              		.fpu softvfp
 301              	buffer_get:
 302              	.LFB3:
 182:le_phy.c      **** 	int i;
 303              		.loc 1 182 0
 304              		.cfi_startproc
 305              		@ args = 0, pretend = 0, frame = 0
 306              		@ frame_needed = 0, uses_anonymous_args = 0
 307 0000 70B5     		push	{r4, r5, r6, lr}
 308              		.cfi_def_cfa_offset 16
 309              		.cfi_offset 4, -16
 310              		.cfi_offset 5, -12
 311              		.cfi_offset 6, -8
 312              		.cfi_offset 14, -4
 313              	.LVL18:
 185:le_phy.c      **** 		if (le_buffer_pool[i].available) {
 314              		.loc 1 185 0
 315 0002 0023     		movs	r3, #0
 316 0004 4FF49275 		mov	r5, #292
ARM GAS  /tmp/ccbEq2sz.s 			page 22


 317 0008 124C     		ldr	r4, .L28
 318 000a 04F5F471 		add	r1, r4, #488
 319              	.LVL19:
 320              	.L26:
 321 000e 05FB03F2 		mul	r2, r5, r3
 322 0012 8E18     		adds	r6, r1, r2
 186:le_phy.c      **** 			le_buffer_pool[i].available = 0;
 323              		.loc 1 186 0
 324 0014 D6F81801 		ldr	r0, [r6, #280]
 325 0018 B8B1     		cbz	r0, .L24
 187:le_phy.c      **** 			buffer_clear(&le_buffer_pool[i]);
 326              		.loc 1 187 0
 327 001a 0025     		movs	r5, #0
 328 001c 1444     		add	r4, r4, r2
 329 001e C4F80053 		str	r5, [r4, #768]
 330              	.LVL20:
 331              	.LBB7:
 332              	.LBB8:
 171:le_phy.c      **** 	buf->size = 0;
 333              		.loc 1 171 0
 334 0022 C4F8F052 		str	r5, [r4, #752]
 172:le_phy.c      **** 	memset(buf->data, 0, sizeof(buf->data));
 335              		.loc 1 172 0
 336 0026 C4F8EC52 		str	r5, [r4, #748]
 173:le_phy.c      **** 	buf->rssi_min = INT8_MAX;
 337              		.loc 1 173 0
 338 002a 4FF48272 		mov	r2, #260
 339 002e 2946     		mov	r1, r5
 340 0030 3046     		mov	r0, r6
 341 0032 FFF7FEFF 		bl	memset
 342              	.LVL21:
 174:le_phy.c      **** 	buf->rssi_max = INT8_MIN;
 343              		.loc 1 174 0
 344 0036 7F23     		movs	r3, #127
 345 0038 84F80433 		strb	r3, [r4, #772]
 175:le_phy.c      **** 	buf->rssi_sum = 0;
 346              		.loc 1 175 0
 347 003c 8023     		movs	r3, #128
 176:le_phy.c      **** }
 348              		.loc 1 176 0
 349 003e C4F80853 		str	r5, [r4, #776]
 175:le_phy.c      **** 	buf->rssi_sum = 0;
 350              		.loc 1 175 0
 351 0042 84F80533 		strb	r3, [r4, #773]
 176:le_phy.c      **** }
 352              		.loc 1 176 0
 353 0046 3046     		mov	r0, r6
 354 0048 70BD     		pop	{r4, r5, r6, pc}
 355              	.LVL22:
 356              	.L24:
 357              	.LBE8:
 358              	.LBE7:
 185:le_phy.c      **** 		if (le_buffer_pool[i].available) {
 359              		.loc 1 185 0 discriminator 2
 360 004a 0133     		adds	r3, r3, #1
 361              	.LVL23:
 362 004c 042B     		cmp	r3, #4
ARM GAS  /tmp/ccbEq2sz.s 			page 23


 363 004e DED1     		bne	.L26
 194:le_phy.c      **** 
 364              		.loc 1 194 0
 365 0050 70BD     		pop	{r4, r5, r6, pc}
 366              	.L29:
 367 0052 00BF     		.align	2
 368              	.L28:
 369 0054 00000000 		.word	.LANCHOR0
 370              		.cfi_endproc
 371              	.LFE3:
 373              		.section	.text.le_cc2400_init_rf,"ax",%progbits
 374              		.align	1
 375              		.syntax unified
 376              		.thumb
 377              		.thumb_func
 378              		.fpu softvfp
 380              	le_cc2400_init_rf:
 381              	.LFB10:
 442:le_phy.c      **** 	u16 grmdm, mdmctrl;
 382              		.loc 1 442 0
 383              		.cfi_startproc
 384              		@ args = 0, pretend = 0, frame = 0
 385              		@ frame_needed = 0, uses_anonymous_args = 0
 386 0000 10B5     		push	{r4, lr}
 387              		.cfi_def_cfa_offset 8
 388              		.cfi_offset 4, -8
 389              		.cfi_offset 14, -4
 444:le_phy.c      **** 
 390              		.loc 1 444 0
 391 0002 1B4B     		ldr	r3, .L34
 392 0004 186A     		ldr	r0, [r3, #32]
 393 0006 FFF7FEFF 		bl	rbit
 394              	.LVL24:
 395 000a 0446     		mov	r4, r0
 396              	.LVL25:
 456:le_phy.c      **** 	cc2400_set(LMTST,   0x2b22);
 397              		.loc 1 456 0
 398 000c 47F6FE71 		movw	r1, #32766
 399 0010 0D20     		movs	r0, #13
 400              	.LVL26:
 401 0012 FFF7FEFF 		bl	cc2400_set
 402              	.LVL27:
 457:le_phy.c      **** 
 403              		.loc 1 457 0
 404 0016 42F62231 		movw	r1, #11042
 405 001a 1220     		movs	r0, #18
 406 001c FFF7FEFF 		bl	cc2400_set
 407              	.LVL28:
 459:le_phy.c      **** 	// 1      2      4b
 408              		.loc 1 459 0
 409 0020 41F24B21 		movw	r1, #4683
 410 0024 1420     		movs	r0, #20
 411 0026 FFF7FEFF 		bl	cc2400_set
 412              	.LVL29:
 472:le_phy.c      **** 
 413              		.loc 1 472 0
 414 002a 44F2E141 		movw	r1, #17633
ARM GAS  /tmp/ccbEq2sz.s 			page 24


 415 002e 2020     		movs	r0, #32
 416 0030 FFF7FEFF 		bl	cc2400_set
 417              	.LVL30:
 474:le_phy.c      **** 	cc2400_set(SYNCH,   (sync >> 16) & 0xffff);
 418              		.loc 1 474 0
 419 0034 A1B2     		uxth	r1, r4
 420 0036 2C20     		movs	r0, #44
 421 0038 FFF7FEFF 		bl	cc2400_set
 422              	.LVL31:
 475:le_phy.c      **** 
 423              		.loc 1 475 0
 424 003c 210C     		lsrs	r1, r4, #16
 425 003e 2D20     		movs	r0, #45
 426 0040 FFF7FEFF 		bl	cc2400_set
 427              	.LVL32:
 477:le_phy.c      **** 	cc2400_set(MDMCTRL, mdmctrl);
 428              		.loc 1 477 0
 429 0044 0B4B     		ldr	r3, .L34+4
 430 0046 0220     		movs	r0, #2
 431 0048 1988     		ldrh	r1, [r3]
 432 004a 0139     		subs	r1, r1, #1
 433 004c 89B2     		uxth	r1, r1
 434 004e FFF7FEFF 		bl	cc2400_set
 435              	.LVL33:
 478:le_phy.c      **** 
 436              		.loc 1 478 0
 437 0052 4021     		movs	r1, #64
 438 0054 0320     		movs	r0, #3
 439 0056 FFF7FEFF 		bl	cc2400_set
 440              	.LVL34:
 441              	.L31:
 481:le_phy.c      **** 
 442              		.loc 1 481 0 discriminator 1
 443 005a FFF7FEFF 		bl	cc2400_status
 444              	.LVL35:
 445 005e 4306     		lsls	r3, r0, #25
 446 0060 FBD5     		bpl	.L31
 484:le_phy.c      **** 	timer1_wait_fs_lock();
 447              		.loc 1 484 0
 448 0062 6120     		movs	r0, #97
 449 0064 FFF7FEFF 		bl	cc2400_strobe
 450              	.LVL36:
 486:le_phy.c      **** 
 451              		.loc 1 486 0
 452 0068 BDE81040 		pop	{r4, lr}
 453              		.cfi_restore 14
 454              		.cfi_restore 4
 455              		.cfi_def_cfa_offset 0
 456              	.LVL37:
 485:le_phy.c      **** }
 457              		.loc 1 485 0
 458 006c FFF7FEBF 		b	timer1_wait_fs_lock
 459              	.LVL38:
 460              	.L35:
 461              		.align	2
 462              	.L34:
 463 0070 00000000 		.word	.LANCHOR0
ARM GAS  /tmp/ccbEq2sz.s 			page 25


 464 0074 00000000 		.word	rf_channel
 465              		.cfi_endproc
 466              	.LFE10:
 468              		.section	.text.change_channel,"ax",%progbits
 469              		.align	1
 470              		.syntax unified
 471              		.thumb
 472              		.thumb_func
 473              		.fpu softvfp
 475              	change_channel:
 476              	.LFB12:
 498:le_phy.c      **** 	uint8_t channel_idx = 0;
 477              		.loc 1 498 0
 478              		.cfi_startproc
 479              		@ args = 0, pretend = 0, frame = 0
 480              		@ frame_needed = 0, uses_anonymous_args = 0
 481 0000 70B5     		push	{r4, r5, r6, lr}
 482              		.cfi_def_cfa_offset 16
 483              		.cfi_offset 4, -16
 484              		.cfi_offset 5, -12
 485              		.cfi_offset 6, -8
 486              		.cfi_offset 14, -4
 487              	.LVL39:
 501:le_phy.c      **** 
 488              		.loc 1 501 0
 489 0002 6420     		movs	r0, #100
 490 0004 FFF7FEFF 		bl	cc2400_strobe
 491              	.LVL40:
 504:le_phy.c      **** 	while (SSP1SR & SSPSR_RNE) {
 492              		.loc 1 504 0
 493 0008 284A     		ldr	r2, .L44
 494 000a 1368     		ldr	r3, [r2]
 495              	.LBB12:
 506:le_phy.c      **** 	}
 496              		.loc 1 506 0
 497 000c 1C3A     		subs	r2, r2, #28
 498              	.LBE12:
 504:le_phy.c      **** 	while (SSP1SR & SSPSR_RNE) {
 499              		.loc 1 504 0
 500 000e 23F00103 		bic	r3, r3, #1
 501 0012 D361     		str	r3, [r2, #28]
 505:le_phy.c      **** 		uint8_t tmp = (uint8_t)DIO_SSP_DR;
 502              		.loc 1 505 0
 503 0014 264B     		ldr	r3, .L44+4
 504              	.L37:
 505 0016 1C68     		ldr	r4, [r3]
 506 0018 14F00404 		ands	r4, r4, #4
 507 001c 30D1     		bne	.L38
 509:le_phy.c      **** 	le_dma_init();
 508              		.loc 1 509 0
 509 001e 254D     		ldr	r5, .L44+8
 510              	.LBB13:
 511              	.LBB14:
 173:le_phy.c      **** 	buf->rssi_min = INT8_MAX;
 512              		.loc 1 173 0
 513 0020 4FF48272 		mov	r2, #260
 514              	.LBE14:
ARM GAS  /tmp/ccbEq2sz.s 			page 26


 515              	.LBE13:
 509:le_phy.c      **** 	le_dma_init();
 516              		.loc 1 509 0
 517 0024 D5F87866 		ldr	r6, [r5, #1656]
 518              	.LVL41:
 519              	.LBB16:
 520              	.LBB15:
 173:le_phy.c      **** 	buf->rssi_min = INT8_MAX;
 521              		.loc 1 173 0
 522 0028 2146     		mov	r1, r4
 171:le_phy.c      **** 	buf->size = 0;
 523              		.loc 1 171 0
 524 002a C6F80841 		str	r4, [r6, #264]
 172:le_phy.c      **** 	memset(buf->data, 0, sizeof(buf->data));
 525              		.loc 1 172 0
 526 002e C6F80441 		str	r4, [r6, #260]
 173:le_phy.c      **** 	buf->rssi_min = INT8_MAX;
 527              		.loc 1 173 0
 528 0032 3046     		mov	r0, r6
 529 0034 FFF7FEFF 		bl	memset
 530              	.LVL42:
 174:le_phy.c      **** 	buf->rssi_max = INT8_MIN;
 531              		.loc 1 174 0
 532 0038 7F23     		movs	r3, #127
 533 003a 86F81C31 		strb	r3, [r6, #284]
 175:le_phy.c      **** 	buf->rssi_sum = 0;
 534              		.loc 1 175 0
 535 003e 8023     		movs	r3, #128
 176:le_phy.c      **** }
 536              		.loc 1 176 0
 537 0040 C6F82041 		str	r4, [r6, #288]
 538              	.LVL43:
 175:le_phy.c      **** 	buf->rssi_sum = 0;
 539              		.loc 1 175 0
 540 0044 86F81D31 		strb	r3, [r6, #285]
 541              	.LBE15:
 542              	.LBE16:
 510:le_phy.c      **** 	dio_ssp_start();
 543              		.loc 1 510 0
 544 0048 FFF7FEFF 		bl	le_dma_init
 545              	.LVL44:
 511:le_phy.c      **** 
 546              		.loc 1 511 0
 547 004c FFF7FEFF 		bl	dio_ssp_start
 548              	.LVL45:
 513:le_phy.c      **** 		// FIXME
 549              		.loc 1 513 0
 550 0050 2A6A     		ldr	r2, [r5, #32]
 551 0052 194B     		ldr	r3, .L44+12
 552 0054 9A42     		cmp	r2, r3
 553 0056 17D1     		bne	.L39
 515:le_phy.c      **** 			case 2402: channel_idx = 37; break;
 554              		.loc 1 515 0
 555 0058 40F67A12 		movw	r2, #2426
 556 005c 174B     		ldr	r3, .L44+16
 557 005e 1B88     		ldrh	r3, [r3]
 558 0060 9BB2     		uxth	r3, r3
ARM GAS  /tmp/ccbEq2sz.s 			page 27


 559 0062 9342     		cmp	r3, r2
 560 0064 0ED0     		beq	.L41
 516:le_phy.c      **** 			case 2426: channel_idx = 38; break;
 561              		.loc 1 516 0
 562 0066 B3F51B6F 		cmp	r3, #2480
 563 006a 0CBF     		ite	eq
 564 006c 2720     		moveq	r0, #39
 565 006e 2520     		movne	r0, #37
 566              	.LVL46:
 567              	.L40:
 526:le_phy.c      **** 	le_cc2400_init_rf();
 568              		.loc 1 526 0
 569 0070 FFF7FEFF 		bl	btle_channel_index_to_phys
 570              	.LVL47:
 528:le_phy.c      **** 
 571              		.loc 1 528 0
 572 0074 BDE87040 		pop	{r4, r5, r6, lr}
 573              		.cfi_remember_state
 574              		.cfi_restore 14
 575              		.cfi_restore 6
 576              		.cfi_restore 5
 577              		.cfi_restore 4
 578              		.cfi_def_cfa_offset 0
 526:le_phy.c      **** 	le_cc2400_init_rf();
 579              		.loc 1 526 0
 580 0078 114B     		ldr	r3, .L44+20
 581 007a 1880     		strh	r0, [r3]	@ movhi
 527:le_phy.c      **** }
 582              		.loc 1 527 0
 583 007c FFF7FEBF 		b	le_cc2400_init_rf
 584              	.LVL48:
 585              	.L38:
 586              		.cfi_restore_state
 587              	.LBB17:
 506:le_phy.c      **** 	}
 588              		.loc 1 506 0
 589 0080 1168     		ldr	r1, [r2]
 590 0082 C8E7     		b	.L37
 591              	.L41:
 592              	.LBE17:
 517:le_phy.c      **** 			case 2480: channel_idx = 39; break;
 593              		.loc 1 517 0
 594 0084 2620     		movs	r0, #38
 595 0086 F3E7     		b	.L40
 596              	.L39:
 522:le_phy.c      **** 		channel_idx = le_map_channel(conn.channel_idx, &conn.remapping);
 597              		.loc 1 522 0
 598 0088 2522     		movs	r2, #37
 599 008a 95F82C00 		ldrb	r0, [r5, #44]	@ zero_extendqisi2
 600 008e 95F82D30 		ldrb	r3, [r5, #45]	@ zero_extendqisi2
 523:le_phy.c      **** 	}
 601              		.loc 1 523 0
 602 0092 05F14001 		add	r1, r5, #64
 522:le_phy.c      **** 		channel_idx = le_map_channel(conn.channel_idx, &conn.remapping);
 603              		.loc 1 522 0
 604 0096 0344     		add	r3, r3, r0
 605 0098 93FBF2F0 		sdiv	r0, r3, r2
ARM GAS  /tmp/ccbEq2sz.s 			page 28


 606 009c 02FB1030 		mls	r0, r2, r0, r3
 607 00a0 C0B2     		uxtb	r0, r0
 608 00a2 85F82C00 		strb	r0, [r5, #44]
 523:le_phy.c      **** 	}
 609              		.loc 1 523 0
 610 00a6 FFF7FEFF 		bl	le_map_channel
 611              	.LVL49:
 612 00aa E1E7     		b	.L40
 613              	.L45:
 614              		.align	2
 615              	.L44:
 616 00ac 24000340 		.word	1073938468
 617 00b0 0C000340 		.word	1073938444
 618 00b4 00000000 		.word	.LANCHOR0
 619 00b8 D6BE898E 		.word	-1903575338
 620 00bc 00000000 		.word	le_adv_channel
 621 00c0 00000000 		.word	rf_channel
 622              		.cfi_endproc
 623              	.LFE12:
 625              		.section	.text.finish_conn_event,"ax",%progbits
 626              		.align	1
 627              		.syntax unified
 628              		.thumb
 629              		.thumb_func
 630              		.fpu softvfp
 632              	finish_conn_event:
 633              	.LFB6:
 225:le_phy.c      **** 	uint32_t last_anchor = 0;
 634              		.loc 1 225 0
 635              		.cfi_startproc
 636              		@ args = 0, pretend = 0, frame = 0
 637              		@ frame_needed = 0, uses_anonymous_args = 0
 638 0000 38B5     		push	{r3, r4, r5, lr}
 639              		.cfi_def_cfa_offset 16
 640              		.cfi_offset 3, -16
 641              		.cfi_offset 4, -12
 642              		.cfi_offset 5, -8
 643              		.cfi_offset 14, -4
 644              	.LVL50:
 228:le_phy.c      **** 	// two packets -- update anchor
 645              		.loc 1 228 0
 646 0002 2B48     		ldr	r0, .L64
 647 0004 FFF7FEFF 		bl	debug_printf
 648              	.LVL51:
 230:le_phy.c      **** 		last_anchor = conn_event.anchor;
 649              		.loc 1 230 0
 650 0008 2A4A     		ldr	r2, .L64+4
 651 000a 2B4B     		ldr	r3, .L64+8
 652 000c 5068     		ldr	r0, [r2, #4]
 653 000e 0228     		cmp	r0, #2
 654 0010 06D1     		bne	.L47
 231:le_phy.c      **** 		last_anchor_set = 1;
 655              		.loc 1 231 0
 656 0012 1468     		ldr	r4, [r2]
 657              	.LVL52:
 658              	.L48:
 251:le_phy.c      **** 	}
ARM GAS  /tmp/ccbEq2sz.s 			page 29


 659              		.loc 1 251 0
 660 0014 0121     		movs	r1, #1
 250:le_phy.c      **** 		conn.anchor_set = 1;
 661              		.loc 1 250 0
 662 0016 C3F80041 		str	r4, [r3, #256]
 251:le_phy.c      **** 	}
 663              		.loc 1 251 0
 664 001a C3F80411 		str	r1, [r3, #260]
 665 001e 1EE0     		b	.L50
 666              	.LVL53:
 667              	.L47:
 236:le_phy.c      **** 		// calculate the difference between the estimated and observed anchor
 668              		.loc 1 236 0
 669 0020 0128     		cmp	r0, #1
 670 0022 0BD1     		bne	.L49
 236:le_phy.c      **** 		// calculate the difference between the estimated and observed anchor
 671              		.loc 1 236 0 is_stmt 0 discriminator 1
 672 0024 D3F80411 		ldr	r1, [r3, #260]
 673 0028 41B1     		cbz	r1, .L49
 674              	.LVL54:
 675              	.LBB21:
 238:le_phy.c      **** 		uint32_t delta = estimated_anchor - conn_event.anchor;
 676              		.loc 1 238 0 is_stmt 1
 677 002a D3F80011 		ldr	r1, [r3, #256]
 678 002e 1D6B     		ldr	r5, [r3, #48]
 239:le_phy.c      **** 		// see whether the observed anchor is within 3 us of the estimate
 679              		.loc 1 239 0
 680 0030 1468     		ldr	r4, [r2]
 681              	.LVL55:
 238:le_phy.c      **** 		uint32_t delta = estimated_anchor - conn_event.anchor;
 682              		.loc 1 238 0
 683 0032 2944     		add	r1, r1, r5
 684              	.LVL56:
 241:le_phy.c      **** 		if (delta < 2 * ANCHOR_EPSILON) {
 685              		.loc 1 241 0
 686 0034 1E31     		adds	r1, r1, #30
 687              	.LVL57:
 688 0036 091B     		subs	r1, r1, r4
 689              	.LVL58:
 242:le_phy.c      **** 			last_anchor = conn_event.anchor;
 690              		.loc 1 242 0
 691 0038 3B29     		cmp	r1, #59
 692 003a EBD9     		bls	.L48
 693              	.LVL59:
 694              	.L49:
 695              	.LBE21:
 255:le_phy.c      **** 		conn.last_anchor += conn.conn_interval;
 696              		.loc 1 255 0
 697 003c D3F80411 		ldr	r1, [r3, #260]
 698 0040 39B9     		cbnz	r1, .L54
 261:le_phy.c      **** 		conn.last_packet_ts = NOW; // FIXME gross hack
 699              		.loc 1 261 0
 700 0042 1168     		ldr	r1, [r2]
 701 0044 C3F80011 		str	r1, [r3, #256]
 262:le_phy.c      **** 	}
 702              		.loc 1 262 0
 703 0048 1C49     		ldr	r1, .L64+12
ARM GAS  /tmp/ccbEq2sz.s 			page 30


 704 004a 0968     		ldr	r1, [r1]
 705 004c C3F80811 		str	r1, [r3, #264]
 706 0050 05E0     		b	.L50
 707              	.L54:
 256:le_phy.c      **** 	}
 708              		.loc 1 256 0
 709 0052 D3F80011 		ldr	r1, [r3, #256]
 710 0056 1C6B     		ldr	r4, [r3, #48]
 711 0058 2144     		add	r1, r1, r4
 712 005a C3F80011 		str	r1, [r3, #256]
 713              	.LVL60:
 714              	.L50:
 715 005e 174C     		ldr	r4, .L64+12
 266:le_phy.c      **** 		conn.last_packet_ts = NOW;
 716              		.loc 1 266 0
 717 0060 10B1     		cbz	r0, .L51
 267:le_phy.c      **** 	}
 718              		.loc 1 267 0
 719 0062 2168     		ldr	r1, [r4]
 720 0064 C3F80811 		str	r1, [r3, #264]
 721              	.L51:
 722              	.LBB22:
 723              	.LBB23:
 203:le_phy.c      **** 	conn_event.opened = 0;
 724              		.loc 1 203 0
 725 0068 0021     		movs	r1, #0
 726 006a 5160     		str	r1, [r2, #4]
 204:le_phy.c      **** }
 727              		.loc 1 204 0
 728 006c 9160     		str	r1, [r2, #8]
 729              	.LBE23:
 730              	.LBE22:
 273:le_phy.c      **** 
 731              		.loc 1 273 0
 732 006e B3F80C21 		ldrh	r2, [r3, #268]
 276:le_phy.c      **** 		reset_conn();
 733              		.loc 1 276 0
 734 0072 D3F80801 		ldr	r0, [r3, #264]
 273:le_phy.c      **** 
 735              		.loc 1 273 0
 736 0076 0132     		adds	r2, r2, #1
 737 0078 A3F80C21 		strh	r2, [r3, #268]	@ movhi
 276:le_phy.c      **** 		reset_conn();
 738              		.loc 1 276 0
 739 007c 2268     		ldr	r2, [r4]
 740 007e 121A     		subs	r2, r2, r0
 741 0080 586B     		ldr	r0, [r3, #52]
 742 0082 8242     		cmp	r2, r0
 743 0084 05D9     		bls	.L52
 744              	.L63:
 284:le_phy.c      **** 		change_channel();
 745              		.loc 1 284 0
 746 0086 FFF7FEFF 		bl	reset_conn
 747              	.LVL61:
 292:le_phy.c      **** 
 748              		.loc 1 292 0
 749 008a BDE83840 		pop	{r3, r4, r5, lr}
ARM GAS  /tmp/ccbEq2sz.s 			page 31


 750              		.cfi_remember_state
 751              		.cfi_restore 14
 752              		.cfi_restore 5
 753              		.cfi_restore 4
 754              		.cfi_restore 3
 755              		.cfi_def_cfa_offset 0
 285:le_phy.c      **** 	}
 756              		.loc 1 285 0
 757 008e FFF7FEBF 		b	change_channel
 758              	.LVL62:
 759              	.L52:
 760              		.cfi_restore_state
 282:le_phy.c      **** 		cancel_follow = 0;
 761              		.loc 1 282 0
 762 0092 0B4A     		ldr	r2, .L64+16
 763 0094 1068     		ldr	r0, [r2]
 764 0096 08B1     		cbz	r0, .L53
 283:le_phy.c      **** 		reset_conn();
 765              		.loc 1 283 0
 766 0098 1160     		str	r1, [r2]
 767 009a F4E7     		b	.L63
 768              	.L53:
 290:le_phy.c      **** 	}
 769              		.loc 1 290 0
 770 009c D3F80001 		ldr	r0, [r3, #256]
 771 00a0 1B6B     		ldr	r3, [r3, #48]
 772 00a2 1844     		add	r0, r0, r3
 773 00a4 A0F6B830 		subw	r0, r0, #3000
 292:le_phy.c      **** 
 774              		.loc 1 292 0
 775 00a8 BDE83840 		pop	{r3, r4, r5, lr}
 776              		.cfi_restore 14
 777              		.cfi_restore 5
 778              		.cfi_restore 4
 779              		.cfi_restore 3
 780              		.cfi_def_cfa_offset 0
 290:le_phy.c      **** 	}
 781              		.loc 1 290 0
 782 00ac FFF7FEBF 		b	timer1_set_match
 783              	.LVL63:
 784              	.L65:
 785              		.align	2
 786              	.L64:
 787 00b0 00000000 		.word	.LC0
 788 00b4 00000000 		.word	conn_event
 789 00b8 00000000 		.word	.LANCHOR0
 790 00bc 08800040 		.word	1073774600
 791 00c0 00000000 		.word	cancel_follow
 792              		.cfi_endproc
 793              	.LFE6:
 795              		.section	.text.le_DMA_IRQHandler,"ax",%progbits
 796              		.align	1
 797              		.global	le_DMA_IRQHandler
 798              		.syntax unified
 799              		.thumb
 800              		.thumb_func
 801              		.fpu softvfp
ARM GAS  /tmp/ccbEq2sz.s 			page 32


 803              	le_DMA_IRQHandler:
 804              	.LFB7:
 298:le_phy.c      ****     debug_printf("le_DMA_IRQHandler\n");
 805              		.loc 1 298 0
 806              		.cfi_startproc
 807              		@ args = 0, pretend = 0, frame = 0
 808              		@ frame_needed = 0, uses_anonymous_args = 0
 809 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 810              		.cfi_def_cfa_offset 24
 811              		.cfi_offset 3, -24
 812              		.cfi_offset 4, -20
 813              		.cfi_offset 5, -16
 814              		.cfi_offset 6, -12
 815              		.cfi_offset 7, -8
 816              		.cfi_offset 14, -4
 299:le_phy.c      **** 	unsigned pos;
 817              		.loc 1 299 0
 818 0002 6948     		ldr	r0, .L89
 819 0004 FFF7FEFF 		bl	debug_printf
 820              	.LVL64:
 302:le_phy.c      **** 
 821              		.loc 1 302 0
 822 0008 684D     		ldr	r5, .L89+4
 305:le_phy.c      **** 		// terminal count - byte received
 823              		.loc 1 305 0
 824 000a 694B     		ldr	r3, .L89+8
 302:le_phy.c      **** 
 825              		.loc 1 302 0
 826 000c 2F68     		ldr	r7, [r5]
 827              	.LVL65:
 305:le_phy.c      **** 		// terminal count - byte received
 828              		.loc 1 305 0
 829 000e 1B68     		ldr	r3, [r3]
 830 0010 DE07     		lsls	r6, r3, #31
 831 0012 49D5     		bpl	.L66
 307:le_phy.c      **** 			DMACIntTCClear = (1 << 0);
 832              		.loc 1 307 0
 833 0014 674B     		ldr	r3, .L89+12
 834 0016 1B68     		ldr	r3, [r3]
 835 0018 DC07     		lsls	r4, r3, #31
 836 001a 3ED5     		bpl	.L75
 308:le_phy.c      **** 
 837              		.loc 1 308 0
 838 001c 0123     		movs	r3, #1
 839 001e 664E     		ldr	r6, .L89+16
 311:le_phy.c      **** 			current_rxbuf->rssi_sum += rssi;
 840              		.loc 1 311 0
 841 0020 0620     		movs	r0, #6
 308:le_phy.c      **** 
 842              		.loc 1 308 0
 843 0022 3360     		str	r3, [r6]
 311:le_phy.c      **** 			current_rxbuf->rssi_sum += rssi;
 844              		.loc 1 311 0
 845 0024 FFF7FEFF 		bl	cc2400_get
 846              	.LVL66:
 312:le_phy.c      **** 			if (rssi < current_rxbuf->rssi_min) current_rxbuf->rssi_min = rssi;
 847              		.loc 1 312 0
ARM GAS  /tmp/ccbEq2sz.s 			page 33


 848 0028 644C     		ldr	r4, .L89+20
 311:le_phy.c      **** 			current_rxbuf->rssi_sum += rssi;
 849              		.loc 1 311 0
 850 002a 40F30720 		sbfx	r0, r0, #8, #8
 851              	.LVL67:
 312:le_phy.c      **** 			if (rssi < current_rxbuf->rssi_min) current_rxbuf->rssi_min = rssi;
 852              		.loc 1 312 0
 853 002e D4F87836 		ldr	r3, [r4, #1656]
 313:le_phy.c      **** 			if (rssi > current_rxbuf->rssi_max) current_rxbuf->rssi_max = rssi;
 854              		.loc 1 313 0
 855 0032 93F91C21 		ldrsb	r2, [r3, #284]
 312:le_phy.c      **** 			if (rssi < current_rxbuf->rssi_min) current_rxbuf->rssi_min = rssi;
 856              		.loc 1 312 0
 857 0036 D3F82011 		ldr	r1, [r3, #288]
 313:le_phy.c      **** 			if (rssi > current_rxbuf->rssi_max) current_rxbuf->rssi_max = rssi;
 858              		.loc 1 313 0
 859 003a 8242     		cmp	r2, r0
 314:le_phy.c      **** 
 860              		.loc 1 314 0
 861 003c 93F91D21 		ldrsb	r2, [r3, #285]
 313:le_phy.c      **** 			if (rssi > current_rxbuf->rssi_max) current_rxbuf->rssi_max = rssi;
 862              		.loc 1 313 0
 863 0040 C8BF     		it	gt
 864 0042 83F81C01 		strbgt	r0, [r3, #284]
 314:le_phy.c      **** 
 865              		.loc 1 314 0
 866 0046 8242     		cmp	r2, r0
 317:le_phy.c      **** 			current_rxbuf->data[pos] = le_dma_dest[pos & 1]; // dirty hack
 867              		.loc 1 317 0
 868 0048 D3F80821 		ldr	r2, [r3, #264]
 869              	.LVL68:
 312:le_phy.c      **** 			if (rssi < current_rxbuf->rssi_min) current_rxbuf->rssi_min = rssi;
 870              		.loc 1 312 0
 871 004c 0144     		add	r1, r1, r0
 314:le_phy.c      **** 
 872              		.loc 1 314 0
 873 004e B8BF     		it	lt
 874 0050 83F81D01 		strblt	r0, [r3, #285]
 318:le_phy.c      **** 			pos += 1;
 875              		.loc 1 318 0
 876 0054 5A48     		ldr	r0, .L89+24
 877              	.LVL69:
 312:le_phy.c      **** 			if (rssi < current_rxbuf->rssi_min) current_rxbuf->rssi_min = rssi;
 878              		.loc 1 312 0
 879 0056 C3F82011 		str	r1, [r3, #288]
 318:le_phy.c      **** 			pos += 1;
 880              		.loc 1 318 0
 881 005a 02F00101 		and	r1, r2, #1
 882 005e 415C     		ldrb	r1, [r0, r1]	@ zero_extendqisi2
 883 0060 9954     		strb	r1, [r3, r2]
 319:le_phy.c      **** 			current_rxbuf->pos = pos;
 884              		.loc 1 319 0
 885 0062 0132     		adds	r2, r2, #1
 886              	.LVL70:
 322:le_phy.c      **** 				current_rxbuf->timestamp = timestamp - USEC(8 + 32); // packet starts at preamble
 887              		.loc 1 322 0
 888 0064 012A     		cmp	r2, #1
ARM GAS  /tmp/ccbEq2sz.s 			page 34


 320:le_phy.c      **** 
 889              		.loc 1 320 0
 890 0066 C3F80821 		str	r2, [r3, #264]
 322:le_phy.c      **** 				current_rxbuf->timestamp = timestamp - USEC(8 + 32); // packet starts at preamble
 891              		.loc 1 322 0
 892 006a 1ED1     		bne	.L72
 324:le_phy.c      **** 				current_rxbuf->access_address = conn.access_address;
 893              		.loc 1 324 0
 894 006c 5549     		ldr	r1, .L89+28
 323:le_phy.c      **** 				current_rxbuf->channel = rf_channel;
 895              		.loc 1 323 0
 896 006e A7F5C877 		sub	r7, r7, #400
 897              	.LVL71:
 324:le_phy.c      **** 				current_rxbuf->access_address = conn.access_address;
 898              		.loc 1 324 0
 899 0072 0A88     		ldrh	r2, [r1]
 900              	.LVL72:
 329:le_phy.c      **** 					timer1_clear_match();
 901              		.loc 1 329 0
 902 0074 0888     		ldrh	r0, [r1]
 324:le_phy.c      **** 				current_rxbuf->access_address = conn.access_address;
 903              		.loc 1 324 0
 904 0076 92B2     		uxth	r2, r2
 905 0078 C3F81021 		str	r2, [r3, #272]
 325:le_phy.c      **** 
 906              		.loc 1 325 0
 907 007c 226A     		ldr	r2, [r4, #32]
 323:le_phy.c      **** 				current_rxbuf->channel = rf_channel;
 908              		.loc 1 323 0
 909 007e C3F80C71 		str	r7, [r3, #268]
 325:le_phy.c      **** 
 910              		.loc 1 325 0
 911 0082 C3F81421 		str	r2, [r3, #276]
 329:le_phy.c      **** 					timer1_clear_match();
 912              		.loc 1 329 0
 913 0086 80B2     		uxth	r0, r0
 914 0088 FFF7FEFF 		bl	btle_channel_index
 915              	.LVL73:
 916 008c 2428     		cmp	r0, #36
 917 008e 04D8     		bhi	.L75
 918              	.LBB30:
 919              	.LBB31:
 555:le_phy.c      **** }
 920              		.loc 1 555 0
 921 0090 4D4A     		ldr	r2, .L89+32
 922 0092 1368     		ldr	r3, [r2]
 923 0094 23F00103 		bic	r3, r3, #1
 924 0098 1360     		str	r3, [r2]
 925              	.LVL74:
 926              	.L75:
 927              	.LBE31:
 928              	.LBE30:
 390:le_phy.c      **** 			// TODO error state transition
 929              		.loc 1 390 0
 930 009a 4C4B     		ldr	r3, .L89+36
 931 009c 1B68     		ldr	r3, [r3]
 932 009e DB07     		lsls	r3, r3, #31
ARM GAS  /tmp/ccbEq2sz.s 			page 35


 392:le_phy.c      **** 		}
 933              		.loc 1 392 0
 934 00a0 42BF     		ittt	mi
 935 00a2 0122     		movmi	r2, #1
 936 00a4 4A4B     		ldrmi	r3, .L89+40
 937 00a6 1A60     		strmi	r2, [r3]
 938              	.L66:
 939 00a8 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 940              	.LVL75:
 941              	.L72:
 335:le_phy.c      **** 				uint8_t length = dewhiten_length(current_rxbuf->channel, current_rxbuf->data[1]);
 942              		.loc 1 335 0
 943 00aa 022A     		cmp	r2, #2
 944 00ac 2ED1     		bne	.L73
 945              	.LBB32:
 946              	.LBB33:
 947              	.LBB34:
 687:le_phy.c      **** 	uint8_t out = 0;
 948              		.loc 1 687 0
 949 00ae B3F81001 		ldrh	r0, [r3, #272]
 950              	.LBE34:
 951              	.LBE33:
 336:le_phy.c      **** 				current_rxbuf->size = length + 2 + 3; // two bytes for header and three for CRC
 952              		.loc 1 336 0
 953 00b2 5E78     		ldrb	r6, [r3, #1]	@ zero_extendqisi2
 954              	.LVL76:
 955              	.LBB36:
 956              	.LBB35:
 687:le_phy.c      **** 	uint8_t out = 0;
 957              		.loc 1 687 0
 958 00b4 FFF7FEFF 		bl	btle_channel_index
 959              	.LVL77:
 691:le_phy.c      **** 
 960              		.loc 1 691 0
 961 00b8 7F27     		movs	r7, #127
 962              	.LVL78:
 688:le_phy.c      **** 
 963              		.loc 1 688 0
 964 00ba 0021     		movs	r1, #0
 687:le_phy.c      **** 	uint8_t out = 0;
 965              		.loc 1 687 0
 966 00bc 454D     		ldr	r5, .L89+44
 967 00be 2B5C     		ldrb	r3, [r5, r0]	@ zero_extendqisi2
 968 00c0 AE46     		mov	lr, r5
 691:le_phy.c      **** 
 969              		.loc 1 691 0
 970 00c2 0833     		adds	r3, r3, #8
 971 00c4 B3FBF7F2 		udiv	r2, r3, r7
 693:le_phy.c      **** 		bit = (data >> (7-i)) & 1;
 972              		.loc 1 693 0
 973 00c8 0846     		mov	r0, r1
 974              	.LVL79:
 691:le_phy.c      **** 
 975              		.loc 1 691 0
 976 00ca C2EBC212 		rsb	r2, r2, r2, lsl #7
 977 00ce 9B1A     		subs	r3, r3, r2
 978              	.LVL80:
ARM GAS  /tmp/ccbEq2sz.s 			page 36


 979              	.L74:
 694:le_phy.c      **** 		bit ^= whitening[idx];
 980              		.loc 1 694 0
 981 00d0 C0F10702 		rsb	r2, r0, #7
 982 00d4 46FA02F2 		asr	r2, r6, r2
 983 00d8 02F00105 		and	r5, r2, #1
 984              	.LVL81:
 695:le_phy.c      **** 		idx = (idx + 1) % sizeof(whitening);
 985              		.loc 1 695 0
 986 00dc 0EEB0302 		add	r2, lr, r3
 987 00e0 92F82820 		ldrb	r2, [r2, #40]	@ zero_extendqisi2
 696:le_phy.c      **** 		out |= bit << i;
 988              		.loc 1 696 0
 989 00e4 0133     		adds	r3, r3, #1
 990              	.LVL82:
 695:le_phy.c      **** 		idx = (idx + 1) % sizeof(whitening);
 991              		.loc 1 695 0
 992 00e6 6A40     		eors	r2, r2, r5
 993              	.LVL83:
 696:le_phy.c      **** 		out |= bit << i;
 994              		.loc 1 696 0
 995 00e8 B3FBF7F5 		udiv	r5, r3, r7
 697:le_phy.c      **** 	}
 996              		.loc 1 697 0
 997 00ec 8240     		lsls	r2, r2, r0
 998              	.LVL84:
 693:le_phy.c      **** 		bit = (data >> (7-i)) & 1;
 999              		.loc 1 693 0
 1000 00ee 0130     		adds	r0, r0, #1
 1001              	.LVL85:
 696:le_phy.c      **** 		out |= bit << i;
 1002              		.loc 1 696 0
 1003 00f0 C5EBC515 		rsb	r5, r5, r5, lsl #7
 697:le_phy.c      **** 	}
 1004              		.loc 1 697 0
 1005 00f4 0A43     		orrs	r2, r2, r1
 693:le_phy.c      **** 		bit = (data >> (7-i)) & 1;
 1006              		.loc 1 693 0
 1007 00f6 0828     		cmp	r0, #8
 696:le_phy.c      **** 		out |= bit << i;
 1008              		.loc 1 696 0
 1009 00f8 A3EB0503 		sub	r3, r3, r5
 1010              	.LVL86:
 697:le_phy.c      **** 	}
 1011              		.loc 1 697 0
 1012 00fc D1B2     		uxtb	r1, r2
 1013              	.LVL87:
 693:le_phy.c      **** 		bit = (data >> (7-i)) & 1;
 1014              		.loc 1 693 0
 1015 00fe E7D1     		bne	.L74
 1016              	.LVL88:
 1017              	.LBE35:
 1018              	.LBE36:
 337:le_phy.c      **** 			}
 1019              		.loc 1 337 0
 1020 0100 D4F87836 		ldr	r3, [r4, #1656]
 1021 0104 0531     		adds	r1, r1, #5
ARM GAS  /tmp/ccbEq2sz.s 			page 37


 1022 0106 C3F80411 		str	r1, [r3, #260]
 1023 010a C6E7     		b	.L75
 1024              	.LVL89:
 1025              	.L73:
 1026              	.LBE32:
 341:le_phy.c      **** 				// stop the CC2400 before flushing SSP
 1027              		.loc 1 341 0
 1028 010c C5D9     		bls	.L75
 341:le_phy.c      **** 				// stop the CC2400 before flushing SSP
 1029              		.loc 1 341 0 is_stmt 0 discriminator 1
 1030 010e D3F80431 		ldr	r3, [r3, #260]
 1031 0112 9A42     		cmp	r2, r3
 1032 0114 C1D3     		bcc	.L75
 343:le_phy.c      **** 
 1033              		.loc 1 343 0 is_stmt 1
 1034 0116 6120     		movs	r0, #97
 1035 0118 FFF7FEFF 		bl	cc2400_strobe
 1036              	.LVL90:
 346:le_phy.c      **** 				DMACIntTCClear = (1 << 0); // if we don't clear a second time, data is corrupt
 1037              		.loc 1 346 0
 1038 011c 0022     		movs	r2, #0
 1039 011e 2E4B     		ldr	r3, .L89+48
 1040              	.LBB37:
 351:le_phy.c      **** 				}
 1041              		.loc 1 351 0
 1042 0120 2E49     		ldr	r1, .L89+52
 1043              	.LBE37:
 346:le_phy.c      **** 				DMACIntTCClear = (1 << 0); // if we don't clear a second time, data is corrupt
 1044              		.loc 1 346 0
 1045 0122 1A60     		str	r2, [r3]
 347:le_phy.c      **** 
 1046              		.loc 1 347 0
 1047 0124 0123     		movs	r3, #1
 349:le_phy.c      **** 				while (SSP1SR & SSPSR_RNE) {
 1048              		.loc 1 349 0
 1049 0126 2E4A     		ldr	r2, .L89+56
 347:le_phy.c      **** 
 1050              		.loc 1 347 0
 1051 0128 3360     		str	r3, [r6]
 349:le_phy.c      **** 				while (SSP1SR & SSPSR_RNE) {
 1052              		.loc 1 349 0
 1053 012a 1368     		ldr	r3, [r2]
 350:le_phy.c      **** 					uint8_t tmp = (uint8_t)DIO_SSP_DR;
 1054              		.loc 1 350 0
 1055 012c 183A     		subs	r2, r2, #24
 349:le_phy.c      **** 				while (SSP1SR & SSPSR_RNE) {
 1056              		.loc 1 349 0
 1057 012e 23F00103 		bic	r3, r3, #1
 1058 0132 9361     		str	r3, [r2, #24]
 1059              	.L76:
 350:le_phy.c      **** 					uint8_t tmp = (uint8_t)DIO_SSP_DR;
 1060              		.loc 1 350 0
 1061 0134 1368     		ldr	r3, [r2]
 1062 0136 5807     		lsls	r0, r3, #29
 1063 0138 26D4     		bmi	.L77
 355:le_phy.c      **** 
 1064              		.loc 1 355 0
ARM GAS  /tmp/ccbEq2sz.s 			page 38


 1065 013a D4F87816 		ldr	r1, [r4, #1656]
 1066 013e 2948     		ldr	r0, .L89+60
 1067 0140 FFF7FEFF 		bl	queue_insert
 1068              	.LVL91:
 358:le_phy.c      **** 					++conn_event.num_packets;
 1069              		.loc 1 358 0
 1070 0144 1F4B     		ldr	r3, .L89+28
 1071 0146 1888     		ldrh	r0, [r3]
 1072 0148 80B2     		uxth	r0, r0
 1073 014a FFF7FEFF 		bl	btle_channel_index
 1074              	.LVL92:
 1075 014e 2428     		cmp	r0, #36
 1076 0150 0FD8     		bhi	.L80
 359:le_phy.c      **** 
 1077              		.loc 1 359 0
 1078 0152 254A     		ldr	r2, .L89+64
 1079 0154 5368     		ldr	r3, [r2, #4]
 1080 0156 0133     		adds	r3, r3, #1
 362:le_phy.c      **** 						conn_event.anchor = current_rxbuf->timestamp;
 1081              		.loc 1 362 0
 1082 0158 012B     		cmp	r3, #1
 359:le_phy.c      **** 
 1083              		.loc 1 359 0
 1084 015a 5360     		str	r3, [r2, #4]
 362:le_phy.c      **** 						conn_event.anchor = current_rxbuf->timestamp;
 1085              		.loc 1 362 0
 1086 015c 16D1     		bne	.L79
 363:le_phy.c      **** 						timer1_set_match(NOW + IFS_TIMEOUT); // set a timeout for next packet
 1087              		.loc 1 363 0
 1088 015e D4F87836 		ldr	r3, [r4, #1656]
 1089 0162 D3F80C31 		ldr	r3, [r3, #268]
 1090 0166 1360     		str	r3, [r2]
 364:le_phy.c      **** 					}
 1091              		.loc 1 364 0
 1092 0168 2868     		ldr	r0, [r5]
 1093 016a 00F6B830 		addw	r0, r0, #3000
 1094 016e FFF7FEFF 		bl	timer1_set_match
 1095              	.LVL93:
 1096              	.L80:
 378:le_phy.c      **** 
 1097              		.loc 1 378 0
 1098 0172 FFF7FEFF 		bl	buffer_get
 1099              	.LVL94:
 1100 0176 C4F87806 		str	r0, [r4, #1656]
 381:le_phy.c      **** 				dio_ssp_start();
 1101              		.loc 1 381 0
 1102 017a FFF7FEFF 		bl	le_dma_init
 1103              	.LVL95:
 382:le_phy.c      **** 
 1104              		.loc 1 382 0
 1105 017e FFF7FEFF 		bl	dio_ssp_start
 1106              	.LVL96:
 385:le_phy.c      **** 			}
 1107              		.loc 1 385 0
 1108 0182 FFF7FEFF 		bl	timer1_wait_fs_lock
 1109              	.LVL97:
 1110 0186 88E7     		b	.L75
ARM GAS  /tmp/ccbEq2sz.s 			page 39


 1111              	.L77:
 1112              	.LBB38:
 351:le_phy.c      **** 				}
 1113              		.loc 1 351 0
 1114 0188 0B68     		ldr	r3, [r1]
 1115 018a D3E7     		b	.L76
 1116              	.L79:
 1117              	.LBE38:
 368:le_phy.c      **** 						cc2400_strobe(SRFOFF);
 1118              		.loc 1 368 0
 1119 018c 022B     		cmp	r3, #2
 1120 018e F0D1     		bne	.L80
 369:le_phy.c      **** 						current_rxbuf = buffer_get();
 1121              		.loc 1 369 0
 1122 0190 6420     		movs	r0, #100
 1123 0192 FFF7FEFF 		bl	cc2400_strobe
 1124              	.LVL98:
 370:le_phy.c      **** 						finish_conn_event();
 1125              		.loc 1 370 0
 1126 0196 FFF7FEFF 		bl	buffer_get
 1127              	.LVL99:
 1128 019a C4F87806 		str	r0, [r4, #1656]
 395:le_phy.c      **** 
 1129              		.loc 1 395 0
 1130 019e BDE8F840 		pop	{r3, r4, r5, r6, r7, lr}
 1131              		.cfi_restore 14
 1132              		.cfi_restore 7
 1133              		.cfi_restore 6
 1134              		.cfi_restore 5
 1135              		.cfi_restore 4
 1136              		.cfi_restore 3
 1137              		.cfi_def_cfa_offset 0
 1138              	.LVL100:
 371:le_phy.c      **** 						return;
 1139              		.loc 1 371 0
 1140 01a2 FFF7FEBF 		b	finish_conn_event
 1141              	.LVL101:
 1142              	.L90:
 1143 01a6 00BF     		.align	2
 1144              	.L89:
 1145 01a8 13000000 		.word	.LC1
 1146 01ac 08800040 		.word	1073774600
 1147 01b0 00400050 		.word	1342193664
 1148 01b4 04400050 		.word	1342193668
 1149 01b8 08400050 		.word	1342193672
 1150 01bc 00000000 		.word	.LANCHOR0
 1151 01c0 00000000 		.word	le_dma_dest
 1152 01c4 00000000 		.word	rf_channel
 1153 01c8 14800040 		.word	1073774612
 1154 01cc 0C400050 		.word	1342193676
 1155 01d0 10400050 		.word	1342193680
 1156 01d4 00000000 		.word	.LANCHOR1
 1157 01d8 10410050 		.word	1342193936
 1158 01dc 08000340 		.word	1073938440
 1159 01e0 24000340 		.word	1073938468
 1160 01e4 00000000 		.word	packet_queue
 1161 01e8 00000000 		.word	conn_event
ARM GAS  /tmp/ccbEq2sz.s 			page 40


 1162              		.cfi_endproc
 1163              	.LFE7:
 1165              		.section	.text.TIMER1_IRQHandler,"ax",%progbits
 1166              		.align	1
 1167              		.global	TIMER1_IRQHandler
 1168              		.syntax unified
 1169              		.thumb
 1170              		.thumb_func
 1171              		.fpu softvfp
 1173              	TIMER1_IRQHandler:
 1174              	.LFB19:
 567:le_phy.c      **** 	// MR0: connection events
 1175              		.loc 1 567 0
 1176              		.cfi_startproc
 1177              		@ args = 0, pretend = 0, frame = 0
 1178              		@ frame_needed = 0, uses_anonymous_args = 0
 1179 0000 38B5     		push	{r3, r4, r5, lr}
 1180              		.cfi_def_cfa_offset 16
 1181              		.cfi_offset 3, -16
 1182              		.cfi_offset 4, -12
 1183              		.cfi_offset 5, -8
 1184              		.cfi_offset 14, -4
 569:le_phy.c      **** 		// ack the interrupt
 1185              		.loc 1 569 0
 1186 0002 494B     		ldr	r3, .L118
 1187 0004 1A68     		ldr	r2, [r3]
 1188 0006 D007     		lsls	r0, r2, #31
 1189 0008 5AD5     		bpl	.L92
 571:le_phy.c      **** 
 1190              		.loc 1 571 0
 1191 000a 0121     		movs	r1, #1
 1192 000c 1960     		str	r1, [r3]
 574:le_phy.c      **** 				conn.conn_event_counter == conn.conn_update_instant) {
 1193              		.loc 1 574 0
 1194 000e 474B     		ldr	r3, .L118+4
 1195 0010 474D     		ldr	r5, .L118+8
 1196 0012 D3F81021 		ldr	r2, [r3, #272]
 1197 0016 1C46     		mov	r4, r3
 1198 0018 92B3     		cbz	r2, .L93
 574:le_phy.c      **** 				conn.conn_event_counter == conn.conn_update_instant) {
 1199              		.loc 1 574 0 is_stmt 0 discriminator 1
 1200 001a B3F80C01 		ldrh	r0, [r3, #268]
 1201 001e B3F81C21 		ldrh	r2, [r3, #284]
 1202 0022 9042     		cmp	r0, r2
 1203 0024 2CD1     		bne	.L93
 579:le_phy.c      **** 				timer1_set_match(conn.last_anchor + conn.conn_interval +
 1204              		.loc 1 579 0 is_stmt 1
 1205 0026 AA68     		ldr	r2, [r5, #8]
 1206 0028 62B9     		cbnz	r2, .L94
 579:le_phy.c      **** 				timer1_set_match(conn.last_anchor + conn.conn_interval +
 1207              		.loc 1 579 0 is_stmt 0 discriminator 1
 1208 002a D86B     		ldr	r0, [r3, #60]
 1209 002c 50B1     		cbz	r0, .L94
 580:le_phy.c      **** 						conn.win_offset - RX_WARMUP_TIME);
 1210              		.loc 1 580 0 is_stmt 1
 1211 002e D3F80021 		ldr	r2, [r3, #256]
 1212 0032 1B6B     		ldr	r3, [r3, #48]
ARM GAS  /tmp/ccbEq2sz.s 			page 41


 1213 0034 1044     		add	r0, r0, r2
 1214 0036 A0F6B830 		subw	r0, r0, #3000
 1215 003a 1844     		add	r0, r0, r3
 1216 003c FFF7FEFF 		bl	timer1_set_match
 1217              	.LVL102:
 582:le_phy.c      **** 			}
 1218              		.loc 1 582 0
 1219 0040 A960     		str	r1, [r5, #8]
 1220 0042 38BD     		pop	{r3, r4, r5, pc}
 1221              	.L94:
 589:le_phy.c      **** 
 1222              		.loc 1 589 0
 1223 0044 0123     		movs	r3, #1
 1224 0046 AB60     		str	r3, [r5, #8]
 593:le_phy.c      **** 				conn.conn_interval = conn.conn_update_pending_interval;
 1225              		.loc 1 593 0
 1226 0048 0023     		movs	r3, #0
 594:le_phy.c      **** 				conn.supervision_timeout = conn.conn_update_pending_supervision_timeout;
 1227              		.loc 1 594 0
 1228 004a D4F81401 		ldr	r0, [r4, #276]
 593:le_phy.c      **** 				conn.conn_interval = conn.conn_update_pending_interval;
 1229              		.loc 1 593 0
 1230 004e C4F80431 		str	r3, [r4, #260]
 596:le_phy.c      **** 
 1231              		.loc 1 596 0
 1232 0052 C4F81031 		str	r3, [r4, #272]
 599:le_phy.c      **** 						conn.win_offset + conn.win_size + USEC(2120));
 1233              		.loc 1 599 0
 1234 0056 D4F80031 		ldr	r3, [r4, #256]
 594:le_phy.c      **** 				conn.supervision_timeout = conn.conn_update_pending_supervision_timeout;
 1235              		.loc 1 594 0
 1236 005a 2063     		str	r0, [r4, #48]
 599:le_phy.c      **** 						conn.win_offset + conn.win_size + USEC(2120));
 1237              		.loc 1 599 0
 1238 005c 1844     		add	r0, r0, r3
 1239 005e 00F5A540 		add	r0, r0, #21120
 1240 0062 E36B     		ldr	r3, [r4, #60]
 1241 0064 5030     		adds	r0, r0, #80
 1242 0066 1844     		add	r0, r0, r3
 600:le_phy.c      **** 				change_channel();
 1243              		.loc 1 600 0
 1244 0068 94F83830 		ldrb	r3, [r4, #56]	@ zero_extendqisi2
 595:le_phy.c      **** 				conn.conn_update_pending = 0;
 1245              		.loc 1 595 0
 1246 006c D4F81821 		ldr	r2, [r4, #280]
 599:le_phy.c      **** 						conn.win_offset + conn.win_size + USEC(2120));
 1247              		.loc 1 599 0
 1248 0070 1844     		add	r0, r0, r3
 595:le_phy.c      **** 				conn.conn_update_pending = 0;
 1249              		.loc 1 595 0
 1250 0072 6263     		str	r2, [r4, #52]
 599:le_phy.c      **** 						conn.win_offset + conn.win_size + USEC(2120));
 1251              		.loc 1 599 0
 1252 0074 FFF7FEFF 		bl	timer1_set_match
 1253              	.LVL103:
 668:le_phy.c      **** 
 1254              		.loc 1 668 0
ARM GAS  /tmp/ccbEq2sz.s 			page 42


 1255 0078 BDE83840 		pop	{r3, r4, r5, lr}
 1256              		.cfi_remember_state
 1257              		.cfi_restore 14
 1258              		.cfi_restore 5
 1259              		.cfi_restore 4
 1260              		.cfi_restore 3
 1261              		.cfi_def_cfa_offset 0
 601:le_phy.c      **** 			}
 1262              		.loc 1 601 0
 1263 007c FFF7FEBF 		b	change_channel
 1264              	.LVL104:
 1265              	.L93:
 1266              		.cfi_restore_state
 607:le_phy.c      **** 				conn.conn_event_counter == conn.channel_map_update_instant) {
 1267              		.loc 1 607 0
 1268 0080 D4F82031 		ldr	r3, [r4, #288]
 1269 0084 73B1     		cbz	r3, .L96
 607:le_phy.c      **** 				conn.conn_event_counter == conn.channel_map_update_instant) {
 1270              		.loc 1 607 0 is_stmt 0 discriminator 1
 1271 0086 B4F80C21 		ldrh	r2, [r4, #268]
 1272 008a B4F82431 		ldrh	r3, [r4, #292]
 1273 008e 9A42     		cmp	r2, r3
 1274 0090 08D1     		bne	.L96
 609:le_phy.c      **** 			conn.channel_map_update_pending = 0;
 1275              		.loc 1 609 0 is_stmt 1
 1276 0092 2849     		ldr	r1, .L118+12
 1277 0094 C022     		movs	r2, #192
 1278 0096 A1F1E800 		sub	r0, r1, #232
 1279 009a FFF7FEFF 		bl	memcpy
 1280              	.LVL105:
 610:le_phy.c      **** 		}
 1281              		.loc 1 610 0
 1282 009e 0023     		movs	r3, #0
 1283 00a0 C4F82031 		str	r3, [r4, #288]
 1284              	.L96:
 614:le_phy.c      **** 			conn_event.opened = 1;
 1285              		.loc 1 614 0
 1286 00a4 AB68     		ldr	r3, [r5, #8]
 1287 00a6 002B     		cmp	r3, #0
 1288 00a8 35D1     		bne	.L97
 615:le_phy.c      **** 			// timeout is max packet length + warmup time (slack)
 1289              		.loc 1 615 0
 1290 00aa 0123     		movs	r3, #1
 1291 00ac AB60     		str	r3, [r5, #8]
 617:le_phy.c      **** 			change_channel();
 1292              		.loc 1 617 0
 1293 00ae 224B     		ldr	r3, .L118+16
 1294 00b0 1868     		ldr	r0, [r3]
 1295 00b2 00F5BD40 		add	r0, r0, #24192
 1296 00b6 0830     		adds	r0, r0, #8
 1297 00b8 FFF7FEFF 		bl	timer1_set_match
 1298              	.LVL106:
 618:le_phy.c      **** 		}
 1299              		.loc 1 618 0
 1300 00bc FFF7FEFF 		bl	change_channel
 1301              	.LVL107:
 1302              	.L92:
ARM GAS  /tmp/ccbEq2sz.s 			page 43


 644:le_phy.c      **** 		T1IR = TIR_MR1_Interrupt;
 1303              		.loc 1 644 0
 1304 00c0 194B     		ldr	r3, .L118
 1305 00c2 1A68     		ldr	r2, [r3]
 1306 00c4 9107     		lsls	r1, r2, #30
 1307 00c6 0DD5     		bpl	.L98
 645:le_phy.c      **** 		T1MCR &= ~TMCR_MR1I;
 1308              		.loc 1 645 0
 1309 00c8 0222     		movs	r2, #2
 646:le_phy.c      **** 
 1310              		.loc 1 646 0
 1311 00ca 1C49     		ldr	r1, .L118+20
 645:le_phy.c      **** 		T1MCR &= ~TMCR_MR1I;
 1312              		.loc 1 645 0
 1313 00cc 1A60     		str	r2, [r3]
 646:le_phy.c      **** 
 1314              		.loc 1 646 0
 1315 00ce 0B68     		ldr	r3, [r1]
 1316 00d0 23F00803 		bic	r3, r3, #8
 1317 00d4 0B60     		str	r3, [r1]
 648:le_phy.c      **** 		RXLED_CLR;
 1318              		.loc 1 648 0
 1319 00d6 4FF48071 		mov	r1, #256
 1320 00da 194B     		ldr	r3, .L118+24
 1321 00dc 1960     		str	r1, [r3]
 649:le_phy.c      **** 		USRLED_CLR;
 1322              		.loc 1 649 0
 1323 00de 1021     		movs	r1, #16
 1324 00e0 1960     		str	r1, [r3]
 650:le_phy.c      **** 	}
 1325              		.loc 1 650 0
 1326 00e2 1A60     		str	r2, [r3]
 1327              	.L98:
 654:le_phy.c      **** 		T1IR = TIR_MR2_Interrupt;
 1328              		.loc 1 654 0
 1329 00e4 104B     		ldr	r3, .L118
 1330 00e6 1A68     		ldr	r2, [r3]
 1331 00e8 5207     		lsls	r2, r2, #29
 1332 00ea 1BD5     		bpl	.L91
 655:le_phy.c      **** 
 1333              		.loc 1 655 0
 1334 00ec 0422     		movs	r2, #4
 1335 00ee 1A60     		str	r2, [r3]
 658:le_phy.c      **** 			le_cc2400_strobe_rx();
 1336              		.loc 1 658 0
 1337 00f0 FFF7FEFF 		bl	cc2400_status
 1338              	.LVL108:
 1339 00f4 4307     		lsls	r3, r0, #29
 1340 00f6 11D5     		bpl	.L99
 1341              	.LBB41:
 1342              	.LBB42:
 490:le_phy.c      **** #ifdef UBERTOOTH_ONE
 1343              		.loc 1 490 0
 1344 00f8 6220     		movs	r0, #98
 1345 00fa FFF7FEFF 		bl	cc2400_strobe
 1346              	.LVL109:
 492:le_phy.c      **** 	HGM_SET;
ARM GAS  /tmp/ccbEq2sz.s 			page 44


 1347              		.loc 1 492 0
 1348 00fe 8022     		movs	r2, #128
 1349 0100 104B     		ldr	r3, .L118+28
 1350 0102 1A60     		str	r2, [r3]
 493:le_phy.c      **** #endif
 1351              		.loc 1 493 0
 1352 0104 4FF48072 		mov	r2, #256
 1353 0108 1A60     		str	r2, [r3]
 1354              	.LBE42:
 1355              	.LBE41:
 660:le_phy.c      **** 		}
 1356              		.loc 1 660 0
 1357 010a 0C4A     		ldr	r2, .L118+20
 1358 010c 1368     		ldr	r3, [r2]
 1359 010e 23F04003 		bic	r3, r3, #64
 1360 0112 1360     		str	r3, [r2]
 1361 0114 38BD     		pop	{r3, r4, r5, pc}
 1362              	.L97:
 638:le_phy.c      **** 			}
 1363              		.loc 1 638 0
 1364 0116 FFF7FEFF 		bl	finish_conn_event
 1365              	.LVL110:
 1366 011a D1E7     		b	.L92
 1367              	.L99:
 668:le_phy.c      **** 
 1368              		.loc 1 668 0
 1369 011c BDE83840 		pop	{r3, r4, r5, lr}
 1370              		.cfi_remember_state
 1371              		.cfi_restore 14
 1372              		.cfi_restore 5
 1373              		.cfi_restore 4
 1374              		.cfi_restore 3
 1375              		.cfi_def_cfa_offset 0
 665:le_phy.c      **** 		}
 1376              		.loc 1 665 0
 1377 0120 FFF7FEBF 		b	timer1_wait_fs_lock
 1378              	.LVL111:
 1379              	.L91:
 1380              		.cfi_restore_state
 1381 0124 38BD     		pop	{r3, r4, r5, pc}
 1382              	.L119:
 1383 0126 00BF     		.align	2
 1384              	.L118:
 1385 0128 00800040 		.word	1073774592
 1386 012c 00000000 		.word	.LANCHOR0
 1387 0130 00000000 		.word	conn_event
 1388 0134 28010000 		.word	.LANCHOR0+296
 1389 0138 08800040 		.word	1073774600
 1390 013c 14800040 		.word	1073774612
 1391 0140 3CC00920 		.word	537509948
 1392 0144 58C00920 		.word	537509976
 1393              		.cfi_endproc
 1394              	.LFE19:
 1396              		.section	.text.le_phy_main,"ax",%progbits
 1397              		.align	1
 1398              		.global	le_phy_main
 1399              		.syntax unified
ARM GAS  /tmp/ccbEq2sz.s 			page 45


 1400              		.thumb
 1401              		.thumb_func
 1402              		.fpu softvfp
 1404              	le_phy_main:
 1405              	.LFB30:
 875:le_phy.c      **** 
 876:le_phy.c      **** static int filter_match(le_rx_t *buf) {
 877:le_phy.c      **** 	if (!le.target_set)
 878:le_phy.c      **** 		return 1;
 879:le_phy.c      **** 
 880:le_phy.c      **** 	// allow all data channel packets
 881:le_phy.c      **** 	if (btle_channel_index(buf->channel) < 37)
 882:le_phy.c      **** 		return 1;
 883:le_phy.c      **** 
 884:le_phy.c      **** 	switch (buf->data[0] & 0xf) {
 885:le_phy.c      **** 		// ADV_IND, ADV_NONCONN_IND, ADV_SCAN_IND, SCAN_RSP
 886:le_phy.c      **** 		case 0x00:
 887:le_phy.c      **** 		case 0x02:
 888:le_phy.c      **** 		case 0x06:
 889:le_phy.c      **** 		case 0x04:
 890:le_phy.c      **** 			// header + one address
 891:le_phy.c      **** 			if (buf->size < 2 + 6)
 892:le_phy.c      **** 				return 0;
 893:le_phy.c      **** 			return bd_addr_cmp(&buf->data[2]);
 894:le_phy.c      **** 			break;
 895:le_phy.c      **** 
 896:le_phy.c      **** 		// ADV_DIRECT_IND, SCAN_REQ, CONNECT_REQ
 897:le_phy.c      **** 		case 0x01:
 898:le_phy.c      **** 		case 0x03:
 899:le_phy.c      **** 		case 0x05:
 900:le_phy.c      **** 			// header + two addresses
 901:le_phy.c      **** 			if (buf->size < 2 + 6 + 6)
 902:le_phy.c      **** 				return 0;
 903:le_phy.c      **** 			return bd_addr_cmp(&buf->data[2]) ||
 904:le_phy.c      **** 				   bd_addr_cmp(&buf->data[8]);
 905:le_phy.c      **** 			break;
 906:le_phy.c      **** 
 907:le_phy.c      **** 		default:
 908:le_phy.c      **** 			break;
 909:le_phy.c      **** 	}
 910:le_phy.c      **** 
 911:le_phy.c      **** 	return 0;
 912:le_phy.c      **** }
 913:le_phy.c      **** 
 914:le_phy.c      **** void le_phy_main(void) {
 1406              		.loc 1 914 0
 1407              		.cfi_startproc
 1408              		@ args = 0, pretend = 0, frame = 24
 1409              		@ frame_needed = 0, uses_anonymous_args = 0
 1410 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 1411              		.cfi_def_cfa_offset 36
 1412              		.cfi_offset 4, -36
 1413              		.cfi_offset 5, -32
 1414              		.cfi_offset 6, -28
 1415              		.cfi_offset 7, -24
 1416              		.cfi_offset 8, -20
 1417              		.cfi_offset 9, -16
ARM GAS  /tmp/ccbEq2sz.s 			page 46


 1418              		.cfi_offset 10, -12
 1419              		.cfi_offset 11, -8
 1420              		.cfi_offset 14, -4
 1421 0004 87B0     		sub	sp, sp, #28
 1422              		.cfi_def_cfa_offset 64
 915:le_phy.c      **** 	// disable USB interrupts -- we poll them below
 916:le_phy.c      **** 	// n.b., they should not be enabled but let's be careful
 917:le_phy.c      **** 	ICER0 = ICER0_ICE_USB;
 1423              		.loc 1 917 0
 1424 0006 4FF08073 		mov	r3, #16777216
 1425              	.LBB72:
 1426              	.LBB73:
 166:le_phy.c      **** }
 1427              		.loc 1 166 0
 1428 000a 0125     		movs	r5, #1
 1429              	.LBE73:
 1430              	.LBE72:
 1431              		.loc 1 917 0
 1432 000c DFF85083 		ldr	r8, .L160+76
 1433              	.LBB76:
 1434              	.LBB74:
 166:le_phy.c      **** }
 1435              		.loc 1 166 0
 1436 0010 C04C     		ldr	r4, .L160
 1437              	.LBE74:
 1438              	.LBE76:
 1439              		.loc 1 917 0
 1440 0012 C8F80030 		str	r3, [r8]
 918:le_phy.c      **** 	// disable clkn and timer0
 919:le_phy.c      **** 	clkn_disable();
 1441              		.loc 1 919 0
 1442 0016 FFF7FEFF 		bl	clkn_disable
 1443              	.LVL112:
 920:le_phy.c      **** 
 921:le_phy.c      **** 	buffers_init();
 922:le_phy.c      **** 	queue_init(&packet_queue);
 1444              		.loc 1 922 0
 1445 001a BF48     		ldr	r0, .L160+4
 1446              	.LBB77:
 1447              	.LBB75:
 166:le_phy.c      **** }
 1448              		.loc 1 166 0
 1449 001c C4F80053 		str	r5, [r4, #768]
 1450              	.LVL113:
 1451 0020 C4F82454 		str	r5, [r4, #1060]
 1452              	.LVL114:
 1453 0024 C4F84855 		str	r5, [r4, #1352]
 1454              	.LVL115:
 1455 0028 C4F86C56 		str	r5, [r4, #1644]
 1456              	.LVL116:
 1457              	.LBE75:
 1458              	.LBE77:
 1459              		.loc 1 922 0
 1460 002c FFF7FEFF 		bl	queue_init
 1461              	.LVL117:
 1462              	.LBB78:
 1463              	.LBB79:
ARM GAS  /tmp/ccbEq2sz.s 			page 47


 534:le_phy.c      **** 	T1PR = 4; // 100 ns
 1464              		.loc 1 534 0
 1465 0030 0223     		movs	r3, #2
 1466 0032 BA4E     		ldr	r6, .L160+8
 535:le_phy.c      **** 	T1TCR = TCR_Counter_Enable;
 1467              		.loc 1 535 0
 1468 0034 BA4A     		ldr	r2, .L160+12
 534:le_phy.c      **** 	T1PR = 4; // 100 ns
 1469              		.loc 1 534 0
 1470 0036 3360     		str	r3, [r6]
 535:le_phy.c      **** 	T1TCR = TCR_Counter_Enable;
 1471              		.loc 1 535 0
 1472 0038 0423     		movs	r3, #4
 1473 003a 1360     		str	r3, [r2]
 539:le_phy.c      **** }
 1474              		.loc 1 539 0
 1475 003c B94A     		ldr	r2, .L160+16
 536:le_phy.c      **** 
 1476              		.loc 1 536 0
 1477 003e 3560     		str	r5, [r6]
 539:le_phy.c      **** }
 1478              		.loc 1 539 0
 1479 0040 1360     		str	r3, [r2]
 1480              	.LBE79:
 1481              	.LBE78:
 923:le_phy.c      **** 	timer1_start();
 924:le_phy.c      **** 
 925:le_phy.c      **** 	current_rxbuf = buffer_get();
 1482              		.loc 1 925 0
 1483 0042 FFF7FEFF 		bl	buffer_get
 1484              	.LVL118:
 926:le_phy.c      **** 	rf_channel = le_adv_channel; // FIXME
 1485              		.loc 1 926 0
 1486 0046 B84B     		ldr	r3, .L160+20
 1487 0048 B84A     		ldr	r2, .L160+24
 1488 004a 1B88     		ldrh	r3, [r3]
 925:le_phy.c      **** 	rf_channel = le_adv_channel; // FIXME
 1489              		.loc 1 925 0
 1490 004c C4F87806 		str	r0, [r4, #1656]
 1491              		.loc 1 926 0
 1492 0050 9BB2     		uxth	r3, r3
 1493 0052 1380     		strh	r3, [r2]	@ movhi
 927:le_phy.c      **** 	conn.access_address = ADVERTISING_AA;
 1494              		.loc 1 927 0
 1495 0054 B64B     		ldr	r3, .L160+28
 928:le_phy.c      **** 	le_sys_init();
 929:le_phy.c      **** 	le_cc2400_init_rf();
 930:le_phy.c      **** 
 931:le_phy.c      **** 	cancel_follow = 0;
 1496              		.loc 1 931 0
 1497 0056 B74F     		ldr	r7, .L160+32
 927:le_phy.c      **** 	conn.access_address = ADVERTISING_AA;
 1498              		.loc 1 927 0
 1499 0058 2362     		str	r3, [r4, #32]
 1500              	.LBB80:
 1501              	.LBB81:
 435:le_phy.c      **** 	dio_ssp_init();   // init SSP and raise !CS (self-routed GPIO)
ARM GAS  /tmp/ccbEq2sz.s 			page 48


 1502              		.loc 1 435 0
 1503 005a FFF7FEFF 		bl	usb_queue_init
 1504              	.LVL119:
 436:le_phy.c      **** 	le_dma_init();    // prepare DMA + interrupts
 1505              		.loc 1 436 0
 1506 005e FFF7FEFF 		bl	dio_ssp_init
 1507              	.LVL120:
 437:le_phy.c      **** 	dio_ssp_start();  // enable SSP + DMA
 1508              		.loc 1 437 0
 1509 0062 FFF7FEFF 		bl	le_dma_init
 1510              	.LVL121:
 438:le_phy.c      **** }
 1511              		.loc 1 438 0
 1512 0066 FFF7FEFF 		bl	dio_ssp_start
 1513              	.LVL122:
 1514              	.LBE81:
 1515              	.LBE80:
 929:le_phy.c      **** 
 1516              		.loc 1 929 0
 1517 006a FFF7FEFF 		bl	le_cc2400_init_rf
 1518              	.LVL123:
 1519              		.loc 1 931 0
 1520 006e 0020     		movs	r0, #0
 1521              	.LBB82:
 1522              	.LBB83:
 1523              	.LBB84:
 680:le_phy.c      **** }
 1524              		.loc 1 680 0
 1525 0070 DFF8F092 		ldr	r9, .L160+80
 1526              	.LBE84:
 1527              	.LBE83:
 1528              	.LBE82:
 1529              		.loc 1 931 0
 1530 0074 3860     		str	r0, [r7]
 932:le_phy.c      **** 	debug_uart_init(0);
 1531              		.loc 1 932 0
 1532 0076 FFF7FEFF 		bl	debug_uart_init
 1533              	.LVL124:
 1534 007a CDF80480 		str	r8, [sp, #4]
 1535 007e 0296     		str	r6, [sp, #8]
 1536              	.L121:
 933:le_phy.c      **** 	while (requested_mode == MODE_BT_FOLLOW_LE) {
 1537              		.loc 1 933 0
 1538 0080 AD4B     		ldr	r3, .L160+36
 1539 0082 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1540 0084 092B     		cmp	r3, #9
 1541 0086 11D0     		beq	.L138
 1542              	.LBB123:
 1543              	.LBB124:
 543:le_phy.c      **** 
 1544              		.loc 1 543 0
 1545 0088 0222     		movs	r2, #2
 1546 008a 029B     		ldr	r3, [sp, #8]
 546:le_phy.c      **** }
 1547              		.loc 1 546 0
 1548 008c 0199     		ldr	r1, [sp, #4]
 543:le_phy.c      **** 
ARM GAS  /tmp/ccbEq2sz.s 			page 49


 1549              		.loc 1 543 0
 1550 008e 1A60     		str	r2, [r3]
 546:le_phy.c      **** }
 1551              		.loc 1 546 0
 1552 0090 0423     		movs	r3, #4
 1553 0092 0B60     		str	r3, [r1]
 1554              	.LBE124:
 1555              	.LBE123:
 934:le_phy.c      **** 		le_rx_t *packet = NULL;
 935:le_phy.c      **** 		if (queue_remove(&packet_queue, (void **)&packet)) {
 936:le_phy.c      **** 			le_dewhiten(packet->data, packet->size, packet->channel);
 937:le_phy.c      **** 
 938:le_phy.c      **** 			if (filter_match(packet)) {
 939:le_phy.c      **** 				blink(0, 1, 0); // RX LED
 940:le_phy.c      **** 				usb_enqueue_le(packet);
 941:le_phy.c      **** 				packet_handler(packet);
 942:le_phy.c      **** 			}
 943:le_phy.c      **** 
 944:le_phy.c      **** 			buffer_release(packet);
 945:le_phy.c      **** 		}
 946:le_phy.c      **** 
 947:le_phy.c      **** 		// polled USB handling
 948:le_phy.c      **** 		handle_usb(0);
 949:le_phy.c      **** 
 950:le_phy.c      **** 		// XXX maybe LED light show?
 951:le_phy.c      **** 	}
 952:le_phy.c      **** 
 953:le_phy.c      **** 	timer1_stop();
 954:le_phy.c      **** 
 955:le_phy.c      **** 	// reset state
 956:le_phy.c      **** 	RXLED_CLR;
 1556              		.loc 1 956 0
 1557 0094 1021     		movs	r1, #16
 1558 0096 A94B     		ldr	r3, .L160+40
 1559 0098 1960     		str	r1, [r3]
 957:le_phy.c      **** 	TXLED_CLR;
 1560              		.loc 1 957 0
 1561 009a 4FF48071 		mov	r1, #256
 1562 009e 1960     		str	r1, [r3]
 958:le_phy.c      **** 	USRLED_CLR;
 1563              		.loc 1 958 0
 1564 00a0 1A60     		str	r2, [r3]
 959:le_phy.c      **** 	clkn_init();
 1565              		.loc 1 959 0
 1566 00a2 FFF7FEFF 		bl	clkn_init
 1567              	.LVL125:
 960:le_phy.c      **** 
 961:le_phy.c      **** 	// TODO kill CC2400
 962:le_phy.c      **** }
 1568              		.loc 1 962 0
 1569 00a6 07B0     		add	sp, sp, #28
 1570              		.cfi_remember_state
 1571              		.cfi_def_cfa_offset 36
 1572              		@ sp needed
 1573 00a8 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1574              	.L138:
 1575              		.cfi_restore_state
ARM GAS  /tmp/ccbEq2sz.s 			page 50


 1576              	.LBB125:
 934:le_phy.c      **** 		if (queue_remove(&packet_queue, (void **)&packet)) {
 1577              		.loc 1 934 0
 1578 00ac 0023     		movs	r3, #0
 1579 00ae 06A9     		add	r1, sp, #24
 1580 00b0 41F8043D 		str	r3, [r1, #-4]!
 935:le_phy.c      **** 			le_dewhiten(packet->data, packet->size, packet->channel);
 1581              		.loc 1 935 0
 1582 00b4 9848     		ldr	r0, .L160+4
 1583 00b6 FFF7FEFF 		bl	queue_remove
 1584              	.LVL126:
 1585 00ba 0028     		cmp	r0, #0
 1586 00bc 00F0DD80 		beq	.L122
 936:le_phy.c      **** 
 1587              		.loc 1 936 0
 1588 00c0 0598     		ldr	r0, [sp, #20]
 1589              	.LBB87:
 1590              	.LBB88:
 877:le_phy.c      **** 		return 1;
 1591              		.loc 1 877 0
 1592 00c2 9F4E     		ldr	r6, .L160+44
 1593              	.LBE88:
 1594              	.LBE87:
 936:le_phy.c      **** 
 1595              		.loc 1 936 0
 1596 00c4 D0F81021 		ldr	r2, [r0, #272]
 1597 00c8 D0F80411 		ldr	r1, [r0, #260]
 1598 00cc FFF7FEFF 		bl	le_dewhiten
 1599              	.LVL127:
 1600              	.LBB92:
 1601              	.LBB89:
 877:le_phy.c      **** 		return 1;
 1602              		.loc 1 877 0
 1603 00d0 736C     		ldr	r3, [r6, #68]
 1604 00d2 002B     		cmp	r3, #0
 1605 00d4 40F0B880 		bne	.L123
 1606              	.LVL128:
 1607              	.L126:
 1608              	.LBE89:
 1609              	.LBE92:
 1610              	.LBB93:
 1611              	.LBB85:
 674:le_phy.c      **** 	if (usr)
 1612              		.loc 1 674 0
 1613 00d8 1023     		movs	r3, #16
 1614 00da 9A4A     		ldr	r2, .L160+48
 1615              	.LBE85:
 1616              	.LBE93:
 940:le_phy.c      **** 				packet_handler(packet);
 1617              		.loc 1 940 0
 1618 00dc DDF81480 		ldr	r8, [sp, #20]
 1619              	.LBB94:
 1620              	.LBB86:
 674:le_phy.c      **** 	if (usr)
 1621              		.loc 1 674 0
 1622 00e0 1360     		str	r3, [r2]
 679:le_phy.c      **** 	T1MCR |= TMCR_MR1I;
ARM GAS  /tmp/ccbEq2sz.s 			page 51


 1623              		.loc 1 679 0
 1624 00e2 994B     		ldr	r3, .L160+52
 1625 00e4 994A     		ldr	r2, .L160+56
 1626 00e6 1B68     		ldr	r3, [r3]
 1627 00e8 03F5C333 		add	r3, r3, #99840
 1628 00ec A033     		adds	r3, r3, #160
 1629 00ee 1360     		str	r3, [r2]
 680:le_phy.c      **** }
 1630              		.loc 1 680 0
 1631 00f0 D9F80030 		ldr	r3, [r9]
 1632 00f4 43F00803 		orr	r3, r3, #8
 1633 00f8 C9F80030 		str	r3, [r9]
 1634              	.LVL129:
 1635              	.LBE86:
 1636              	.LBE94:
 1637              	.LBB95:
 1638              	.LBB96:
 707:le_phy.c      **** 
 1639              		.loc 1 707 0
 1640 00fc FFF7FEFF 		bl	usb_enqueue
 1641              	.LVL130:
 710:le_phy.c      **** 		return 0;
 1642              		.loc 1 710 0
 1643 0100 0546     		mov	r5, r0
 1644 0102 0028     		cmp	r0, #0
 1645 0104 40F0D480 		bne	.L157
 1646              	.LVL131:
 1647              	.L124:
 1648              	.LBE96:
 1649              	.LBE95:
 941:le_phy.c      **** 			}
 1650              		.loc 1 941 0
 1651 0108 059D     		ldr	r5, [sp, #20]
 1652              	.LVL132:
 1653              	.LBB98:
 1654              	.LBB99:
 836:le_phy.c      **** 		switch (buf->data[0] & 0xf) {
 1655              		.loc 1 836 0
 1656 010a B5F81001 		ldrh	r0, [r5, #272]
 1657 010e FFF7FEFF 		bl	btle_channel_index
 1658              	.LVL133:
 1659 0112 2428     		cmp	r0, #36
 1660 0114 2978     		ldrb	r1, [r5]	@ zero_extendqisi2
 1661 0116 40F22781 		bls	.L132
 837:le_phy.c      **** 			// CONNECT_REQ
 1662              		.loc 1 837 0
 1663 011a 01F00F01 		and	r1, r1, #15
 1664 011e 0529     		cmp	r1, #5
 1665 0120 40F0A780 		bne	.L128
 1666              	.LVL134:
 1667              	.LBB100:
 1668              	.LBB101:
 747:le_phy.c      **** 		return;
 1669              		.loc 1 747 0
 1670 0124 736B     		ldr	r3, [r6, #52]
 1671 0126 002B     		cmp	r3, #0
 1672 0128 00F0A380 		beq	.L128
ARM GAS  /tmp/ccbEq2sz.s 			page 52


 750:le_phy.c      **** 		return;
 1673              		.loc 1 750 0
 1674 012c D5F80431 		ldr	r3, [r5, #260]
 1675 0130 272B     		cmp	r3, #39
 1676 0132 40F09E80 		bne	.L128
 754:le_phy.c      **** 		cancel_follow = 0;
 1677              		.loc 1 754 0
 1678 0136 3B68     		ldr	r3, [r7]
 1679 0138 0BB1     		cbz	r3, .L134
 755:le_phy.c      **** 
 1680              		.loc 1 755 0
 1681 013a 0023     		movs	r3, #0
 1682 013c 3B60     		str	r3, [r7]
 1683              	.L134:
 757:le_phy.c      **** 	conn.crc_init           = extract_field(buf, 18, 3);
 1684              		.loc 1 757 0
 1685 013e 0422     		movs	r2, #4
 1686 0140 0E21     		movs	r1, #14
 1687 0142 2846     		mov	r0, r5
 1688 0144 FFF7FEFF 		bl	extract_field
 1689              	.LVL135:
 758:le_phy.c      **** 	conn.crc_init_reversed  = rbit(conn.crc_init);
 1690              		.loc 1 758 0
 1691 0148 0322     		movs	r2, #3
 1692 014a 1221     		movs	r1, #18
 757:le_phy.c      **** 	conn.crc_init           = extract_field(buf, 18, 3);
 1693              		.loc 1 757 0
 1694 014c 2062     		str	r0, [r4, #32]
 758:le_phy.c      **** 	conn.crc_init_reversed  = rbit(conn.crc_init);
 1695              		.loc 1 758 0
 1696 014e 2846     		mov	r0, r5
 1697 0150 FFF7FEFF 		bl	extract_field
 1698              	.LVL136:
 1699 0154 6062     		str	r0, [r4, #36]
 759:le_phy.c      **** 	conn.win_size           = extract_field(buf, 21, 1);
 1700              		.loc 1 759 0
 1701 0156 FFF7FEFF 		bl	rbit
 1702              	.LVL137:
 760:le_phy.c      **** 	conn.win_offset         = extract_field(buf, 22, 2);
 1703              		.loc 1 760 0
 1704 015a 0122     		movs	r2, #1
 759:le_phy.c      **** 	conn.win_size           = extract_field(buf, 21, 1);
 1705              		.loc 1 759 0
 1706 015c A062     		str	r0, [r4, #40]
 760:le_phy.c      **** 	conn.win_offset         = extract_field(buf, 22, 2);
 1707              		.loc 1 760 0
 1708 015e 1521     		movs	r1, #21
 1709 0160 2846     		mov	r0, r5
 1710 0162 FFF7FEFF 		bl	extract_field
 1711              	.LVL138:
 761:le_phy.c      **** 	conn.conn_interval      = extract_field(buf, 24, 2);
 1712              		.loc 1 761 0
 1713 0166 0222     		movs	r2, #2
 760:le_phy.c      **** 	conn.win_offset         = extract_field(buf, 22, 2);
 1714              		.loc 1 760 0
 1715 0168 84F83800 		strb	r0, [r4, #56]
 761:le_phy.c      **** 	conn.conn_interval      = extract_field(buf, 24, 2);
ARM GAS  /tmp/ccbEq2sz.s 			page 53


 1716              		.loc 1 761 0
 1717 016c 1621     		movs	r1, #22
 760:le_phy.c      **** 	conn.win_offset         = extract_field(buf, 22, 2);
 1718              		.loc 1 760 0
 1719 016e 8246     		mov	r10, r0
 761:le_phy.c      **** 	conn.conn_interval      = extract_field(buf, 24, 2);
 1720              		.loc 1 761 0
 1721 0170 2846     		mov	r0, r5
 1722 0172 FFF7FEFF 		bl	extract_field
 1723              	.LVL139:
 762:le_phy.c      **** 	conn.supervision_timeout = extract_field(buf, 28, 2);
 1724              		.loc 1 762 0
 1725 0176 0222     		movs	r2, #2
 761:le_phy.c      **** 	conn.conn_interval      = extract_field(buf, 24, 2);
 1726              		.loc 1 761 0
 1727 0178 E063     		str	r0, [r4, #60]
 762:le_phy.c      **** 	conn.supervision_timeout = extract_field(buf, 28, 2);
 1728              		.loc 1 762 0
 1729 017a 1821     		movs	r1, #24
 761:le_phy.c      **** 	conn.conn_interval      = extract_field(buf, 24, 2);
 1730              		.loc 1 761 0
 1731 017c 8046     		mov	r8, r0
 762:le_phy.c      **** 	conn.supervision_timeout = extract_field(buf, 28, 2);
 1732              		.loc 1 762 0
 1733 017e 2846     		mov	r0, r5
 1734 0180 FFF7FEFF 		bl	extract_field
 1735              	.LVL140:
 763:le_phy.c      **** 	conn.hop_increment      = extract_field(buf, 35, 1) & 0x1f;
 1736              		.loc 1 763 0
 1737 0184 0222     		movs	r2, #2
 762:le_phy.c      **** 	conn.supervision_timeout = extract_field(buf, 28, 2);
 1738              		.loc 1 762 0
 1739 0186 0646     		mov	r6, r0
 1740 0188 2063     		str	r0, [r4, #48]
 763:le_phy.c      **** 	conn.hop_increment      = extract_field(buf, 35, 1) & 0x1f;
 1741              		.loc 1 763 0
 1742 018a 1C21     		movs	r1, #28
 1743 018c 2846     		mov	r0, r5
 1744 018e FFF7FEFF 		bl	extract_field
 1745              	.LVL141:
 764:le_phy.c      **** 
 1746              		.loc 1 764 0
 1747 0192 0122     		movs	r2, #1
 763:le_phy.c      **** 	conn.hop_increment      = extract_field(buf, 35, 1) & 0x1f;
 1748              		.loc 1 763 0
 1749 0194 6063     		str	r0, [r4, #52]
 1750 0196 8346     		mov	fp, r0
 764:le_phy.c      **** 
 1751              		.loc 1 764 0
 1752 0198 2321     		movs	r1, #35
 1753 019a 2846     		mov	r0, r5
 1754 019c FFF7FEFF 		bl	extract_field
 1755              	.LVL142:
 766:le_phy.c      **** 		goto err_out;
 1756              		.loc 1 766 0
 1757 01a0 40F67A43 		movw	r3, #3194
 1758 01a4 B21F     		subs	r2, r6, #6
ARM GAS  /tmp/ccbEq2sz.s 			page 54


 764:le_phy.c      **** 
 1759              		.loc 1 764 0
 1760 01a6 00F01F00 		and	r0, r0, #31
 766:le_phy.c      **** 		goto err_out;
 1761              		.loc 1 766 0
 1762 01aa 9A42     		cmp	r2, r3
 764:le_phy.c      **** 
 1763              		.loc 1 764 0
 1764 01ac 84F82D00 		strb	r0, [r4, #45]
 766:le_phy.c      **** 		goto err_out;
 1765              		.loc 1 766 0
 1766 01b0 00F2AD80 		bhi	.L135
 769:le_phy.c      **** 	}
 1767              		.loc 1 769 0
 1768 01b4 43F2D403 		movw	r3, #12500
 1769 01b8 5E43     		muls	r6, r3, r6
 773:le_phy.c      **** 	if (conn.win_offset > conn.conn_interval)
 1770              		.loc 1 773 0
 1771 01ba 03FB08F2 		mul	r2, r3, r8
 774:le_phy.c      **** 		goto err_out;
 1772              		.loc 1 774 0
 1773 01be 9642     		cmp	r6, r2
 769:le_phy.c      **** 	}
 1774              		.loc 1 769 0
 1775 01c0 2663     		str	r6, [r4, #48]
 773:le_phy.c      **** 	if (conn.win_offset > conn.conn_interval)
 1776              		.loc 1 773 0
 1777 01c2 E263     		str	r2, [r4, #60]
 774:le_phy.c      **** 		goto err_out;
 1778              		.loc 1 774 0
 1779 01c4 C0F0A380 		bcc	.L135
 778:le_phy.c      **** 	max_win_size = conn.conn_interval - USEC(1250);
 1780              		.loc 1 778 0
 1781 01c8 5FFA8AFA 		uxtb	r10, r10
 1782 01cc 03FB0AFA 		mul	r10, r3, r10
 1783              	.LVL143:
 782:le_phy.c      **** 		goto err_out;
 1784              		.loc 1 782 0
 1785 01d0 43F2D303 		movw	r3, #12499
 1786 01d4 9A45     		cmp	r10, r3
 1787 01d6 40F39A80 		ble	.L135
 1788 01da 5D4B     		ldr	r3, .L160+60
 779:le_phy.c      **** 	if (max_win_size > MSEC(10))
 1789              		.loc 1 779 0
 1790 01dc A6F54356 		sub	r6, r6, #12480
 1791              	.LVL144:
 1792 01e0 143E     		subs	r6, r6, #20
 782:le_phy.c      **** 		goto err_out;
 1793              		.loc 1 782 0
 1794 01e2 9E42     		cmp	r6, r3
 1795 01e4 28BF     		it	cs
 1796 01e6 1E46     		movcs	r6, r3
 1797 01e8 B245     		cmp	r10, r6
 1798 01ea 00F29080 		bhi	.L135
 788:le_phy.c      **** 	if (conn.supervision_timeout < MSEC(100) || conn.supervision_timeout > SEC(32))
 1799              		.loc 1 788 0
 1800 01ee 03FB0BF3 		mul	r3, r3, fp
ARM GAS  /tmp/ccbEq2sz.s 			page 55


 789:le_phy.c      **** 		goto err_out;
 1801              		.loc 1 789 0
 1802 01f2 A3F5742B 		sub	fp, r3, #999424
 788:le_phy.c      **** 	if (conn.supervision_timeout < MSEC(100) || conn.supervision_timeout > SEC(32))
 1803              		.loc 1 788 0
 1804 01f6 6363     		str	r3, [r4, #52]
 789:le_phy.c      **** 		goto err_out;
 1805              		.loc 1 789 0
 1806 01f8 564B     		ldr	r3, .L160+64
 1807 01fa ABF5107B 		sub	fp, fp, #576
 1808 01fe 9B45     		cmp	fp, r3
 1809 0200 00F28580 		bhi	.L135
 793:le_phy.c      **** 	if (conn.remapping.total_channels == 0)
 1810              		.loc 1 793 0
 1811 0204 5449     		ldr	r1, .L160+68
 1812 0206 05F11E00 		add	r0, r5, #30
 1813 020a FFF7FEFF 		bl	le_parse_channel_map
 1814              	.LVL145:
 794:le_phy.c      **** 		goto err_out;
 1815              		.loc 1 794 0
 1816 020e D4F8FC30 		ldr	r3, [r4, #252]
 1817 0212 002B     		cmp	r3, #0
 1818 0214 7BD0     		beq	.L135
 1819              	.LBB102:
 1820              	.LBB103:
 203:le_phy.c      **** 	conn_event.opened = 0;
 1821              		.loc 1 203 0
 1822 0216 0022     		movs	r2, #0
 1823              	.LBE103:
 1824              	.LBE102:
 1825              	.LBB106:
 1826              	.LBB107:
 564:le_phy.c      **** }
 1827              		.loc 1 564 0
 1828 0218 D9F80030 		ldr	r3, [r9]
 1829 021c 23F04003 		bic	r3, r3, #64
 1830 0220 C9F80030 		str	r3, [r9]
 1831              	.LBE107:
 1832              	.LBE106:
 1833              	.LBB108:
 1834              	.LBB104:
 203:le_phy.c      **** 	conn_event.opened = 0;
 1835              		.loc 1 203 0
 1836 0224 4D4B     		ldr	r3, .L160+72
 1837              	.LBE104:
 1838              	.LBE108:
 801:le_phy.c      **** 			conn.win_offset + USEC(1250) - RX_WARMUP_TIME);
 1839              		.loc 1 801 0
 1840 0226 E06B     		ldr	r0, [r4, #60]
 1841              	.LBB109:
 1842              	.LBB105:
 203:le_phy.c      **** 	conn_event.opened = 0;
 1843              		.loc 1 203 0
 1844 0228 5A60     		str	r2, [r3, #4]
 204:le_phy.c      **** }
 1845              		.loc 1 204 0
 1846 022a 9A60     		str	r2, [r3, #8]
ARM GAS  /tmp/ccbEq2sz.s 			page 56


 1847              	.LBE105:
 1848              	.LBE109:
 801:le_phy.c      **** 			conn.win_offset + USEC(1250) - RX_WARMUP_TIME);
 1849              		.loc 1 801 0
 1850 022c 5022     		movs	r2, #80
 1851 022e D5F80C31 		ldr	r3, [r5, #268]
 1852 0232 00F51A50 		add	r0, r0, #9856
 1853 0236 2C30     		adds	r0, r0, #44
 1854 0238 1844     		add	r0, r0, r3
 1855 023a D5F80431 		ldr	r3, [r5, #260]
 1856 023e 02FB0300 		mla	r0, r2, r3, r0
 1857 0242 FFF7FEFF 		bl	timer1_set_match
 1858              	.LVL146:
 1859 0246 14E0     		b	.L128
 1860              	.LVL147:
 1861              	.L123:
 1862              	.LBE101:
 1863              	.LBE100:
 1864              	.LBE99:
 1865              	.LBE98:
 938:le_phy.c      **** 				blink(0, 1, 0); // RX LED
 1866              		.loc 1 938 0
 1867 0248 059D     		ldr	r5, [sp, #20]
 1868              	.LBB117:
 1869              	.LBB90:
 881:le_phy.c      **** 		return 1;
 1870              		.loc 1 881 0
 1871 024a B5F81001 		ldrh	r0, [r5, #272]
 1872 024e FFF7FEFF 		bl	btle_channel_index
 1873              	.LVL148:
 1874 0252 2428     		cmp	r0, #36
 1875 0254 7FF640AF 		bls	.L126
 1876 0258 2B78     		ldrb	r3, [r5]	@ zero_extendqisi2
 1877 025a 03F00F02 		and	r2, r3, #15
 1878 025e 062A     		cmp	r2, #6
 1879 0260 07D8     		bhi	.L128
 1880 0262 0123     		movs	r3, #1
 1881 0264 9340     		lsls	r3, r3, r2
 1882 0266 13F0550F 		tst	r3, #85
 1883 026a 0AD1     		bne	.L129
 1884 026c 13F02A0F 		tst	r3, #42
 1885 0270 11D1     		bne	.L130
 1886              	.L128:
 1887              	.LVL149:
 1888              	.LBE90:
 1889              	.LBE117:
 1890              	.LBB118:
 1891              	.LBB119:
 198:le_phy.c      **** }
 1892              		.loc 1 198 0
 1893 0272 0122     		movs	r2, #1
 1894 0274 059B     		ldr	r3, [sp, #20]
 1895 0276 C3F81821 		str	r2, [r3, #280]
 1896              	.LVL150:
 1897              	.L122:
 1898              	.LBE119:
 1899              	.LBE118:
ARM GAS  /tmp/ccbEq2sz.s 			page 57


 948:le_phy.c      **** 
 1900              		.loc 1 948 0
 1901 027a 0020     		movs	r0, #0
 1902 027c FFF7FEFF 		bl	handle_usb
 1903              	.LVL151:
 1904 0280 FEE6     		b	.L121
 1905              	.L129:
 1906              	.LBB120:
 1907              	.LBB91:
 891:le_phy.c      **** 				return 0;
 1908              		.loc 1 891 0
 1909 0282 D5F80431 		ldr	r3, [r5, #260]
 1910 0286 072B     		cmp	r3, #7
 1911 0288 F3D9     		bls	.L128
 893:le_phy.c      **** 			break;
 1912              		.loc 1 893 0
 1913 028a A81C     		adds	r0, r5, #2
 1914              	.L159:
 904:le_phy.c      **** 			break;
 1915              		.loc 1 904 0
 1916 028c FFF7FEFF 		bl	bd_addr_cmp
 1917              	.LVL152:
 903:le_phy.c      **** 				   bd_addr_cmp(&buf->data[8]);
 1918              		.loc 1 903 0
 1919 0290 0028     		cmp	r0, #0
 1920 0292 EED0     		beq	.L128
 1921 0294 20E7     		b	.L126
 1922              	.L130:
 901:le_phy.c      **** 				return 0;
 1923              		.loc 1 901 0
 1924 0296 D5F80431 		ldr	r3, [r5, #260]
 1925 029a 0D2B     		cmp	r3, #13
 1926 029c E9D9     		bls	.L128
 903:le_phy.c      **** 				   bd_addr_cmp(&buf->data[8]);
 1927              		.loc 1 903 0
 1928 029e A81C     		adds	r0, r5, #2
 1929 02a0 FFF7FEFF 		bl	bd_addr_cmp
 1930              	.LVL153:
 1931 02a4 0028     		cmp	r0, #0
 1932 02a6 7FF417AF 		bne	.L126
 904:le_phy.c      **** 			break;
 1933              		.loc 1 904 0
 1934 02aa 05F10800 		add	r0, r5, #8
 1935 02ae EDE7     		b	.L159
 1936              	.LVL154:
 1937              	.L157:
 1938              	.LBE91:
 1939              	.LBE120:
 1940              	.LBB121:
 1941              	.LBB97:
 716:le_phy.c      **** 	f->clk100ns = packet->timestamp;
 1942              		.loc 1 716 0
 1943 02b0 4FF0000A 		mov	r10, #0
 714:le_phy.c      **** 
 1944              		.loc 1 714 0
 1945 02b4 0123     		movs	r3, #1
 716:le_phy.c      **** 	f->clk100ns = packet->timestamp;
ARM GAS  /tmp/ccbEq2sz.s 			page 58


 1946              		.loc 1 716 0
 1947 02b6 80F803A0 		strb	r10, [r0, #3]
 714:le_phy.c      **** 
 1948              		.loc 1 714 0
 1949 02ba 0370     		strb	r3, [r0]
 717:le_phy.c      **** 
 1950              		.loc 1 717 0
 1951 02bc D8F80C31 		ldr	r3, [r8, #268]
 725:le_phy.c      **** 	memcpy(f->data+4, packet->data, DMA_SIZE-4);
 1952              		.loc 1 725 0
 1953 02c0 08F58A71 		add	r1, r8, #276
 717:le_phy.c      **** 
 1954              		.loc 1 717 0
 1955 02c4 4360     		str	r3, [r0, #4]
 719:le_phy.c      **** 	f->rssi_avg = packet->rssi_sum / packet->size;
 1956              		.loc 1 719 0
 1957 02c6 D8F81031 		ldr	r3, [r8, #272]
 725:le_phy.c      **** 	memcpy(f->data+4, packet->data, DMA_SIZE-4);
 1958              		.loc 1 725 0
 1959 02ca 0E30     		adds	r0, r0, #14
 1960              	.LVL155:
 719:le_phy.c      **** 	f->rssi_avg = packet->rssi_sum / packet->size;
 1961              		.loc 1 719 0
 1962 02cc 623B     		subs	r3, r3, #98
 1963 02ce 00F80C3C 		strb	r3, [r0, #-12]
 720:le_phy.c      **** 	f->rssi_min = packet->rssi_min;
 1964              		.loc 1 720 0
 1965 02d2 D8F80421 		ldr	r2, [r8, #260]
 1966 02d6 D8F82031 		ldr	r3, [r8, #288]
 1967 02da B3FBF2F3 		udiv	r3, r3, r2
 1968 02de 00F8043C 		strb	r3, [r0, #-4]
 721:le_phy.c      **** 	f->rssi_max = packet->rssi_max;
 1969              		.loc 1 721 0
 1970 02e2 98F81C31 		ldrb	r3, [r8, #284]	@ zero_extendqisi2
 725:le_phy.c      **** 	memcpy(f->data+4, packet->data, DMA_SIZE-4);
 1971              		.loc 1 725 0
 1972 02e6 0422     		movs	r2, #4
 721:le_phy.c      **** 	f->rssi_max = packet->rssi_max;
 1973              		.loc 1 721 0
 1974 02e8 00F8053C 		strb	r3, [r0, #-5]
 722:le_phy.c      **** 	f->rssi_count = 0;
 1975              		.loc 1 722 0
 1976 02ec 98F81D31 		ldrb	r3, [r8, #285]	@ zero_extendqisi2
 723:le_phy.c      **** 
 1977              		.loc 1 723 0
 1978 02f0 00F803AC 		strb	r10, [r0, #-3]
 722:le_phy.c      **** 	f->rssi_count = 0;
 1979              		.loc 1 722 0
 1980 02f4 00F8063C 		strb	r3, [r0, #-6]
 725:le_phy.c      **** 	memcpy(f->data+4, packet->data, DMA_SIZE-4);
 1981              		.loc 1 725 0
 1982 02f8 FFF7FEFF 		bl	memcpy
 1983              	.LVL156:
 726:le_phy.c      **** 
 1984              		.loc 1 726 0
 1985 02fc 2E22     		movs	r2, #46
 1986 02fe 4146     		mov	r1, r8
ARM GAS  /tmp/ccbEq2sz.s 			page 59


 1987 0300 05F11200 		add	r0, r5, #18
 1988 0304 FFF7FEFF 		bl	memcpy
 1989              	.LVL157:
 728:le_phy.c      **** 
 1990              		.loc 1 728 0
 1991 0308 85F801A0 		strb	r10, [r5, #1]
 1992 030c FCE6     		b	.L124
 1993              	.LVL158:
 1994              	.L135:
 1995              	.LDL1:
 1996              	.LBE97:
 1997              	.LBE121:
 1998              	.LBB122:
 1999              	.LBB116:
 2000              	.LBB111:
 2001              	.LBB110:
 807:le_phy.c      **** }
 2002              		.loc 1 807 0
 2003 030e FFF7FEFF 		bl	reset_conn
 2004              	.LVL159:
 2005 0312 AEE7     		b	.L128
 2006              	.L161:
 2007              		.align	2
 2008              	.L160:
 2009 0314 00000000 		.word	.LANCHOR0
 2010 0318 00000000 		.word	packet_queue
 2011 031c 04800040 		.word	1073774596
 2012 0320 0C800040 		.word	1073774604
 2013 0324 00E100E0 		.word	-536813312
 2014 0328 00000000 		.word	le_adv_channel
 2015 032c 00000000 		.word	rf_channel
 2016 0330 D6BE898E 		.word	-1903575338
 2017 0334 00000000 		.word	cancel_follow
 2018 0338 00000000 		.word	requested_mode
 2019 033c 3CC00920 		.word	537509948
 2020 0340 00000000 		.word	le
 2021 0344 38C00920 		.word	537509944
 2022 0348 08800040 		.word	1073774600
 2023 034c 1C800040 		.word	1073774620
 2024 0350 A0860100 		.word	100000
 2025 0354 C08D0313 		.word	319000000
 2026 0358 40000000 		.word	.LANCHOR0+64
 2027 035c 00000000 		.word	conn_event
 2028 0360 80E100E0 		.word	-536813184
 2029 0364 14800040 		.word	1073774612
 2030              	.LVL160:
 2031              	.L132:
 2032              	.LBE110:
 2033              	.LBE111:
 849:le_phy.c      **** 			switch (buf->data[2]) {
 2034              		.loc 1 849 0
 2035 0368 01F00301 		and	r1, r1, #3
 2036 036c 0329     		cmp	r1, #3
 2037 036e 80D1     		bne	.L128
 2038 0370 95F80180 		ldrb	r8, [r5, #1]	@ zero_extendqisi2
 2039 0374 B8F1000F 		cmp	r8, #0
 2040 0378 3FF47BAF 		beq	.L128
ARM GAS  /tmp/ccbEq2sz.s 			page 60


 850:le_phy.c      **** 				// LE_CONNECTION_UPDATE_REQ -- update connection parameters
 2041              		.loc 1 850 0
 2042 037c AB78     		ldrb	r3, [r5, #2]	@ zero_extendqisi2
 2043 037e A3B1     		cbz	r3, .L136
 2044 0380 012B     		cmp	r3, #1
 2045 0382 7FF476AF 		bne	.L128
 859:le_phy.c      **** 						channel_map_update_handler(buf);
 2046              		.loc 1 859 0
 2047 0386 B8F1080F 		cmp	r8, #8
 2048 038a 7FF472AF 		bne	.L128
 2049              	.LVL161:
 2050              	.LBB112:
 2051              	.LBB113:
 830:le_phy.c      **** 	le_parse_channel_map(&buf->data[3], &conn.pending_remapping);
 2052              		.loc 1 830 0
 2053 038e 4146     		mov	r1, r8
 2054 0390 0222     		movs	r2, #2
 2055 0392 2846     		mov	r0, r5
 829:le_phy.c      **** 	conn.channel_map_update_instant = extract_field(buf, 8, 2);
 2056              		.loc 1 829 0
 2057 0394 C4F82031 		str	r3, [r4, #288]
 830:le_phy.c      **** 	le_parse_channel_map(&buf->data[3], &conn.pending_remapping);
 2058              		.loc 1 830 0
 2059 0398 FFF7FEFF 		bl	extract_field
 2060              	.LVL162:
 831:le_phy.c      **** }
 2061              		.loc 1 831 0
 2062 039c 2549     		ldr	r1, .L162
 830:le_phy.c      **** 	le_parse_channel_map(&buf->data[3], &conn.pending_remapping);
 2063              		.loc 1 830 0
 2064 039e A4F82401 		strh	r0, [r4, #292]	@ movhi
 831:le_phy.c      **** }
 2065              		.loc 1 831 0
 2066 03a2 E81C     		adds	r0, r5, #3
 2067 03a4 FFF7FEFF 		bl	le_parse_channel_map
 2068              	.LVL163:
 2069 03a8 63E7     		b	.L128
 2070              	.LVL164:
 2071              	.L136:
 2072              	.LBE113:
 2073              	.LBE112:
 853:le_phy.c      **** 						connection_update_handler(buf);
 2074              		.loc 1 853 0
 2075 03aa B8F10C0F 		cmp	r8, #12
 2076 03ae 7FF460AF 		bne	.L128
 2077              	.LVL165:
 2078              	.LBB114:
 2079              	.LBB115:
 811:le_phy.c      **** 	conn.win_offset          = extract_field(buf, 4, 2);
 2080              		.loc 1 811 0
 2081 03b2 0122     		movs	r2, #1
 2082 03b4 2846     		mov	r0, r5
 2083 03b6 FFF7FEFF 		bl	extract_field
 2084              	.LVL166:
 812:le_phy.c      **** 	conn.conn_update_pending_interval = extract_field(buf, 6, 2);
 2085              		.loc 1 812 0
 2086 03ba 0222     		movs	r2, #2
ARM GAS  /tmp/ccbEq2sz.s 			page 61


 811:le_phy.c      **** 	conn.win_offset          = extract_field(buf, 4, 2);
 2087              		.loc 1 811 0
 2088 03bc C6B2     		uxtb	r6, r0
 812:le_phy.c      **** 	conn.conn_update_pending_interval = extract_field(buf, 6, 2);
 2089              		.loc 1 812 0
 2090 03be 0421     		movs	r1, #4
 2091 03c0 2846     		mov	r0, r5
 811:le_phy.c      **** 	conn.win_offset          = extract_field(buf, 4, 2);
 2092              		.loc 1 811 0
 2093 03c2 84F83860 		strb	r6, [r4, #56]
 812:le_phy.c      **** 	conn.conn_update_pending_interval = extract_field(buf, 6, 2);
 2094              		.loc 1 812 0
 2095 03c6 FFF7FEFF 		bl	extract_field
 2096              	.LVL167:
 813:le_phy.c      **** 	conn.conn_update_pending_supervision_timeout = extract_field(buf, 10, 2);
 2097              		.loc 1 813 0
 2098 03ca 0222     		movs	r2, #2
 812:le_phy.c      **** 	conn.conn_update_pending_interval = extract_field(buf, 6, 2);
 2099              		.loc 1 812 0
 2100 03cc 8246     		mov	r10, r0
 2101 03ce E063     		str	r0, [r4, #60]
 813:le_phy.c      **** 	conn.conn_update_pending_supervision_timeout = extract_field(buf, 10, 2);
 2102              		.loc 1 813 0
 2103 03d0 0621     		movs	r1, #6
 2104 03d2 2846     		mov	r0, r5
 2105 03d4 FFF7FEFF 		bl	extract_field
 2106              	.LVL168:
 814:le_phy.c      **** 	conn.conn_update_instant = extract_field(buf, 12, 2);
 2107              		.loc 1 814 0
 2108 03d8 0222     		movs	r2, #2
 813:le_phy.c      **** 	conn.conn_update_pending_supervision_timeout = extract_field(buf, 10, 2);
 2109              		.loc 1 813 0
 2110 03da C4F81401 		str	r0, [r4, #276]
 2111 03de 0390     		str	r0, [sp, #12]
 814:le_phy.c      **** 	conn.conn_update_instant = extract_field(buf, 12, 2);
 2112              		.loc 1 814 0
 2113 03e0 0A21     		movs	r1, #10
 2114 03e2 2846     		mov	r0, r5
 2115 03e4 FFF7FEFF 		bl	extract_field
 2116              	.LVL169:
 815:le_phy.c      **** 
 2117              		.loc 1 815 0
 2118 03e8 0222     		movs	r2, #2
 814:le_phy.c      **** 	conn.conn_update_instant = extract_field(buf, 12, 2);
 2119              		.loc 1 814 0
 2120 03ea 8346     		mov	fp, r0
 2121 03ec C4F81801 		str	r0, [r4, #280]
 815:le_phy.c      **** 
 2122              		.loc 1 815 0
 2123 03f0 4146     		mov	r1, r8
 2124 03f2 2846     		mov	r0, r5
 2125 03f4 FFF7FEFF 		bl	extract_field
 2126              	.LVL170:
 820:le_phy.c      **** 	conn.win_offset *= USEC(1250);
 2127              		.loc 1 820 0
 2128 03f8 06EB4602 		add	r2, r6, r6, lsl #1
 2129 03fc 06EB8202 		add	r2, r6, r2, lsl #2
ARM GAS  /tmp/ccbEq2sz.s 			page 62


 2130 0400 06EB8206 		add	r6, r6, r2, lsl #2
 821:le_phy.c      **** 	conn.conn_update_pending_interval *= USEC(1250);
 2131              		.loc 1 821 0
 2132 0404 43F2D402 		movw	r2, #12500
 822:le_phy.c      **** 	conn.conn_update_pending_supervision_timeout *= MSEC(10);
 2133              		.loc 1 822 0
 2134 0408 039B     		ldr	r3, [sp, #12]
 821:le_phy.c      **** 	conn.conn_update_pending_interval *= USEC(1250);
 2135              		.loc 1 821 0
 2136 040a 02FB0AF1 		mul	r1, r2, r10
 822:le_phy.c      **** 	conn.conn_update_pending_supervision_timeout *= MSEC(10);
 2137              		.loc 1 822 0
 2138 040e 5343     		muls	r3, r2, r3
 2139 0410 C4F81431 		str	r3, [r4, #276]
 823:le_phy.c      **** 
 2140              		.loc 1 823 0
 2141 0414 084B     		ldr	r3, .L162+4
 820:le_phy.c      **** 	conn.win_offset *= USEC(1250);
 2142              		.loc 1 820 0
 2143 0416 B600     		lsls	r6, r6, #2
 823:le_phy.c      **** 
 2144              		.loc 1 823 0
 2145 0418 03FB0BF3 		mul	r3, r3, fp
 2146 041c C4F81831 		str	r3, [r4, #280]
 825:le_phy.c      **** }
 2147              		.loc 1 825 0
 2148 0420 0123     		movs	r3, #1
 815:le_phy.c      **** 
 2149              		.loc 1 815 0
 2150 0422 A4F81C01 		strh	r0, [r4, #284]	@ movhi
 820:le_phy.c      **** 	conn.win_offset *= USEC(1250);
 2151              		.loc 1 820 0
 2152 0426 84F83860 		strb	r6, [r4, #56]
 821:le_phy.c      **** 	conn.conn_update_pending_interval *= USEC(1250);
 2153              		.loc 1 821 0
 2154 042a E163     		str	r1, [r4, #60]
 825:le_phy.c      **** }
 2155              		.loc 1 825 0
 2156 042c C4F81031 		str	r3, [r4, #272]
 2157 0430 1FE7     		b	.L128
 2158              	.L163:
 2159 0432 00BF     		.align	2
 2160              	.L162:
 2161 0434 28010000 		.word	.LANCHOR0+296
 2162 0438 A0860100 		.word	100000
 2163              	.LBE115:
 2164              	.LBE114:
 2165              	.LBE116:
 2166              	.LBE122:
 2167              	.LBE125:
 2168              		.cfi_endproc
 2169              	.LFE30:
 2171              		.comm	conn_event,12,4
 2172              		.global	conn
 2173              		.comm	packet_queue,48,4
 2174              		.comm	le_dma_dest,2,1
 2175              		.comm	rf_channel,2,2
ARM GAS  /tmp/ccbEq2sz.s 			page 63


 2176              		.comm	rx_err,4,4
 2177              		.comm	rx_tc,4,4
 2178              		.comm	idle_rxbuf,4,4
 2179              		.comm	active_rxbuf,4,4
 2180              		.comm	rxbuf2,50,1
 2181              		.comm	rxbuf1,50,1
 2182              		.comm	clkn_next_drift_fix,4,4
 2183              		.comm	clkn_last_drift_fix,4,4
 2184              		.comm	clk_drift_correction,2,2
 2185              		.comm	clk_drift_ppm,2,2
 2186              		.comm	clk100ns_offset,2,2
 2187              		.comm	clkn_offset,4,4
 2188              		.comm	last_hop,4,4
 2189              		.comm	clkn,4,4
 2190              		.section	.rodata
 2191              		.set	.LANCHOR1,. + 0
 2194              	whitening_index:
 2195 0000 46       		.byte	70
 2196 0001 3E       		.byte	62
 2197 0002 78       		.byte	120
 2198 0003 6F       		.byte	111
 2199 0004 4D       		.byte	77
 2200 0005 2E       		.byte	46
 2201 0006 0F       		.byte	15
 2202 0007 65       		.byte	101
 2203 0008 42       		.byte	66
 2204 0009 27       		.byte	39
 2205 000a 1F       		.byte	31
 2206 000b 1A       		.byte	26
 2207 000c 50       		.byte	80
 2208 000d 53       		.byte	83
 2209 000e 7D       		.byte	125
 2210 000f 59       		.byte	89
 2211 0010 0A       		.byte	10
 2212 0011 23       		.byte	35
 2213 0012 08       		.byte	8
 2214 0013 36       		.byte	54
 2215 0014 7A       		.byte	122
 2216 0015 11       		.byte	17
 2217 0016 21       		.byte	33
 2218 0017 00       		.byte	0
 2219 0018 3A       		.byte	58
 2220 0019 73       		.byte	115
 2221 001a 06       		.byte	6
 2222 001b 5E       		.byte	94
 2223 001c 56       		.byte	86
 2224 001d 31       		.byte	49
 2225 001e 34       		.byte	52
 2226 001f 14       		.byte	20
 2227 0020 28       		.byte	40
 2228 0021 1B       		.byte	27
 2229 0022 54       		.byte	84
 2230 0023 5A       		.byte	90
 2231 0024 3F       		.byte	63
 2232 0025 70       		.byte	112
 2233 0026 2F       		.byte	47
 2234 0027 66       		.byte	102
ARM GAS  /tmp/ccbEq2sz.s 			page 64


 2237              	whitening:
 2238 0028 01       		.byte	1
 2239 0029 01       		.byte	1
 2240 002a 01       		.byte	1
 2241 002b 01       		.byte	1
 2242 002c 00       		.byte	0
 2243 002d 01       		.byte	1
 2244 002e 00       		.byte	0
 2245 002f 01       		.byte	1
 2246 0030 00       		.byte	0
 2247 0031 01       		.byte	1
 2248 0032 00       		.byte	0
 2249 0033 00       		.byte	0
 2250 0034 00       		.byte	0
 2251 0035 00       		.byte	0
 2252 0036 01       		.byte	1
 2253 0037 00       		.byte	0
 2254 0038 01       		.byte	1
 2255 0039 01       		.byte	1
 2256 003a 00       		.byte	0
 2257 003b 01       		.byte	1
 2258 003c 01       		.byte	1
 2259 003d 01       		.byte	1
 2260 003e 01       		.byte	1
 2261 003f 00       		.byte	0
 2262 0040 00       		.byte	0
 2263 0041 01       		.byte	1
 2264 0042 01       		.byte	1
 2265 0043 01       		.byte	1
 2266 0044 00       		.byte	0
 2267 0045 00       		.byte	0
 2268 0046 01       		.byte	1
 2269 0047 00       		.byte	0
 2270 0048 01       		.byte	1
 2271 0049 00       		.byte	0
 2272 004a 01       		.byte	1
 2273 004b 01       		.byte	1
 2274 004c 00       		.byte	0
 2275 004d 00       		.byte	0
 2276 004e 01       		.byte	1
 2277 004f 01       		.byte	1
 2278 0050 00       		.byte	0
 2279 0051 00       		.byte	0
 2280 0052 00       		.byte	0
 2281 0053 00       		.byte	0
 2282 0054 00       		.byte	0
 2283 0055 01       		.byte	1
 2284 0056 01       		.byte	1
 2285 0057 00       		.byte	0
 2286 0058 01       		.byte	1
 2287 0059 01       		.byte	1
 2288 005a 00       		.byte	0
 2289 005b 01       		.byte	1
 2290 005c 00       		.byte	0
 2291 005d 01       		.byte	1
 2292 005e 01       		.byte	1
 2293 005f 01       		.byte	1
ARM GAS  /tmp/ccbEq2sz.s 			page 65


 2294 0060 00       		.byte	0
 2295 0061 01       		.byte	1
 2296 0062 00       		.byte	0
 2297 0063 00       		.byte	0
 2298 0064 00       		.byte	0
 2299 0065 01       		.byte	1
 2300 0066 01       		.byte	1
 2301 0067 00       		.byte	0
 2302 0068 00       		.byte	0
 2303 0069 01       		.byte	1
 2304 006a 00       		.byte	0
 2305 006b 00       		.byte	0
 2306 006c 00       		.byte	0
 2307 006d 01       		.byte	1
 2308 006e 00       		.byte	0
 2309 006f 00       		.byte	0
 2310 0070 00       		.byte	0
 2311 0071 00       		.byte	0
 2312 0072 00       		.byte	0
 2313 0073 00       		.byte	0
 2314 0074 01       		.byte	1
 2315 0075 00       		.byte	0
 2316 0076 00       		.byte	0
 2317 0077 01       		.byte	1
 2318 0078 00       		.byte	0
 2319 0079 00       		.byte	0
 2320 007a 01       		.byte	1
 2321 007b 01       		.byte	1
 2322 007c 00       		.byte	0
 2323 007d 01       		.byte	1
 2324 007e 00       		.byte	0
 2325 007f 00       		.byte	0
 2326 0080 01       		.byte	1
 2327 0081 01       		.byte	1
 2328 0082 01       		.byte	1
 2329 0083 01       		.byte	1
 2330 0084 00       		.byte	0
 2331 0085 01       		.byte	1
 2332 0086 01       		.byte	1
 2333 0087 01       		.byte	1
 2334 0088 00       		.byte	0
 2335 0089 00       		.byte	0
 2336 008a 00       		.byte	0
 2337 008b 00       		.byte	0
 2338 008c 01       		.byte	1
 2339 008d 01       		.byte	1
 2340 008e 01       		.byte	1
 2341 008f 01       		.byte	1
 2342 0090 01       		.byte	1
 2343 0091 01       		.byte	1
 2344 0092 01       		.byte	1
 2345 0093 00       		.byte	0
 2346 0094 00       		.byte	0
 2347 0095 00       		.byte	0
 2348 0096 01       		.byte	1
 2349 0097 01       		.byte	1
 2350 0098 01       		.byte	1
ARM GAS  /tmp/ccbEq2sz.s 			page 66


 2351 0099 00       		.byte	0
 2352 009a 01       		.byte	1
 2353 009b 01       		.byte	1
 2354 009c 00       		.byte	0
 2355 009d 00       		.byte	0
 2356 009e 00       		.byte	0
 2357 009f 01       		.byte	1
 2358 00a0 00       		.byte	0
 2359 00a1 01       		.byte	1
 2360 00a2 00       		.byte	0
 2361 00a3 00       		.byte	0
 2362 00a4 01       		.byte	1
 2363 00a5 00       		.byte	0
 2364 00a6 01       		.byte	1
 2365              		.bss
 2366              		.align	2
 2367              		.set	.LANCHOR0,. + 0
 2370              	le_dma_lli.4936:
 2371 0000 00000000 		.space	32
 2371      00000000 
 2371      00000000 
 2371      00000000 
 2371      00000000 
 2374              	conn:
 2375 0020 00000000 		.space	456
 2375      00000000 
 2375      00000000 
 2375      00000000 
 2375      00000000 
 2378              	le_buffer_pool:
 2379 01e8 00000000 		.space	1168
 2379      00000000 
 2379      00000000 
 2379      00000000 
 2379      00000000 
 2382              	current_rxbuf:
 2383 0678 00000000 		.space	4
 2384              		.section	.rodata.str1.1,"aMS",%progbits,1
 2385              	.LC0:
 2386 0000 66696E69 		.ascii	"finish_conn_event\012\000"
 2386      73685F63 
 2386      6F6E6E5F 
 2386      6576656E 
 2386      740A00
 2387              	.LC1:
 2388 0013 6C655F44 		.ascii	"le_DMA_IRQHandler\012\000"
 2388      4D415F49 
 2388      52514861 
 2388      6E646C65 
 2388      720A00
 2389              		.text
 2390              	.Letext0:
 2391              		.file 2 "/usr/lib/gcc/arm-none-eabi/6.3.1/include/stddef.h"
 2392              		.file 3 "/usr/include/newlib/sys/lock.h"
 2393              		.file 4 "/usr/include/newlib/sys/_types.h"
 2394              		.file 5 "/usr/include/newlib/sys/reent.h"
 2395              		.file 6 "/usr/include/newlib/stdlib.h"
ARM GAS  /tmp/ccbEq2sz.s 			page 67


 2396              		.file 7 "/usr/lib/gcc/arm-none-eabi/6.3.1/include/stdint-gcc.h"
 2397              		.file 8 "../../host/libubertooth/src/ubertooth_interface.h"
 2398              		.file 9 "../common/ubertooth.h"
 2399              		.file 10 "ubertooth_clock.h"
 2400              		.file 11 "ubertooth_dma.h"
 2401              		.file 12 "bluetooth_le.h"
 2402              		.file 13 "queue.h"
 2403              		.file 14 "ubertooth_usb.h"
 2404              		.file 15 "/usr/include/newlib/string.h"
ARM GAS  /tmp/ccbEq2sz.s 			page 68


DEFINED SYMBOLS
                            *ABS*:0000000000000000 le_phy.c
     /tmp/ccbEq2sz.s:16     .text.le_dma_init:0000000000000000 $t
     /tmp/ccbEq2sz.s:22     .text.le_dma_init:0000000000000000 le_dma_init
     /tmp/ccbEq2sz.s:81     .text.le_dma_init:0000000000000034 $d
                            *COM*:0000000000000002 le_dma_dest
     /tmp/ccbEq2sz.s:90     .text.timer1_set_match:0000000000000000 $t
     /tmp/ccbEq2sz.s:96     .text.timer1_set_match:0000000000000000 timer1_set_match
     /tmp/ccbEq2sz.s:118    .text.timer1_set_match:0000000000000010 $d
     /tmp/ccbEq2sz.s:124    .text.timer1_wait_fs_lock:0000000000000000 $t
     /tmp/ccbEq2sz.s:130    .text.timer1_wait_fs_lock:0000000000000000 timer1_wait_fs_lock
     /tmp/ccbEq2sz.s:151    .text.timer1_wait_fs_lock:0000000000000018 $d
     /tmp/ccbEq2sz.s:157    .text.extract_field:0000000000000000 $t
     /tmp/ccbEq2sz.s:163    .text.extract_field:0000000000000000 extract_field
     /tmp/ccbEq2sz.s:206    .text.bd_addr_cmp:0000000000000000 $t
     /tmp/ccbEq2sz.s:212    .text.bd_addr_cmp:0000000000000000 bd_addr_cmp
     /tmp/ccbEq2sz.s:254    .text.bd_addr_cmp:0000000000000024 $d
     /tmp/ccbEq2sz.s:259    .text.reset_conn:0000000000000000 $t
     /tmp/ccbEq2sz.s:265    .text.reset_conn:0000000000000000 reset_conn
     /tmp/ccbEq2sz.s:289    .text.reset_conn:0000000000000018 $d
     /tmp/ccbEq2sz.s:295    .text.buffer_get:0000000000000000 $t
     /tmp/ccbEq2sz.s:301    .text.buffer_get:0000000000000000 buffer_get
     /tmp/ccbEq2sz.s:369    .text.buffer_get:0000000000000054 $d
     /tmp/ccbEq2sz.s:374    .text.le_cc2400_init_rf:0000000000000000 $t
     /tmp/ccbEq2sz.s:380    .text.le_cc2400_init_rf:0000000000000000 le_cc2400_init_rf
     /tmp/ccbEq2sz.s:463    .text.le_cc2400_init_rf:0000000000000070 $d
                            *COM*:0000000000000002 rf_channel
     /tmp/ccbEq2sz.s:469    .text.change_channel:0000000000000000 $t
     /tmp/ccbEq2sz.s:475    .text.change_channel:0000000000000000 change_channel
     /tmp/ccbEq2sz.s:616    .text.change_channel:00000000000000ac $d
     /tmp/ccbEq2sz.s:626    .text.finish_conn_event:0000000000000000 $t
     /tmp/ccbEq2sz.s:632    .text.finish_conn_event:0000000000000000 finish_conn_event
     /tmp/ccbEq2sz.s:787    .text.finish_conn_event:00000000000000b0 $d
                            *COM*:000000000000000c conn_event
     /tmp/ccbEq2sz.s:796    .text.le_DMA_IRQHandler:0000000000000000 $t
     /tmp/ccbEq2sz.s:803    .text.le_DMA_IRQHandler:0000000000000000 le_DMA_IRQHandler
     /tmp/ccbEq2sz.s:1145   .text.le_DMA_IRQHandler:00000000000001a8 $d
                            *COM*:0000000000000030 packet_queue
     /tmp/ccbEq2sz.s:1166   .text.TIMER1_IRQHandler:0000000000000000 $t
     /tmp/ccbEq2sz.s:1173   .text.TIMER1_IRQHandler:0000000000000000 TIMER1_IRQHandler
     /tmp/ccbEq2sz.s:1385   .text.TIMER1_IRQHandler:0000000000000128 $d
     /tmp/ccbEq2sz.s:1397   .text.le_phy_main:0000000000000000 $t
     /tmp/ccbEq2sz.s:1404   .text.le_phy_main:0000000000000000 le_phy_main
     /tmp/ccbEq2sz.s:2009   .text.le_phy_main:0000000000000314 $d
     /tmp/ccbEq2sz.s:2035   .text.le_phy_main:0000000000000368 $t
     /tmp/ccbEq2sz.s:2161   .text.le_phy_main:0000000000000434 $d
     /tmp/ccbEq2sz.s:2374   .bss:0000000000000020 conn
                            *COM*:0000000000000004 rx_err
                            *COM*:0000000000000004 rx_tc
                            *COM*:0000000000000004 idle_rxbuf
                            *COM*:0000000000000004 active_rxbuf
                            *COM*:0000000000000032 rxbuf2
                            *COM*:0000000000000032 rxbuf1
                            *COM*:0000000000000004 clkn_next_drift_fix
                            *COM*:0000000000000004 clkn_last_drift_fix
                            *COM*:0000000000000002 clk_drift_correction
                            *COM*:0000000000000002 clk_drift_ppm
ARM GAS  /tmp/ccbEq2sz.s 			page 69


                            *COM*:0000000000000002 clk100ns_offset
                            *COM*:0000000000000004 clkn_offset
                            *COM*:0000000000000004 last_hop
                            *COM*:0000000000000004 clkn
     /tmp/ccbEq2sz.s:2194   .rodata:0000000000000000 whitening_index
     /tmp/ccbEq2sz.s:2237   .rodata:0000000000000028 whitening
     /tmp/ccbEq2sz.s:2366   .bss:0000000000000000 $d
     /tmp/ccbEq2sz.s:2370   .bss:0000000000000000 le_dma_lli.4936
     /tmp/ccbEq2sz.s:2378   .bss:00000000000001e8 le_buffer_pool
     /tmp/ccbEq2sz.s:2382   .bss:0000000000000678 current_rxbuf
                     .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
le
memset
rbit
cc2400_set
cc2400_status
cc2400_strobe
dio_ssp_start
btle_channel_index_to_phys
le_map_channel
le_adv_channel
debug_printf
cancel_follow
cc2400_get
btle_channel_index
queue_insert
memcpy
clkn_disable
queue_init
usb_queue_init
dio_ssp_init
debug_uart_init
clkn_init
queue_remove
le_dewhiten
usb_enqueue
le_parse_channel_map
handle_usb
requested_mode
